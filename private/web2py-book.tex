
\documentclass[justified,sixbynine,notoc]{tufte-book}
\title{web2py\\{\small Complete Reference Manual, 5th Edition}}
\author{Massimo Di Pierro}
\publisher{Experts4Solutions}

% For nicely typeset tabular material
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{tocloft}
\usepackage{parskip}
\usepackage{upquote}

%\setlength\parskip{33pt}  % our strange value
%\usepackage{CJK}

\usepackage{natbib}
\setlength{\bibsep}{0.0pt}

\makeindex
\usepackage{listings}
\usepackage{url}
\usepackage[utf8x]{inputenc}

\sloppy\raggedbottom

\definecolor{lg}{rgb}{0.9,0.9,0.9}
\definecolor{dg}{rgb}{0.3,0.3,0.3}
\def\ft{\small\tt}
\def\inxx#1{\index{#1}}

\lstset{language=Python,
keywords={A,B,BEAUTIFY,BODY,BR,CAT,CENTER,CLEANUP,CODE,COL,COLGROUP,CRYPT,DAL,DIV,EM,EMBED,FIELDSET,FORM,Field,H1,H2,H3,H4,H5,H6,HEAD,HR,HTML,HTTP,I,IFRAME,IMG,INPUT,IS\_ALPHANUMERIC,IS\_DATE,IS\_DATETIME,IS\_DATETIME\_IN\_RANGE,IS\_DATE\_IN\_RANGE,IS\_DECIMAL\_IN\_RANGE,IS\_EMAIL,IS\_EMPTY\_OR,IS\_EQUAL\_TO,IS\_EXPR,IS\_FLOAT\_IN\_RANGE,IS\_IMAGE,IS\_INT\_IN\_RANGE,IS\_IN\_DB,IS\_IN\_SET,IS\_IPV4,IS\_LENGTH,IS\_LIST\_OF,IS\_LOWER,IS\_MATCH,IS\_NOT\_EMPTY,IS\_NOT\_IN\_DB,IS\_NULL\_OR,IS\_SLUG,IS\_STRONG,IS\_TIME,IS\_UPLOAD\_FILENAME,IS\_UPPER,IS\_URL,LABEL,LEGEND,LI,LINK,LOAD,MARKMIN,MENU,META,OBJECT,OL,ON,OPTGROUP,OPTION,P,PRE,SCRIPT,SELECT,SPAN,SQLDB,SQLFORM,SQLField,SQLTABLE,STYLE,T,TABLE,TAG,TBODY,TD,TEXTAREA,TFOOT,TH,THEAD,TITLE,TR,TT,UL,URL,XHTML,XML,embed64,local\_import,redirect,request,response,session,xmlescape,jQuery},
   breaklines=true, basicstyle=\ttfamily\color{black}\footnotesize,
   keywordstyle=\bf\ttfamily,
   commentstyle=\it\ttfamily,
   stringstyle=\color{dg}\it\ttfamily,
   numbers=left, numberstyle=\color{dg}\tiny, stepnumber=1, numbersep=5pt,
   % frame=lr,
   backgroundcolor=\color{lg},
   tabsize=4, showspaces=false,
   showstringspaces=false
   aboveskip=6pt,
   belowskip=-3pt
}
\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
% Generates the index
\begin{document}

\frontmatter

\maketitle
\thispagestyle{empty}
\setlength{\parindent}{0pt}
\setlength{\parskip}{2mm}
{\footnotesize
\vskip 1in
Copyright 2008-2013 by Massimo Di Pierro. All rights reserved.
\vskip 1cm

THE CONTENT OF THIS BOOK IS PROVIDED UNDER THE TERMS OF THE CREATIVE COMMONS PUBLIC LICENSE BY-NC-ND 3.0.

\url{http://creativecommons.org/licenses/by-nc-nd/3.0/legalcode}

THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS.

Limit of Liability/Disclaimer of Warranty: While the publisher and
author have used their best efforts in preparing this book, they
make no representations or warranties with respect to the accuracy
or completeness of the contents of this book and specifically
disclaim any implied warranties of merchantability or fitness for a
particular purpose.  No warranty may be created ore extended by
sales representatives or written sales materials. 
The advice and strategies contained herein may not be
suitable for your situation. You should consult with a professional
where appropriate.  Neither the publisher nor author shall be liable 
for any loss of profit or any other commercial damages, including
but not limited to special, incidental, consequential, or other damages. \\ \\

For more information about appropriate use of this material contact:

\begin{verbatim}
Massimo Di Pierro
School of Computing
DePaul University
243 S Wabash Ave
Chicago, IL 60604 (USA)
Email: massimo.dipierro@gmail.com
\end{verbatim}

Library of Congress Cataloging-in-Publication Data: \\ \\
ISBN: 978-0-578-09793-0 \\
Build Date: \today
}

\newpage
%\begin{center}
%\noindent\fontsize{12}{18}\selectfont\itshape
\nohyphenation
\thispagestyle{empty}
\phantom{placeholder}
\vspace{2in}
\hskip 3in
{\it to my family}
%\end{center}
\newpage
\thispagestyle{empty}
\phantom {a}
\newpage

\setlength{\cftparskip}{\baselineskip}
\tableofcontents

\mainmatter
\begin{fullwidth}
%\begin{CJK*}{UTF8}{min}


\chapter*{Preface}
I believe that the ability to easily build high quality web applications is of critical importance for the growth of a free and open society. This prevents the biggest players from monopolizing the flow of information.

Hence I started the web2py project in 2007, primarily as a teaching tool with the goal of making web development easier, faster, and more secure. Over time, it has managed to win the affection of thousands of knowledgeable users and more than two hundred developers. Our collective effort has created one of the most full-featured Open Source Web Frameworks for enterprise web development.

As a result, in 2011, web2py won the Bossie Award for best Open Source Development Software, and in 2012 it won the Technology of the Year award from InfoWorld.

As you will learn in the following pages, web2py tries to lower the barrier of entry to web development by focusing on three main goals:

{\it Ease of use}. This means reducing the learning and deployment time as well as development and maintenance costs. This is why {\ft web2py} is a full-stack framework without dependencies. It requires no installation and has no configuration files. Everything works {\it out of the box}, including a web server, database and a web-based IDE that gives access to all the main features. The API includes just 12 core objects, which are easy to work with and memorize. It can interoperate with most web servers, databases and all Python libraries.

{\it Rapid development}. Every function of {\ft web2py} has a default behavior (which can be overridden).  For example, as soon as you have specified your data models, you will have access to a web-based database administration panel. Also, {\ft web2py} automatically generates forms for your data and it allows you to easily expose the data in HTML, XML, JSON, RSS, etc. {\ft web2py} provides some high level widgets such as the wiki and the grid to rapidly build complex applications.

{\it Security}. The {\ft web2py} database abstraction layer eliminates SQL Injections. The template language prevents Cross Site Scripting vulnerabilities. The forms generated by {\ft web2py} provide field validation and block Cross Site Request Forgeries. Passwords are always stored hashed. Sessions are stored server-side by default to prevent Cookie Tampering and session cookies are UUID to prevent Cookie Stealing.

{\ft web2py} is built from the user perspective and is constantly being optimized internally to become faster and leaner, whilst always maintaining {\it backwards compatibility}.

{\ft web2py} is free for you to use. If you benefit from it, we hope you will feel encouraged to {\it pay it forward} by contributing back to society in whatever form you choose.

\goodbreak\chapter{Introduction}
\noindent web2py~\cite{web2py}  is a free, open-source web framework for agile development of secure
database-driven web applications; it is written in Python~\cite{python}
and programmable in Python.
web2py is a full-stack framework,
meaning that it contains all the components you need
to build fully functional web applications.
\noindent web2py is designed to guide a web developer to follow good software engineering practices, such as using
the Model View Controller (MVC) pattern. web2py separates the data representation (the model)
from the data presentation (the view) and also from the application logic and workflow (the controller). web2py
provides libraries to help the developer design, implement, and test each of these three parts separately,
and makes them work together.
\noindent web2py is built for security. This means that it automatically addresses many of the issues
that can lead to security vulnerabilities, by following well established practices. For
example, it validates all input (to prevent injections), escapes all output (to prevent cross-site scripting),
renames uploaded files (to prevent directory traversal attacks).
web2py takes care of main security issues, so developers have less chances of introducing vulnerabilities.
\noindent web2py includes a Database Abstraction Layer (DAL) that writes SQL~\cite{sql-w}  dynamically so that you, the developer, don't have to. The DAL knows how to generate SQL transparently for
SQLite~\cite{sqlite}, MySQL~\cite{mysql}, PostgreSQL~\cite{postgres}, MSSQL~\cite{mssql},
FireBird~\cite{firebird}, Oracle~\cite{oracle}, IBM DB2~\cite{db2}, Informix~\cite{informix},
Ingres~\cite{ingresdb}, and MongoDB~\cite{mongodb}.
The DAL can also generate function calls for the Google Datastore
when running on the Google App Engine (GAE)~\cite{gae}.
Experimentally we support more databases and new ones are constantly added.
Please check on the web2py web site and mailing list for more recent adapters.
Once one or more database tables are defined, web2py automatically generates a fully functional web-based database
administration interface to access the database and the tables.
\noindent web2py differs from other web frameworks in that it is the only framework to fully embrace the Web 2.0
paradigm, where the web is the computer. In fact, web2py does not require installation or configuration; it
runs on any architecture that can run Python (Windows, Windows CE, Mac OS X, iOS, and Unix/Linux), and the development, deployment, and maintenance phases for the applications can be done via a local or remote web interface.  web2py runs with CPython (the C implementation) and PyPy (Python written in Python), on Python versions 2.5, 2.6, and 2.7, although "officially" it only supports 2.5 so that we can guarantee backward compatibility for applications.
\noindent web2py provides a ticketing system for error events. If an error occurs, a ticket is issued to the user,
and the error is logged for the administrator.
\noindent web2py is open source and released under the LGPL version 3 license.

Another important feature of web2py is that we, its developers, commit to maintain backward compatibility in future versions. We have done so since the first release of web2py in October, 2007.
New features have been added and bugs have been fixed, but if a program worked with web2py 1.0, that program will work even better today.

Here are some examples of web2py statements that illustrate its power and simplicity. The following code:
\begin{lstlisting}
db.define_table('person', Field('name'), Field('image', 'upload'))
\end{lstlisting}
\noindent creates a database table called "person" with two fields: "name", a string; and "image", something that
needs to be uploaded (the actual image). If the table already exists but does not match this definition, it is altered appropriately.

Given the table defined above, the following code:
\begin{lstlisting}
form = SQLFORM(db.person).process()
\end{lstlisting}
\noindent creates an insert form for this table that allows users to upload images. It also
validates a submitted form, renames the uploaded image in a secure way, stores the image in a file,
inserts the corresponding record in the database, prevents double submission, and eventually modifies
the form itself by adding error messages if the data submitted by the user does not pass validation.

This code embeds a fully working wiki with tags, search, tag cloud, permissions, media attachments, and oembed support:

\begin{lstlisting}
def index(): return auth.wiki()
\end{lstlisting}

The following code instead:
\begin{lstlisting}
@auth.requires_permission('read','person')
def f(): ....
\end{lstlisting}
\noindent prevents visitors from accessing the function {\ft f} unless the visitor is a member of a group whose members have permissions to "read" records of table "person". If the visitor is not logged in, he gets directed to a login page (provided by default by web2py).
\noindent web2py also supports components, i.e. actions which can be loaded in a view and interact with the visitor via Ajax without re-loading the entire page. This is done via a {\ft LOAD} helper which allows very modular design of applications; it is discussed in chapter 3 in the context of the wiki and, in some detail, in the last chapter of this book.

\goodbreak\section{Principles}

Python programming typically follows these basic principles:
\begin{itemize}
\item Don't repeat yourself (DRY).

\item There should be only one way of doing things.

\item Explicit is better than implicit.
\end{itemize}
\noindent web2py fully embraces the first two principles by forcing the developer to use sound software
engineering practices that discourage repetition of code. web2py guides the developer through almost
all the tasks common in web application development (creating and processing forms, managing
sessions, cookies, errors, etc.).

\inxx{request}
web2py differs from other frameworks with regard to the third principle, which sometimes conflicts
with the other two. In particular, web2py does not import user applications, but executes them in a predefined context.  This context exposes the Python keywords, as well as the web2py keywords.

To some this may appear as magic, but it should not.
Simply, in practice, some modules are already imported without you doing so.
web2py is trying to avoid the annoying characteristic of
other frameworks that force the developer to import the same modules at the top of every model and
controller.
\noindent web2py, by importing its own modules, saves time and prevents mistakes, thus following the spirit of "don't repeat yourself"
and "there should be only one way of doing things".

If the developer wishes to use other Python modules or third-party modules, those
modules must be imported explicitly, as in any other Python program.

\goodbreak\section{Web frameworks}

\inxx{PHP} \inxx{ASP} \inxx{JSP}

At its most fundamental level, a web application consists of a set of programs (or functions) that are
executed when the corresponding URL is visited.
The output of the program is returned to the visitor and rendered by the browser.

The purpose of web frameworks is to allow developers to build new apps quickly, easily and without mistakes.
This is done by providing APIs and tools that reduce and simplify the amount of coding that is required.

The two classic approaches for developing web applications are:
\begin{itemize}
\item Generating HTML~\cite{html-w}~\cite{html-o}  programmatically.

\item Embedding code into HTML pages.
\end{itemize}

The first model is the one that was followed, for example, by early CGI scripts.
The second model is followed, for example, by PHP~\cite{php}
(where the code is in PHP, a C-like language), ASP (where the code is in Visual Basic), and JSP (where the code is in Java).

Here is an example of a PHP program that, when executed, retrieves data from a database and
returns an HTML page showing the selected records:
\begin{lstlisting}[keywords={}]
<html><body><h1>Records</h1><?
  mysql_connect(localhost,username,password);
  @mysql_select_db(database) or die( "Unable to select database");
  $query="SELECT * FROM contacts";
  $result=mysql_query($query);
  mysql_close();
  $i=0;
  while ($i < mysql_numrows($result)) {
    $name=mysql_result($result,$i,"name");
    $phone=mysql_result($result,$i,"phone");
    echo "<b>$name</b><br>Phone:$phone<br /><br /><hr /><br />";
    $i++;
  }
?></body></html>
\end{lstlisting}

The problem with this approach is that code is embedded into HTML, but the very same code also needs to
generate additional HTML and to generate SQL statements
to query the database, entangling multiple layers of
the application and making it difficult to read and maintain. The situation is
even worse for Ajax applications, and the complexity grows with the number of pages (files) that make up
the application.

The functionality of the above example can be expressed in web2py with two lines of Python code:
\begin{lstlisting}
def index():
    return HTML(BODY(H1('Records'), db().select(db.contacts.ALL)))
\end{lstlisting}

In this simple example, the HTML page structure is represented programmatically by the {\ft HTML}, {\ft BODY}, and {\ft H1} objects; the database {\ft db} is queried by the {\ft select} command; finally, everything
is serialized into HTML.
Notice that {\ft db} is not a keyword but a user defined variable. We will use this name consistently to refer to a database connection to avoid confusion.

Web frameworks are typically categorized as one of two types: A "glued" framework is
built by assembling (gluing together) several third-party components. A "full-stack" framework is built
by creating components designed specifically to be tightly integrated and work together.
\noindent web2py is a full-stack framework. Almost all of its components are built from scratch and are designed to work
together, but they function just as well outside of the complete web2py framework. For example, the
Database Abstraction Layer (DAL) or the template language can be used independently of the
web2py framework by importing {\ft gluon.dal} or {\ft gluon.template} into your own Python applications. {\ft gluon} is the name of the web2py module that contains system libraries. Some web2py libraries,
such as building and processing forms from database tables, have dependencies on other portions
of web2py. web2py can also work with third-party Python libraries, including other template languages
and DALs, but they will not be as tightly integrated as the original components.

\goodbreak\section{Model-View-Controller}

\inxx{Model-View-Controller}
web2py encourages the developer to separate data representation (the model), data
presentation (the view) and the application workflow (the controller). Let's consider again the previous example
and see how to build a web2py application around it. Here is an example of the web2py MVC edit interface:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en0.png}\end{center}


The typical workflow of a request in web2py is described in the following diagram:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en100.png}\end{center}


In the diagram:
\begin{itemize}
\item The Server can be the web2py built-in web server or a third-party server, such as Apache. The Server handles multi-threading.

\item "main" is the main WSGI application. It performs all common tasks and wraps user applications. It deals with cookies, sessions, transactions, URL routing and reverse routing, and dispatching.
\end{itemize}
It can serve and stream static files if the web server is not doing it already.
\begin{itemize}
\item The Models, Views and Controller components make up the user application.

\item Multiple applications can be hosted in the same web2py instance.

\item The dashed arrows represent communication with the database engine(s). The database queries can be written in raw SQL (discouraged) or by using the web2py Database Abstraction Layer (recommended), so that web2py application code is not dependent on the specific database engine.

\item The dispatcher maps the requested URL to a function call in the controller. The output of the function can be a string or a dictionary of symbols (a hash table). The data in the dictionary is rendered by a view. If the visitor requests an HTML page (the default), the dictionary is rendered into an HTML page. If the visitor requests the same page in XML, web2py tries to find a view that can render the dictionary in XML. The developer can create views to render pages in any of the already supported protocols (HTML, XML, JSON, RSS, CSV, and RTF) or in additional custom protocols.

\item All calls are wrapped into a transaction, and any uncaught exception causes the transaction to be rolled back. If the request succeeds, the transaction is committed.

\item web2py also handles sessions and session cookies automatically, and when a transaction is committed, the session is also stored, unless specified otherwise.

\item It is possible to register recurrent tasks (via cron) to run at scheduled times and/or after the completion of certain actions. In this way it is possible to run long and compute-intensive tasks in the background without slowing down navigation.
\end{itemize}

Here is a minimal and complete MVC application, consisting of three files:

{\bf "db.py" is the model:}

\begin{lstlisting}
db = DAL('sqlite://storage.sqlite')
db.define_table('contact',
   Field('name'),
   Field('phone'))
\end{lstlisting}

It connects to the database (in this example a SQLite database stored in the {\ft storage.sqlite} file) and
defines a table called {\ft contact}. If the table does not exist, web2py creates it and, transparently
and in the background,
generates SQL code in the appropriate SQL dialect for the specific database engine used.
The developer can
see the generated SQL but does not need to change the code if the database back-end, which defaults to
SQLite, is replaced with MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Informix, Interbase, Ingres, and the Google App Engine (both SQL and NoSQL).

Once a table is defined and created, web2py also generates a fully functional web-based database
administration interface, called {\bf appadmin}, to access the database and the tables.

{\bf "default.py" is the controller:}

\begin{lstlisting}
def contacts():
    grid=SQLFORM.grid(db.contact, user_signature=False)
    return locals()
\end{lstlisting}

In web2py, URLs are mapped to Python modules and function calls. In this case, the controller contains
a single function (or "action") called {\ft contacts}. An action may
return a string (the returned web page) or a Python dictionary (a set of
{\ft key:value} pairs) or the set of local variables (as in this example).
If the function returns a dictionary, it is passed to a view with the same
name as the controller/function, which in turn renders the page.
In this example, the function {\ft contacts} generates a select/search/create/update/delete grid for table {\ft db.contact}
and returns the grid to the view.

{\bf "default/contacts.html" is the view:}

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Manage My Contacts</h1>
{{=grid}}
\end{lstlisting}

This view is called automatically by web2py after the associated controller function (action) is executed.
The purpose of this view is to render the variables in the returned dictionary (in our case {\ft grid}) into HTML.
The view file is written in HTML, but it embeds Python code delimited by the special {\ft \{\{} and {\ft \}\}}
delimiters. This is quite different from the PHP code example, because the only code
embedded into the HTML is "presentation layer" code. The "layout.html" file referenced at the top of the
view is provided by web2py and constitutes the basic layout for all web2py applications. The layout file can
easily be modified or replaced.

\goodbreak\section{Why web2py}
\noindent web2py is one of many web application frameworks, but it has compelling and unique features.
web2py was originally developed as a teaching tool, with the following primary motivations:
\begin{itemize}
\item Easy for users to learn server-side web development without compromising functionality. For this reason, web2py requires no installation and no configuration, has no dependencies (except for the source code distribution, which requires Python 2.5 and its standard library modules), and exposes most of its functionality via a Web interface, including an Integrated Development Environment with Debugger and database interface.

\item web2py has been stable from day one because it follows a top-down design; i.e., its API was designed before it was implemented. Even as new functionality has been added, web2py has never broken backwards compatibility, and it will not break compatibility when additional functionality is added in the future.

\item web2py proactively addresses the most important security issues which plague many modern web applications, as determined by OWASP~\cite{owasp}  below.

\item web2py is lightweight. Its core libraries, including the Database Abstraction Layer, the template language, and all the helpers amount to 1.4MB. The entire source code including sample applications and images amounts to 10.4MB.

\item web2py has a small footprint and is very fast. It uses the Rocket~\cite{rocket}  WSGI web server developed by Timothy Farrell. It is as fast as Apache with mod\_wsgi, and supports SSL and IPv6.

\item web2py uses Python syntax for models, controllers, and views, but does not import models and controllers (as all the other Python frameworks do) - instead it executes them. This means that apps can be installed, uninstalled, and modified without having to restart the web server (even in production), and different apps can coexist without their modules interfering with one another.

\item web2py uses a Database Abstraction Layer (DAL) instead of an Object Relational Mapper (ORM). From a conceptual point of view, this means that different database tables are mapped into different instances of one {\ft Table} class and not into different classes, while records are mapped into instances of one {\ft Row} class, not into instances of the corresponding table class. From a practical point of view, it means that SQL syntax maps almost one-to-one into DAL syntax, and there is no complex metaclass programming going on under the hood as in popular ORMs, which would add latency.
\end{itemize}

WSGI~\cite{wsgi-w}~\cite{wsgi-o} (Web Server Gateway Interface) is an emerging Python standard for communication between a web server and Python applications).

Here is a screenshot of the main web2py {\bf admin} interface:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en200.png}\end{center}


\goodbreak\section{Security}

\inxx{security}
The Open Web Application Security Project~\cite{owasp}  (OWASP) is a free and open worldwide community focused
on improving the security of application software.

OWASP has listed the top ten security issues that put web applications at risk.
That list is reproduced here, along with a description of how each issue is addressed by web2py:
\begin{itemize}
\item \inxx{cross site scripting}  "Cross Site Scripting (XSS): XSS flaws occur whenever an application takes user supplied data and sends it to a web browser without first validating or encoding that content. XSS allows attackers to execute scripts in the victim's browser which can hijack user sessions, deface web sites, possibly introduce worms, etc." {\it web2py, by default, escapes all variables rendered in the view, preventing XSS.}

\item \inxx{injection flaws} "Injection Flaws: Injection flaws, particularly SQL injection, are common in web applications. Injection occurs when user-supplied data is sent to an interpreter as part of a command or query. The attacker's hostile data tricks the interpreter into executing unintended commands or changing data." {\it web2py includes a Database Abstraction Layer that makes SQL injection impossible. Normally, SQL statements are not written by the developer.  Instead, SQL is generated dynamically by the DAL, ensuring that all inserted data is properly escaped.}

\item \inxx{malicious file execution} "Malicious File Execution: Code vulnerable to remote file inclusion (RFI) allows attackers to include hostile code and data, resulting in devastating attacks, such as total server compromise." {\it web2py allows only exposed functions to be executed, preventing malicious file execution. Imported functions are never exposed; only actions are exposed. web2py uses a Web-based administration interface which makes it very easy to keep track of what is exposed and what is not.}

\item \inxx{insecure object reference} "Insecure Direct Object Reference: A direct object reference occurs when a developer exposes a reference to an internal implementation object, such as a file, directory, database record, or key, as a URL or form parameter. Attackers can manipulate those references to access other objects without authorization." {\it web2py does not expose any internal objects; moreover, web2py validates all URLs, thus preventing directory traversal attacks. web2py also provides a simple mechanism to create forms that automatically validate all input values.}

\item \inxx{CSRF} "Cross Site Request Forgery (CSRF): A CSRF attack forces a logged-on victim's browser to send a pre-authenticated request to a vulnerable web application, which then forces the victim's browser to perform a hostile action to the benefit of the attacker. CSRF can be as powerful as the web application that it attacks." {\it web2py prevents CSRF as well as accidental double submission of forms by assigning a one-time random token to each form. Moreover web2py uses UUID for session cookie.}

\item \inxx{information leakage} \inxx{improper error handling} "Information Leakage and Improper Error Handling: Applications can unintentionally leak information about their configuration, internal workings, or violate privacy through a variety of application problems. Attackers use this weakness to steal sensitive data, or conduct more serious attacks." {\it web2py includes a ticketing system. No error can result in code being exposed to the users. All errors are logged and a ticket is issued to the user that allows error tracking. But errors and source code are accessible only to the administrator.}

\item "Broken Authentication and Session Management: Account credentials and session tokens are often not properly protected. Attackers compromise passwords, keys, or authentication tokens to assume other users' identities." {\it web2py provides a built-in mechanism for administrator authentication, and it manages sessions independently for each application. The administrative interface also forces the use of secure session cookies when the client is not "localhost". For applications, it includes a powerful Role Based Access Control API.}

\item \inxx{cryptographic store} "Insecure Cryptographic Storage: Web applications rarely use cryptographic functions properly to protect data and credentials. Attackers use weakly protected data to conduct identity theft and other crimes, such as credit card fraud." {\it web2py uses the MD5 or the HMAC+SHA-512 hash algorithms to protect stored passwords. Other algorithms are also available.}

\item \inxx{secure communications} "Insecure Communications: Applications frequently fail to encrypt network traffic when it is necessary to protect sensitive communications." {\it web2py includes the SSL-enabled~\cite{ssl}  Rocket WSGI server, but it can also use Apache or Lighttpd and mod\_ssl to provide SSL encryption of communications.}

\item \inxx{access restriction} "Failure to Restrict URL Access: Frequently an application only protects sensitive functionality by preventing the display of links or URLs to unauthorized users. Attackers can use this weakness to access and perform unauthorized operations by accessing those URLs directly." {\it web2py maps URL requests to Python modules and functions. web2py provides a mechanism for declaring which functions are public and which require authentication and authorization. The included Role Based Access Control API allow developers to restrict access to any function based on login, group membership or group based permissions. The permissions are very granular and can be combined with database filters to allow, for example, to give access to specific tables and/or records. web2py also allows digitally signed URL and provides API to digitally sign Ajax callbacks.}
\end{itemize}
\noindent web2py was reviewed for security and you can find the result of the review in ref.~\cite{pythonsecurity}.

\goodbreak\section{In the box}

You can download web2py from the official web site:

\begin{lstlisting}[keywords={}]
http://www.web2py.com
\end{lstlisting}
\noindent web2py is composed of the following components:
\begin{itemize}
\item {\bf libraries}: provide core functionality of web2py and are accessible programmatically.

\item {\bf web server}: the Rocket WSGI web server.

\item the {\bf admin} application: used to create, design, and manage other web2py applications. {\bf admin} provides a complete web-based Integrated Development Environment (IDE) for building web2py applications. It also includes other functionality, such as web-based testing and a web-based shell.

\item the {\bf examples} application: contains documentation and interactive examples. {\bf examples} is a clone of the official web2py.com web site, and includes epydoc documentation.

\item the {\bf welcome} application: the basic scaffolding template for any other application. By default it includes a pure CSS cascading menu and user authentication (discussed in Chapter 9).
\end{itemize}
\noindent web2py is distributed in source code, and in binary form for Microsoft Windows and for Mac OS X.

The source code distribution can be used in any platform where Python runs and includes the above-mentioned components.
To run the source code, you need Python 2.5 pre-installed on the system. You also need one of the supported database engines installed.
For testing and light-demand applications, you can use the SQLite database, included with Python 2.5.

The binary versions of web2py (for Windows and Mac OS X) include a Python 2.5 interpreter and
the SQLite database. Technically, these two are not components of web2py. Including them in the binary distributions
enables you to run web2py out of the box.

The following image depicts the overall web2py structure:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en300.png}\end{center}


\goodbreak\section{About this book}

This book includes the following chapters, besides this introduction:
\begin{itemize}
\item Chapter 2 is a minimalist introduction to Python. It assumes knowledge of both procedural and object-oriented programming concepts such as loops, conditions, function calls and classes, and covers basic Python syntax. It also covers examples of Python modules that are used throughout the book. If you already know Python, you may skip Chapter 2.

\item Chapter 3 shows how to start web2py, discusses the administrative interface, and guides the reader through various examples of increasing complexity: an application that returns a string, a counter application, an image blog, and a full blown wiki application that allows image uploads and comments, provides authentication, authorization, web services and an RSS feed. While reading this chapter, you may need to refer to Chapter 2 for general Python syntax and to the following chapters for a more detailed reference about the functions that are used.

\item Chapter 4 covers more systematically the core structure and libraries: URL mapping, request, response, sessions, caching, cron, internationalization and general workflow.

\item Chapter 5 is a reference for the template language used to build views. It shows how to embed Python code into HTML, and demonstrates the use of helpers (objects that can generate HTML).

\item Chapter 6 covers the Database Abstraction Layer, or DAL. The syntax of the DAL is presented through a series of examples.

\item Chapter 7 covers forms, form validation and form processing. FORM is the low level helper for form building. SQLFORM is the high level form builder. In Chapter 7 we also discuss legacy Create/Read/Update/Delete (CRUD) API.

\item Chapter 8 covers communication with as sending emails and SMSes.

\item Chapter 9 covers authentication, authorization and the extensible Role-Based Access Control mechanism available in web2py. Mail configuration and CAPTCHA are also discussed here, since they are used for authentication. In the third edition of the book we have added extensive coverage of integration with third-party authentication mechanisms such as OpenID, OAuth, Google, Facebook, LinkedIn, etc.

\item Chapter 10 is about creating web services in web2py. We provide examples of integration with the Google Web Toolkit via Pyjamas, and with Adobe Flash via PyAMF.

\item Chapter 11 is about web2py and jQuery recipes. web2py is designed mainly for server-side programming, but it includes jQuery, since we have found it to be the best open-source JavaScript library available for effects and Ajax. In this chapter, we discuss how to effectively use jQuery with web2py.

\item Chapter 12 discusses web2py components and plugins as a way to build modular applications. We provide an example of a plugin that implements many commonly used functionality, such as charting, comments, tagging, and wiki.

\item Chapter 13 is about production deployment of web2py applications. We mainly address three possible production scenarios: on a Linux web server or a set of servers (which we consider the main deployment alternative), running as a service on a Microsoft Windows environment, and deployment on the Google Applications Engine. In this chapter, we also discuss security and scalability issues.

\item Chapter 14 contains a variety of other recipes to solve specific tasks, including upgrades, geocoding, pagination, the Twitter API, and more.
\end{itemize}

This book only covers basic web2py functionalities and the API that ships with web2py.
This book does not cover web2py appliances (i.e. ready made applications).

You can download web2py appliances from the corresponding web site~\cite{appliances}.

You can find additional topics discussed on the usergroup~\cite{usergroup}. There is also AlterEgo~\cite{alterego}, the old web2py blog and FAQ.
\inxx{MARKMIN}
This book has been written using the markmin syntax and automatically converted to HTML, LaTeX and PDF.

\goodbreak\section{Support}

The main support channel is the usergroup~\cite{usergroup}, with dozens of posts every day. Even if you're a newbie, don't hesitate to ask - we'll be pleased to help you.
There is also a formal issue tracker system on http://code.google.com/p/web2py/issue. Last but not least, you can have professional support (see the web site for details).

\goodbreak\section{Contribute}

Any help is really appreciated. You can help other users on the user group, or by directly submitting patches on the program (at the GitHub site https://github.com/web2py/web2py).
Even if you find a typo on this book, or have an improvement on it, the best way to help is by patching the book itself (which is under the source folder of the repository
at https://github.com/mdipierro/web2py-book).

\goodbreak\section{Elements of style}

PEP8~\cite{style}  contains good style practices when programming with Python. You will find
that web2py does not always follow these rules. This is not because of omissions or negligence; it is our
belief that the users of web2py should follow these rules and we encourage it. We chose not to
follow some of those rules when defining web2py helper objects in order to minimize the probability
of name conflict with objects defined by the user.

For example, the class that represents a {\ft <div>} is called {\ft DIV}, while according to the
Python style reference it should have been called {\ft Div}. We believe that, for this specific example that
using an all-upper-case "DIV" is a more natural choice. Moreover, this approach leaves programmers
free to create a class called "Div" if they choose to do so.
Our syntax also maps naturally into the DOM notation of most browsers (including, for example, Firefox).

According to the Python style guide, all-upper-case strings should be used for constants and not
variables. Continuing with our example, even considering that {\ft DIV} is a class,
it is a special class that should never be modified by
the user because doing so would break other web2py applications.
Hence, we believe this qualifies the {\ft DIV} class as
something that should be treated as a constant, further justifying our choice of notation.

In summary, the following conventions are followed:
\begin{itemize}
\item HTML helpers and validators are all upper case for the reasons discussed above (for example {\ft DIV}, {\ft A}, {\ft FORM}, {\ft URL}).

\item The translator object {\ft T} is upper case despite the fact that it is an instance of a class and not a class itself. Logically the translator object performs an action similar to the HTML helpers, it affects rendering part of the presentation. Also, {\ft T} needs to be easy to locate in the code and must have a short name.

\item DAL classes follow the Python style guide (first letter capitalized), for example {\ft Table}, {\ft Field}, {\ft Query}, {\ft Row}, {\ft Rows}, etc.
\end{itemize}

In all other cases we believe we have followed, as much as possible,
the Python Style Guide (PEP8).
For example all instance objects are lower-case (request, response, session, cache), and all internal classes are capitalized.

In all the examples of this book, web2py keywords are shown in bold, while strings and comments are shown in italic.

\goodbreak\section{License}

\inxx{license}
\noindent web2py is licensed under the LGPL version 3 License. The full text of the license if available in ref.~\cite{lgpl3}.

In accordance with LGPL you may:

\begin{itemize}
\item redistribute web2py with your apps (including official web2py binary versions)

\item release your applications which use official web2py libraries under any license you wish
\end{itemize}

Yet you must:

\begin{itemize}
\item make clear in the documentation that your application uses web2py

\item release any modification of the web2py libraries under the LGPLv3 license
\end{itemize}

The license includes the usual disclaimer:

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT
HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE,
BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES
OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

{\bf Earlier versions}

Earlier versions of web2py, 1.0.*-1.90.*, were released under the GPL2 license plus a
commercial exception which, for practical purposes, was very similar to the current LPGLv3.

{\bf Third party software distributed with web2py}
\noindent web2py contains third party software under the gluon/contrib/ folder and various JavaScript and CSS files.
These files are distributed with web2py under their original licenses, as stated in the files.

\goodbreak\section{Acknowledgments}
\noindent web2py was originally developed by and copyrighted by Massimo Di Pierro.
The first version (1.0) was released in October, 2007. Since then it has been adopted by many users, some of whom have also contributed bug reports, testing, debugging, patches, and proofreading of this book.

Some of the major developers and contributors are, in alphabetical order by first name:

Adam Bryzak,
Adam Gojdas,
Adrian Klaver,
Alain Boulch,
Alan Etkin,
Alec Taylor,
Alexandre Andrade,
Alexey Nezhdanov,
Alvaro Justen,
Anand Vaidya,
Anatoly Belyakov,
Ander Arbelaiz,
Anders Roos,
Andrew Replogle,
Andrew Willimott,
Angelo Compagnucci,
Angelo and Villas,
Annet Vermeer,
Anthony Bastardi,
Anton Muecki,
Antonio Ramos,
Arun Rajeevan,
Attila Csipa,
Ben Goosman,
Ben Reinhart,
Benjamin,
Bernd Rothert,
Bill Ferret,
Blomqvist,
Boris Manojlovic,
Branko Vukelic,
Brent Zeiben,
Brian Cottingham,
Brian Harrison,
Brian Meredyk,
Bruno Rocha,
CJ Lazell,
Caleb Hattingh,
Carlos Galindo,
Carlos Hanson,
Carsten Haese,
Cedric Meyer,
Charles Law,
Charles Winebrinner,
Chris Clark,
Chris May,
Chris Sanders,
Christian Foster Howes,
Christopher Smiga,
Christopher Steel,
Clavin Sim,
Cliff Kachinske,
Corne Dickens,
Craig Younkins,
Dan McGee,
Dan Ragubba,
Dane Wright,
Danny Morgan,
Daniel Gonz,
Daniel Haag,
Daniel Lin,
Dave Stoll,
David Adley,
David Harrison,
David Lin,
David Marko,
David Wagner,
Denes Lengyel,
Diaz Luis,
Dirk Krause,
Dominic Koenig,
Doug Warren,
Douglas Philips,
Douglas Soares de Andrade,
Douglas and Alan,
Dustin Bensing,
Elcio Ferreira,
Eric Vicenti,
Erwin Olario,
Falko Krause,
Farsheed Ashouri,
Felipe Meirelles,
Flavien Scheurer,
Fran Boon,
Francisco Gama,
Fred Yanowski,
Friedrich Weber,
Gabriele Alberti,
Gergely Kontra,
Gergely Peli,
Gerley Kontra,
Gilson Filho,
Glenn Caltech,
Graham Dumpleton,
Gregory Benjamin,
Gustavo Di Pietro,
Gyuris Szabolcs,
Hamdy Abdel-Badeea,
Hans C. v. Stockhausen,
Hans Donner,
Hans Murx,
Huaiyu Wang,
Ian Reinhart Geiser,
Iceberg,
Igor Gassko,
Ismael Serratos,
Jan Beilicke,
Jay Kelkar,
Jeff Bauer,
Jesus Matrinez,
Jim Karsten,
Joachim Breitsprecher,
Joakim Eriksson,
Joe Barnhart,
Joel Carrier,
Joel Samuelsson,
John Heenan,
Jon Romero,
Jonas Rundberg,
Jonathan Benn,
Jonathan Lundell,
Jose Jachuf,
Joseph Piron,
Josh Goldfoot,
Josh Jaques,
José Vicente de Sousa,
Jurgis Pralgauskis,
Keith Yang,
Kenji Hosoda,
Kenneth Lundstr,
Kirill Spitsin,
Kyle Smith,
Larry Weinberg,
Limodou,
Loren McGinnis,
Louis DaPrato,
Luca De Alfaro,
Luca Zachetti,
Lucas D'Ávila,
Madhukar R Pai,
Manuele Presenti,
Marc Abramowitz,
Marcel Hellkamp,
Marcel Leuthi,
Marcello Della Longa,
Margaret Greaney,
Maria Mitica,
Mariano Reingart,
Marin Prajic,
Marin Pranji,
Marius van Niekerk,
Mark Kirkwood,
Mark Larsen,
Mark Moore,
Markus Gritsch,
Mart Senecal,
Martin Hufsky,
Martin Mulone,
Martin Weissenboeck,
Mateusz Banach,
Mathew Grabau,
Mathieu Clabaut,
Matt Doiron,
Matthew Norris,
Michael Fig,
Michael Herman,
Michael Howden,
Michael Jursa,
Michael Toomim,
Michael Willis,
Michele Comitini,
Miguel Goncalves,
Miguel Lopez,
Mike Amy,
Mike Dickun,
Mike Ellis,
Mike Pechkin,
Milan Melena,
Muhammet Aydin,
Napoleon Moreno,
Nathan Freeze,
Niall Sweeny,
Niccolo Polo,
Nick Groenke,
Nick Vargish,
Nico de Groot,
Nico Zanferrari,
Nicolas Bruxer,
Nik Klever,
Olaf Ferger,
Oliver Dain,
Olivier Roch Vilato,
Omi Chiba,
Ondrej Such,
Ont Rif,
Oscar Benjamin,
Osman Masood,
Ovidio Marinho Falcao Neto,
Pai,
Panos Jee,
Paolo Betti,
Paolo Caruccio,
Paolo Gasparello,
Paolo Valleri,
Patrick Breitenbach,
Pearu Peterson,
Peli Gergely,
Pete Hunt,
Peter Kirchner,
Phyo Arkar Lwin,
Pierre Thibault,
Pieter Muller,
Piotr Banasziewicz,
Ramjee Ganti,
Richard Gordon,
Richard Ree,
Robert Kooij,
Robert Valentak,
Roberto	Perdomo,
Robin Bhattacharyya,
Roman Bataev,
Ron McOuat,
Ross Peoples,
Ruijun Luo,
Running Calm,
Ryan Seto,
Salomon Derossi,
Sam Sheftel,
Scott Roberts,
Sergey Podlesnyi,
Sharriff Aina,
Simone Bizzotto,
Sriram Durbha,
Sterling Hankins,
Stuart Rackham,
Telman Yusupov,
Thadeus Burgess,
Thomas Dallagnese,
Tim Farrell,
Tim Michelsen,
Tim Richardson,
Timothy Farrell,
Tito Garrido,
Tyrone Hattingh,
Vasile Ermicioi,
Vidul Nikolaev Petrov,
Vidul Petrov,
Vinicius Assef,
Vladimir Donnikov,
Vladyslav Kozlovsky,
Vladyslav Kozlovskyy,
Wang Huaiyu,
Wen Gong,
Wes James,
Will Stevens,
Yair Eshel,
Yarko Tymciurak,
Yoshiyuki Nakamura,
Younghyun Jo,
Zahariash.

I am sure I forgot somebody, so I apologize.

I particularly thank Anthony, Jonathan, Mariano, Bruno, Vladyslav, Martin, Nathan, Simone, Thadeus, Tim, Iceberg, Denes, Hans, Christian, Fran and Patrick for their major contributions to web2py and Anthony, Alvaro, Brian, Bruno, Denes, Dane Denny, Erwin, Felipe, Graham, Jonathan, Hans, Kyle, Mark, Margaret, Michele, Nico, Richard, Roberto, Robin, Roman, Scott, Shane, Sharriff, Sriram, Sterling, Stuart, Thadeus, Wen (and others) for proofreading various versions of this book. Their contribution was invaluable. If you find any errors in this book, they are exclusively my fault, probably introduced by a last-minute edit. I also thank Ryan Steffen of Wiley Custom Learning Solutions for help with publishing the first edition of this book.
\noindent web2py contains code from the following authors, whom I would like to thank:

Guido van Rossum for Python~\cite{python}, Peter Hunt, Richard Gordon, Timothy Farrell for the Rocket~\cite{rocket}  web server, Christopher Dolivet for EditArea~\cite{editarea}, Bob Ippolito for simplejson~\cite{simplejson}, Simon Cusack and Grant Edwards for pyRTF~\cite{pyrtf}, Dalke Scientific Software for pyRSS2Gen~\cite{pyrss2gen}, Mark Pilgrim for feedparser~\cite{feedparser}, Trent Mick for markdown2~\cite{markdown2}, Allan Saddi for fcgi.py, Evan Martin for the Python memcache module~\cite{memcache}, John Resig for jQuery~\cite{jquery}.

I thank Helmut Epp (provost of DePaul University), David Miller (Dean of the College of Computing and Digital Media of DePaul University), and Estia Eichten (Member of MetaCryption LLC), for their continuous trust and support.

Finally, I wish to thank my wife, Claudia, and my son, Marco, for putting up with me during the many hours I have spent developing web2py, exchanging emails with users and collaborators, and writing this book. This book is dedicated to them.

\goodbreak\chapter{The Python language}

\inxx{Python}

\goodbreak\section{About Python}

Python is a general-purpose high-level programming language.
Its design philosophy emphasizes programmer productivity and code readability. It has a minimalist core syntax with very few basic commands and simple semantics, but it also has a large and comprehensive standard library, including an Application Programming Interface (API) \inxx{API} to many of the underlying operating system (OS) functions. Python code, while minimalist, defines built-in objects such as linked lists ({\ft list}), tuples ({\ft tuple}), hash tables ({\ft dict}), and arbitrarily long integers ({\ft long}).

Python supports multiple programming paradigms, including object-oriented ({\ft class}), imperative ({\ft def}), and functional ({\ft lambda}) programming. Python has a dynamic type system and automatic memory management using reference counting (similar to Perl, Ruby, and Scheme).

Python was first released by Guido van Rossum in 1991. The language has an open, community-based development model managed by the non-profit Python Software Foundation. There are many interpreters and compilers that implement the Python language, including one in Java (Jython) but, in this brief review, we refer to the reference C implementation created by Guido.

You can find many tutorials, the official documentation and library references of the language on the official Python website.~\cite{python}

For additional Python references, we can recommend the books in ref.~\cite{guido}  and ref.~\cite{lutz}.

You may skip this chapter if you are already familiar with the Python language.

\goodbreak\section{Starting up}

\inxx{shell}
The binary distributions of web2py for Microsoft Windows or Apple OS X come packaged with the Python interpreter built into the distribution file itself.

You can start it on Windows with the following command (type at the DOS prompt):
\begin{lstlisting}
web2py.exe -S welcome
\end{lstlisting}

On Apple OS X, enter the following command type in a Terminal window (assuming you're in the same folder as web2py.app):
\begin{lstlisting}
./web2py.app/Contents/MacOS/web2py -S welcome
\end{lstlisting}

On a Linux or other Unix box, chances are that you have Python already installed. If so, at a shell prompt type:
\begin{lstlisting}
python web2py.py -S welcome
\end{lstlisting}

If you do not have Python 2.5 (or later 2.x) already installed, you will have to download and install it before running web2py.

The {\ft -S welcome} command line option instructs web2py to run the interactive shell as if the commands were executed in a controller for the {\bf welcome} application, the web2py scaffolding application. This exposes almost all web2py classes, objects and functions to you. This is the only difference between the web2py interactive command line and the normal Python command line.

The admin interface also provides a web-based shell for each application. You can access the one for the "welcome" application at.
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/admin/shell/index/welcome
\end{lstlisting}

You can try all the examples in this chapter using the normal shell or the web-based shell.

\goodbreak\section{help, dir}

\inxx{help} \inxx{dir}

The Python language provides two commands to obtain documentation about objects defined in the current scope, both built-in and user-defined.

We can ask for {\ft help} about an object, for example "1":
\begin{lstlisting}
>>> help(1)
Help on int object:

class int(object)
 |  int(x[, base]) -> integer
 |
 |  Convert a string or number to an integer, if possible.  A floating point
 |  argument will be truncated towards zero (this does not include a string
 |  representation of a floating point number!)  When converting a string, use
 |  the optional base.  It is an error to supply a base when converting a
 |  non-string. If the argument is outside the integer range a long object
 |  will be returned instead.
 |
 |  Methods defined here:
 |
 |  __abs__(...)
 |      x.__abs__() <==> abs(x)
...
\end{lstlisting}
\noindent and, since "1" is an integer, we get a description about the {\ft int} class and all its methods. Here the output has been truncated because it is very long and detailed.

Similarly, we can obtain a list of methods of the object "1" with the command {\ft dir}:
\begin{lstlisting}
>>> dir(1)
['__abs__', ..., '__xor__']
\end{lstlisting}

\goodbreak\section{Types}

\inxx{type}
Python is a dynamically typed language, meaning that variables do not have a type and therefore do not have to be declared. Values, on the other hand, do have a type. You can query a variable for the type of value it contains:
\begin{lstlisting}
>>> a = 3
>>> print type(a)
<type 'int'>
>>> a = 3.14
>>> print type(a)
<type 'float'>
>>> a = 'hello python'
>>> print type(a)
<type 'str'>
\end{lstlisting}

Python also includes, natively, data structures such as lists and dictionaries.

\goodbreak\subsection{{\ft str}}

\inxx{str} \inxx{ASCII} \inxx{UTF8} \inxx{Unicode} \inxx{encode}

Python supports the use of two different types of strings: ASCII strings and Unicode strings. ASCII strings are delimited by '...', "..." or by '{\it..}' or """...""". Triple quotes delimit multiline strings. Unicode strings start with a {\ft u} followed by the string containing Unicode characters. A Unicode string can be converted into an ASCII string by choosing an encoding for example:
\begin{lstlisting}
>>> a = 'this is an ASCII string'
>>> b = u'This is a Unicode string'
>>> a = b.encode('utf8')
\end{lstlisting}

After executing these three commands, the resulting {\ft a} is an ASCII string storing UTF8 encoded characters. By design, web2py uses UTF8 encoded strings internally.

It is also possible to write variables into strings in various ways:
\begin{lstlisting}
>>> print 'number is ' + str(3)
number is 3
>>> print 'number is %s' % (3)
number is 3
>>> print 'number is %(number)s' % dict(number=3)
number is 3
\end{lstlisting}

The last notation is more explicit and less error prone, and is to be preferred.

Many Python objects, for example numbers, can be serialized into strings using {\ft str} or {\ft repr}. These two commands are very similar but produce slightly different output. For example:
\begin{lstlisting}
>>> for i in [3, 'hello']:
        print str(i), repr(i)
3 3
hello 'hello'
\end{lstlisting}

For user-defined classes, {\ft str} and {\ft repr} can be defined/redefined using the special operators {\ft \_\_str\_\_} and {\ft \_\_repr\_\_}. These are briefly described later on; for more, refer to the official Python documentation~\cite{pydocs}. {\ft repr} always has a default value.

Another important characteristic of a Python string is that, like a list, it is an iterable object.
\begin{lstlisting}
>>> for i in 'hello':
        print i
h
e
l
l
o
\end{lstlisting}

\goodbreak\subsection{{\ft list}}

\inxx{list}

The main methods of a Python list are append, insert, and delete:
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> print type(a)
<type 'list'>
>>> a.append(8)
>>> a.insert(2, 7)
>>> del a[0]
>>> print a
[2, 7, 3, 8]
>>> print len(a)
4
\end{lstlisting}

Lists can be sliced:
\begin{lstlisting}
>>> print a[:3]
[2, 7, 3]
>>> print a[1:]
[7, 3, 8]
>>> print a[-2:]
[3, 8]
\end{lstlisting}
\noindent and concatenated:
\begin{lstlisting}
>>> a = [2, 3]
>>> b = [5, 6]
>>> print a + b
[2, 3, 5, 6]
\end{lstlisting}

A list is iterable; you can loop over it:
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> for i in a:
        print i
1
2
3
\end{lstlisting}

The elements of a list do not have to be of the same type; they can be any type of Python object.

There is a very common situation for which a {\it list comprehension} can be used.  Consider the following code:
\begin{lstlisting}
>>> a = [1,2,3,4,5]
>>> b = []
>>> for x in a:
        if x % 2 == 0:
            b.append(x * 3)
>>> b
[6, 12]
\end{lstlisting}

This code clearly processes a list of items, selects and modifies a subset of the input list, and creates a new result list, and this code can be entirely replaced with the following list comprehension:
\begin{lstlisting}
>>> a = [1,2,3,4,5]
>>> b = [x * 3 for x in a if x % 2 == 0]
>>> b
[6, 12]
\end{lstlisting}

\goodbreak\subsection{{\ft tuple}}

\inxx{tuple}

A tuple is like a list, but its size and elements are immutable, while in a list they are mutable. If a tuple element is an object, the object attributes are mutable. A tuple is delimited by round brackets.
\begin{lstlisting}
>>> a = (1, 2, 3)
\end{lstlisting}

So while this works for a list:
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> a[1] = 5
>>> print a
[1, 5, 3]
\end{lstlisting}
\noindent the element assignment does not work for a tuple:
\begin{lstlisting}
>>> a = (1, 2, 3)
>>> print a[1]
2
>>> a[1] = 5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
\end{lstlisting}

A tuple, like a list, is an iterable object. Notice that a tuple consisting of a single element must include a trailing comma, as shown below:
\begin{lstlisting}
>>> a = (1)
>>> print type(a)
<type 'int'>
>>> a = (1,)
>>> print type(a)
<type 'tuple'>
\end{lstlisting}

Tuples are very useful for efficient packing of objects because of their immutability, and the brackets are often optional:
\begin{lstlisting}
>>> a = 2, 3, 'hello'
>>> x, y, z = a
>>> print x
2
>>> print z
hello
\end{lstlisting}

\goodbreak\subsection{{\ft dict}}

\inxx{dict}

A Python {\ft dict}-ionary is a hash table that maps a key object to a value object. For example:
\begin{lstlisting}
>>> a = {'k':'v', 'k2':3}
>>> a['k']
v
>>> a['k2']
3
>>> a.has_key('k')
True
>>> a.has_key('v')
False
\end{lstlisting}

Keys can be of any hashable type (int, string, or any object whose class implements the {\ft \_\_hash\_\_} method). Values can be of any type. Different keys and values in the same dictionary do not have to be of the same type. If the keys are alphanumeric characters, a dictionary can also be declared with the alternative syntax:
\begin{lstlisting}
>>> a = dict(k='v', h2=3)
>>> a['k']
v
>>> print a
{'k':'v', 'h2':3}
\end{lstlisting}

Useful methods are {\ft has\_key}, {\ft keys}, {\ft values} and {\ft items}:
\begin{lstlisting}
>>> a = dict(k='v', k2=3)
>>> print a.keys()
['k', 'k2']
>>> print a.values()
['v', 3]
>>> print a.items()
[('k', 'v'), ('k2', 3)]
\end{lstlisting}

The {\ft items} method produces a list of tuples, each containing a key and its associated value.

Dictionary elements and list elements can be deleted with the command {\ft del}:
\begin{lstlisting}
>>> a = [1, 2, 3]
>>> del a[1]
>>> print a
[1, 3]
>>> a = dict(k='v', h2=3)
>>> del a['h2']
>>> print a
{'k':'v'}
\end{lstlisting}

Internally, Python uses the {\ft hash} operator to convert objects into integers, and uses that integer to determine where to store the value.
\begin{lstlisting}
>>> hash("hello world")
-1500746465
\end{lstlisting}

\goodbreak\section{About indentation}

Python uses indentation to delimit blocks of code. A block starts with a line ending in colon, and continues for all lines that have a similar or higher indentation as the next line. For example:
\begin{lstlisting}
>>> i = 0
>>> while i < 3:
>>>    print i
>>>    i = i + 1
>>>
0
1
2
\end{lstlisting}

It is common to use four spaces for each level of indentation.
It is a good policy not to mix tabs with spaces, which can result in (invisible) confusion.

\goodbreak\section{{\ft for...in}}

\inxx{for}
In Python, you can loop over iterable objects:
\begin{lstlisting}
>>> a = [0, 1, 'hello', 'python']
>>> for i in a:
        print i
0
1
hello
python
\end{lstlisting}

One common shortcut is {\ft xrange},
which generates an iterable range without storing the entire list of elements.
\begin{lstlisting}
>>> for i in xrange(0, 4):
        print i
0
1
2
3
\end{lstlisting}

This is equivalent to the C/C++/C\#/Java syntax:
\begin{lstlisting}
for(int i=0; i<4; i=i+1) { print(i); }
\end{lstlisting}

Another useful command is {\ft enumerate}, which counts while looping:
\begin{lstlisting}
>>> a = [0, 1, 'hello', 'python']
>>> for i, j in enumerate(a):
        print i, j
0 0
1 1
2 hello
3 python
\end{lstlisting}

There is also a keyword {\ft range(a, b, c)} that returns a list of integers starting with the value {\ft a}, incrementing by {\ft c}, and ending with the last value smaller than {\ft b},  {\ft a} defaults to 0 and {\ft c} defaults to 1. {\ft xrange} is similar but does not actually generate the list, only an iterator over the list; thus it is better for looping.

You can jump out of a loop using {\ft break}
\begin{lstlisting}
>>> for i in [1, 2, 3]:
         print i
         break
1
\end{lstlisting}

You can jump to the next loop iteration without executing the entire code block with {\ft continue}
\begin{lstlisting}
>>> for i in [1, 2, 3]:
         print i
         continue
         print 'test'
1
2
3
\end{lstlisting}

\goodbreak\section{{\ft while}}

\inxx{while}
The {\ft while} loop in Python works much as it does in many other programming languages, by looping an indefinite number of times and testing a condition before each iteration. If the condition is {\ft False}, the loop ends.
\begin{lstlisting}
>>> i = 0
>>> while i < 10:
        i = i + 1
>>> print i
10
\end{lstlisting}

There is no {\ft loop...until} construct in Python.

\goodbreak\section{{\ft if...elif...else}}

\inxx{if} \inxx{elif} \inxx{else}
The use of conditionals in Python is intuitive:
\begin{lstlisting}
>>> for i in range(3):
>>>     if i == 0:
>>>         print 'zero'
>>>     elif i == 1:
>>>         print 'one'
>>>     else:
>>>         print 'other'
zero
one
other
\end{lstlisting}

"elif" means "else if". Both {\ft elif} and {\ft else} clauses are optional. There can be more than one {\ft elif} but only one {\ft else} statement. Complex conditions can be created using the {\ft not}, {\ft and} and {\ft or} operators.
\begin{lstlisting}
>>> for i in range(3):
>>>     if i == 0 or (i == 1 and i + 1 == 2):
>>>         print '0 or 1'
\end{lstlisting}

\goodbreak\section{{\ft try...except...else...finally}}

\inxx{try} \inxx{except} \inxx{finally} \inxx{Exception}
Python can throw - pardon, raise - Exceptions:
\begin{lstlisting}
>>> try:
>>>     a = 1 / 0
>>> except Exception, e:
>>>     print 'oops: %s' % e
>>> else:
>>>     print 'no problem here'
>>> finally:
>>>     print 'done'
oops: integer division or modulo by zero
done
\end{lstlisting}

If the exception is raised, it is caught by the {\ft except} clause, which is executed, while the {\ft else} clause is not. If no exception is raised, the {\ft except} clause is not executed, but the {\ft else} one is. The {\ft finally} clause is always executed.

There can be multiple {\ft except} clauses for different possible exceptions:
\begin{lstlisting}
>>> try:
>>>     raise SyntaxError
>>> except ValueError:
>>>     print 'value error'
>>> except SyntaxError:
>>>     print 'syntax error'
syntax error
\end{lstlisting}

The {\ft else} and {\ft finally} clauses are optional.

Here is a list of built-in Python exceptions + HTTP (defined by web2py)
\begin{lstlisting}
BaseException
 +-- HTTP (defined by web2py)
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- Exception
      +-- GeneratorExit
      +-- StopIteration
      +-- StandardError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |    |    +-- UnicodeError
      |    |         +-- UnicodeDecodeError
      |    |         +-- UnicodeEncodeError
      |    |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
\end{lstlisting}

For a detailed description of each of them, refer to the official Python documentation.
\noindent web2py exposes only one new exception, called {\ft HTTP}. When raised, it causes the program to return an HTTP error page (for more on this refer to Chapter 4).

Any object can be raised as an exception, but it is good practice to raise objects that extend one of the built-in exception classes.

\goodbreak\section{{\ft def...return}}

\inxx{def} \inxx{return}

Functions are declared using {\ft def}.  Here is a typical Python function:
\begin{lstlisting}
>>> def f(a, b):
        return a + b
>>> print f(4, 2)
6
\end{lstlisting}

There is no need (or way) to specify types of the arguments or the return type(s). In this example, a function {\ft f} is defined that can take two arguments.

Functions are the first code syntax feature described in this chapter to introduce the concept of {\it scope}, or {\it namespace}.  In the above example, the identifiers {\ft a} and {\ft b} are undefined outside of the scope of function {\ft f}:
\begin{lstlisting}
>>> def f(a):
        return a + 1
>>> print f(1)
2
>>> print a
Traceback (most recent call last):
  File "<pyshell#22>", line 1, in <module>
    print a
NameError: name 'a' is not defined
\end{lstlisting}

Identifiers defined outside of function scope are accessible within the function; observe how the identifier {\ft a} is handled in the following code:
\begin{lstlisting}
>>> a = 1
>>> def f(b):
        return a + b
>>> print f(1)
2
>>> a = 2
>>> print f(1) # new value of a is used
3
>>> a = 1 # reset a
>>> def g(b):
        a = 2 # creates a new local a
        return a + b
>>> print g(2)
4
>>> print a # global a is unchanged
1
\end{lstlisting}

If {\ft a} is modified, subsequent function calls will use the new value of the global {\ft a} because the function definition binds the storage location of the identifier {\ft a}, not the value of {\ft a} itself at the time of function declaration; however, if {\ft a} is assigned-to inside function {\ft g}, the global {\ft a} is unaffected because the new local {\ft a} hides the global value.  The external-scope reference can be used in the creation of {\it closures}:
\begin{lstlisting}
>>> def f(x):
        def g(y):
            return x * y
        return g
>>> doubler = f(2) # doubler is a new function
>>> tripler = f(3) # tripler is a new function
>>> quadrupler = f(4) # quadrupler is a new function
>>> print doubler(5)
10
>>> print tripler(5)
15
>>> print quadrupler(5)
20
\end{lstlisting}

Function {\ft f} creates new functions; and note that the scope of the name {\ft g} is entirely internal to {\ft f}.  Closures are extremely powerful.

Function arguments can have default values, and can return multiple results:
\begin{lstlisting}
>>> def f(a, b=2):
        return a + b, a - b
>>> x, y = f(5)
>>> print x
7
>>> print y
3
\end{lstlisting}

Function arguments can be passed explicitly by name, and this means that the order of arguments specified in the caller can be different than the order of arguments with which the function was defined:
\begin{lstlisting}
>>> def f(a, b=2):
        return a + b, a - b
>>> x, y = f(b=5, a=2)
>>> print x
7
>>> print y
-3
\end{lstlisting}

Functions can also take a runtime-variable number of arguments:
\begin{lstlisting}
>>> def f(*a, **b):
        return a, b
>>> x, y = f(3, 'hello', c=4, test='world')
>>> print x
(3, 'hello')
>>> print y
{'c':4, 'test':'world'}
\end{lstlisting}

Here arguments not passed by name (3, 'hello') are stored in the tuple {\ft a}, and arguments passed by name ({\ft c} and {\ft test}) are stored in the dictionary {\ft b}.

In the opposite case, a list or tuple can be passed to a function that requires individual positional arguments by unpacking them:
\begin{lstlisting}
>>> def f(a, b):
        return a + b
>>> c = (1, 2)
>>> print f(*c)
3
\end{lstlisting}
\noindent and a dictionary can be unpacked to deliver keyword arguments:
\begin{lstlisting}
>>> def f(a, b):
        return a + b
>>> c = {'a':1, 'b':2}
>>> print f(**c)
3
\end{lstlisting}

\goodbreak\subsection{{\ft lambda}}

\inxx{lambda}

{\ft lambda} provides a way to create a very short unnamed function very easily:
\begin{lstlisting}
>>> a = lambda b: b + 2
>>> print a(3)
5
\end{lstlisting}

The expression "{\ft lambda} [a]:[b]" literally reads as "a function with arguments [a] that returns [b]". The {\ft lambda} expression is itself unnamed, but the function acquires a name by being assigned to identifier {\ft a}.  The scoping rules for {\ft def} apply to {\ft lambda} equally, and in fact the code above, with respect to {\ft a}, is identical to the function declaration using {\ft def}:
\begin{lstlisting}
>>> def a(b):
        return b + 2
>>> print a(3)
5
\end{lstlisting}

The only benefit of {\ft lambda} is brevity; however, brevity can be very convenient in certain situations.  Consider a function called {\ft map} that applies a function to all items in a list, creating a new list:
\begin{lstlisting}
>>> a = [1, 7, 2, 5, 4, 8]
>>> map(lambda x: x + 2, a)
[3, 9, 4, 7, 6, 10]
\end{lstlisting}
This code would have doubled in size had {\ft def} been used instead of {\ft lambda}. The main drawback of {\ft lambda} is that (in the Python implementation) the syntax allows only for a single expression; however, for longer functions, {\ft def} can be used and the extra cost of providing a function name decreases as the length of the function grows.
Just like {\ft def}, {\ft lambda} can be used to {\it curry} functions: new functions can be created by wrapping existing functions such that the new function carries a different set of arguments:
\begin{lstlisting}
>>> def f(a, b): return a + b
>>> g = lambda a: f(a, 3)
>>> g(2)
5
\end{lstlisting}

There are many situations where currying is useful, but one of those is directly useful in web2py: caching. Suppose you have an expensive function that checks whether its argument is prime:
\begin{lstlisting}
def isprime(number):
    for p in range(2, number):
        if (number % p) == 0:
            return False
    return True
\end{lstlisting}

This function is obviously time consuming.

Suppose you have a caching function {\ft cache.ram} that takes three arguments: a key, a function and a number of seconds.
\begin{lstlisting}
value = cache.ram('key', f, 60)
\end{lstlisting}

The first time it is called, it calls the function {\ft f()}, stores the output in a dictionary in memory (let's say "d"), and returns it so that value is:
\begin{lstlisting}
value = d['key']=f()
\end{lstlisting}

The second time it is called, if the key is in the dictionary and not older than the number of seconds specified (60), it returns the corresponding value without performing the function call.
\begin{lstlisting}
value = d['key']
\end{lstlisting}

How would you cache the output of the function {\bf isprime} for any input?
Here is how:
\begin{lstlisting}
>>> number = 7
>>> seconds = 60
>>> print cache.ram(str(number), lambda: isprime(number), seconds)
True
>>> print cache.ram(str(number), lambda: isprime(number), seconds)
True
\end{lstlisting}

The output is always the same, but the first time {\ft cache.ram} is called, {\ft isprime} is called; the second time it is not.

\begin{quote}Python functions, created with either {\ft def} or {\ft lambda} allow re-factoring existing functions in terms of a different set of arguments.
{\ft cache.ram} and {\ft cache.disk} are web2py caching functions.\end{quote}
\goodbreak\section{{\ft class}}

\inxx{class}

Because Python is dynamically typed, Python classes and objects may seem odd. In fact, you do not need to define the member variables (attributes) when declaring a class, and different instances of the same class can have different attributes. Attributes are generally associated with the instance, not the class (except when declared as "class attributes", which is the same as "static member variables" in C++/Java).

Here is an example:
\begin{lstlisting}
>>> class MyClass(object): pass
>>> myinstance = MyClass()
>>> myinstance.myvariable = 3
>>> print myinstance.myvariable
3
\end{lstlisting}

Notice that {\ft pass} is a do-nothing command. In this case it is used to define a class {\ft MyClass} that contains nothing. {\ft MyClass()} calls the constructor of the class (in this case the default constructor) and returns an object, an instance of the class. The {\ft (object)} in the class definition indicates that our class extends the built-in {\ft object} class. This is not required, but it is good practice.

Here is a more complex class:
\begin{lstlisting}
>>> class MyClass(object):
>>>    z = 2
>>>    def __init__(self, a, b):
>>>        self.x = a
>>>        self.y = b
>>>    def add(self):
>>>        return self.x + self.y + self.z
>>> myinstance = MyClass(3, 4)
>>> print myinstance.add()
9
\end{lstlisting}

Functions declared inside the class are methods. Some methods have special reserved names. For example, {\ft \_\_init\_\_} is the constructor. All variables are local variables of the method except variables declared outside methods. For example, {\ft z} is a {\it class variable}, equivalent to a C++ {\it static member variable} that holds the same value for all instances of the class.

Notice that {\ft \_\_init\_\_} takes 3 arguments and {\ft add} takes one, and yet we call them with 2 and 0 arguments respectively. The first argument represents, by convention, the local name used inside the method to refer to the current object. Here we use {\ft self} to refer to the current object, but we could have used any other name. {\ft self} plays the same role as {\ft *this} in C++ or {\ft this} in Java, but {\ft self} is not a reserved keyword.

This syntax is necessary to avoid ambiguity when declaring nested classes, such as a class that is local to a method inside another class.

\goodbreak\section{Special attributes, methods and operators}

Class attributes, methods, and operators starting with a double underscore are usually intended to be private (i.e. to be used internally but not exposed outside the class) although this is a convention that is not enforced by the interpreter.

Some of them are reserved keywords and have a special meaning.

Here, as an example, are three of them:
\begin{itemize}
\item {\ft \_\_len\_\_}

\item {\ft \_\_getitem\_\_}

\item {\ft \_\_setitem\_\_}
\end{itemize}
They can be used, for example, to create a container object that acts like a list:
\begin{lstlisting}
>>> class MyList(object):
>>>     def __init__(self, *a): self.a = list(a)
>>>     def __len__(self): return len(self.a)
>>>     def __getitem__(self, i): return self.a[i]
>>>     def __setitem__(self, i, j): self.a[i] = j
>>> b = MyList(3, 4, 5)
>>> print b[1]
4
>>> b.a[1] = 7
>>> print b.a
[3, 7, 5]
\end{lstlisting}

Other special operators include {\ft \_\_getattr\_\_} and {\ft \_\_setattr\_\_}, which define the get and set attributes for the class, and {\ft \_\_sum\_\_} and {\ft \_\_sub\_\_}, which overload arithmetic operators. For the use of these operators we refer the reader to more advanced books on this topic. We have already mentioned the special operators {\ft \_\_str\_\_} and {\ft \_\_repr\_\_}.

\goodbreak\section{File input/output}

\inxx{file.read} \inxx{file.write}

In Python you can open and write in a file with:
\begin{lstlisting}
>>> file = open('myfile.txt', 'w')
>>> file.write('hello world')
>>> file.close()
\end{lstlisting}

Similarly, you can read back from the file with:
\begin{lstlisting}
>>> file = open('myfile.txt', 'r')
>>> print file.read()
hello world
\end{lstlisting}

Alternatively, you can read in binary mode with "rb", write in binary mode with "wb", and open the file in append mode "a", using standard C notation.

The {\ft read} command takes an optional argument, which is the number of bytes. You can also jump to any location in a file using {\ft seek}.
\inxx{file.seek}

You can read back from the file with {\ft read}
\begin{lstlisting}
>>> print file.seek(6)
>>> print file.read()
world
\end{lstlisting}
\noindent and you can close the file with:
\begin{lstlisting}
>>> file.close()
\end{lstlisting}

In the standard distribution of Python, which is known as CPython, variables are reference-counted, including those holding file handles, so CPython knows that when the reference count of an open file handle decreases to zero, the file may be closed and the variable disposed.  However, in other implementations of Python such as PyPy, garbage collection is used instead of reference counting, and this means that it is possible that there may accumulate too many open file handles at one time, resulting in an error before the {\it gc} has a chance to close and dispose of them all.  Therefore it is best to explicitly close file handles when they are no longer needed.  {\it web2py} provides two helper functions, {\ft read\_file()} and {\ft write\_file()} inside the {\ft gluon.fileutils} namespace that encapsulate the file access and ensure that the file handles being used are properly closed.

\begin{quote}When using web2py, you do not know where the current directory is, because it depends on how web2py is configured. The variable {\ft request.folder} contains the path to the current application. Paths can be concatenated with the command {\ft os.path.join}, discussed below.\end{quote}
\goodbreak\section{{\ft exec}, {\ft eval}}

\inxx{exec} \inxx{eval}

Unlike Java, Python is a truly interpreted language. This means it has the ability to execute Python statements stored in strings. For example:
\begin{lstlisting}
>>> a = "print 'hello world'"
>>> exec(a)
'hello world'
\end{lstlisting}

What just happened? The function {\ft exec} tells the interpreter to call itself and execute the content of the string passed as argument. It is also possible to execute the content of a string within a context defined by the symbols in a dictionary:
\begin{lstlisting}
>>> a = "print b"
>>> c = dict(b=3)
>>> exec(a, {}, c)
3
\end{lstlisting}

Here the interpreter, when executing the string {\ft a}, sees the symbols defined in {\ft c} ({\ft b} in the example), but does not see {\ft c} or {\ft a} themselves. This is different than a restricted environment, since {\ft exec} does not limit what the inner code can do; it just defines the set of variables visible to the code.

A related function is {\ft eval}, which works very much like {\ft exec} except that it expects the argument to evaluate to a value, and it returns that value.
\begin{lstlisting}
>>> a = "3*4"
>>> b = eval(a)
>>> print b
12
\end{lstlisting}

\goodbreak\section{{\ft import}}

\inxx{import} \inxx{random}
The real power of Python is in its library modules. They provide a large and consistent set of Application Programming Interfaces (APIs) to many system libraries (often in a way independent of the operating system).

For example, if you need to use a random number generator, you can do:
\begin{lstlisting}
>>> import random
>>> print random.randint(0, 9)
5
\end{lstlisting}

This prints a random integer between 0 and 9 (including 9), 5 in the example. The function {\ft randint} is defined in the module {\ft random}. It is also possible to import an object from a module into the current namespace:
\begin{lstlisting}
>>> from random import randint
>>> print randint(0, 9)
\end{lstlisting}
\noindent or import all objects from a module into the current namespace:
\begin{lstlisting}
>>> from random import *
>>> print randint(0, 9)
\end{lstlisting}
\noindent or import everything in a newly defined namespace:
\begin{lstlisting}
>>> import random as myrand
>>> print myrand.randint(0, 9)
\end{lstlisting}

In the rest of this book, we will mainly use objects defined in modules {\ft os}, {\ft sys}, {\ft datetime}, {\ft time} and {\ft cPickle}.

\begin{quote}All of the web2py objects are accessible via a module called {\ft gluon}, and that is the subject of later chapters. Internally, web2py uses many Python modules (for example {\ft thread}), but you rarely need to access them directly.\end{quote}
In the following subsections we consider those modules that are most useful.

\goodbreak\subsection{{\ft os}}

\inxx{os} \inxx{os.path.join} \inxx{os.unlink}

This module provides an interface to the operating system API. For example:
\begin{lstlisting}
>>> import os
>>> os.chdir('..')
>>> os.unlink('filename_to_be_deleted')
\end{lstlisting}

\begin{quote}Some of the {\ft os} functions, such as {\ft chdir}, MUST NOT be used in web2py because they are not thread-safe.\end{quote}{\ft os.path.join} is very useful; it allows the concatenation of paths in an OS-independent way:
\begin{lstlisting}
>>> import os
>>> a = os.path.join('path', 'sub_path')
>>> print a
path/sub_path
\end{lstlisting}

System environment variables can be accessed via:
\begin{lstlisting}
>>> print os.environ
\end{lstlisting}
\noindent which is a read-only dictionary.

\goodbreak\subsection{{\ft sys}}

\inxx{sys} \inxx{sys.path}

The {\ft sys} module contains many variables and functions, but the one we use the most is {\ft sys.path}. It contains a list of paths where Python searches for modules. When we try to import a module, Python looks for it in all the folders listed in {\ft sys.path}. If you install additional modules in some location and want Python to find them, you need to append the path to that location to {\ft sys.path}.
\begin{lstlisting}
>>> import sys
>>> sys.path.append('path/to/my/modules')
\end{lstlisting}

When running web2py, Python stays resident in memory, and there is only one {\ft sys.path}, while there are many threads servicing the HTTP requests. To avoid a memory leak, it is best to check if a path is already present before appending:
\begin{lstlisting}
>>> path = 'path/to/my/modules'
>>> if not path in sys.path:
        sys.path.append(path)
\end{lstlisting}

\goodbreak\subsection{{\ft datetime}}

\inxx{date} \inxx{datetime} \inxx{time}

The use of the datetime module is best illustrated by some examples:
\begin{lstlisting}
>>> import datetime
>>> print datetime.datetime.today()
2008-07-04 14:03:90
>>> print datetime.date.today()
2008-07-04
\end{lstlisting}

Occasionally you may need to time-stamp data based on the UTC time as opposed to local time. In this case you can use the following function:
\begin{lstlisting}
>>> import datetime
>>> print datetime.datetime.utcnow()
2008-07-04 14:03:90
\end{lstlisting}

The datetime module contains various classes: date, datetime, time and timedelta. The difference between two date or two datetime or two time objects is a timedelta:
\begin{lstlisting}
>>> a = datetime.datetime(2008, 1, 1, 20, 30)
>>> b = datetime.datetime(2008, 1, 2, 20, 30)
>>> c = b - a
>>> print c.days
1
\end{lstlisting}

In web2py, date and datetime are used to store the corresponding SQL types when passed to or returned from the database.

\goodbreak\subsection{{\ft time}}

\inxx{time}

The time module differs from {\ft date} and {\ft datetime} because it represents time as seconds from the epoch (beginning of 1970).
\begin{lstlisting}
>>> import time
>>> t = time.time()
1215138737.571
\end{lstlisting}

Refer to the Python documentation for conversion functions between time in seconds and time as a {\ft datetime}.

\goodbreak\subsection{{\ft cPickle}}

\inxx{cPickle}

This is a very powerful module. It provides functions that can serialize almost any Python object, including self-referential objects. For example, let's build a weird object:
\begin{lstlisting}
>>> class MyClass(object): pass
>>> myinstance = MyClass()
>>> myinstance.x = 'something'
>>> a = [1 ,2, {'hello':'world'}, [3, 4, [myinstance]]]
\end{lstlisting}
\noindent and now:
\begin{lstlisting}
>>> import cPickle
>>> b = cPickle.dumps(a)
>>> c = cPickle.loads(b)
\end{lstlisting}

In this example, {\ft b} is a string representation of {\ft a}, and {\ft c} is a copy of {\ft a} generated by de-serializing {\ft b}.
\noindent cPickle can also serialize to and de-serialize from a file:
\begin{lstlisting}
>>> cPickle.dump(a, open('myfile.pickle', 'wb'))
>>> c = cPickle.load(open('myfile.pickle', 'rb'))
\end{lstlisting}

\goodbreak\chapter{Overview}

\goodbreak\section{Startup}

\inxx{Linux} \inxx{Mac} \inxx{Windows}
\noindent web2py comes in binary packages for Windows and Mac OS X. They include the Python interpreter so you do not need to have it pre-installed. There is also a source code version that runs on Windows, Mac, Linux, and other Unix systems. The source code package assumes that Python is already installed on the computer.
\noindent web2py requires no installation. To get started, unzip the downloaded zip file for your specific operating system and execute the corresponding {\ft web2py} file.

On Unix and Linux (source distribution), run:
\begin{lstlisting}
python web2py.py
\end{lstlisting}

On OS X (binary distribution), run:
\begin{lstlisting}
open web2py.app
\end{lstlisting}

On Windows (binary web2py distribution), run:
\begin{lstlisting}
web2py.exe
\end{lstlisting}

On Windows (source web2py distribution), run:
\begin{lstlisting}
c:/Python27/python.exe web2py.py
\end{lstlisting}

\begin{quote}Attention, to run web2py on Windows from source you must install first Mark Hammond's {\footnotesize\href{http://sourceforge.net/projects/pywin32/}{Python for Windows extensions}}\end{quote}
The web2py program accepts various command line options which are discussed later.

By default, at startup, web2py displays a startup window and then displays a GUI widget that asks you to choose a one-time administrator password, the IP address of the network interface to be used for the web server, and a port number from which to serve requests. By default, web2py runs its web server on 127.0.0.1:8000 (port 8000 on localhost), but you can run it on any available IP address and port. You can query the IP address of your network interface by opening a command line and typing {\ft ipconfig} on Windows or {\ft ifconfig} on OS X and Linux. From now on we assume web2py is running on localhost (127.0.0.1:8000). Use 0.0.0.0:80 to run web2py publicly on any of your network interfaces.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en400.png}\end{center}


If you do not provide an administrator password, the administration interface is disabled. This is a security measure to prevent publicly exposing the admin interface.

The administrative interface, {\bf admin}, is only accessible from localhost unless you run web2py behind Apache with mod\_proxy. If {\bf admin} detects a proxy, the session cookie is set to secure and {\bf admin} login does not work unless the communication between the client and the proxy goes over HTTPS; this is a security measure. All communications between the client and {\bf admin} must always be local or encrypted; otherwise an attacker would be able to perform a man-in-the middle attack or a replay attack and execute arbitrary code on the server.

After the administration password has been set, web2py starts up the web browser at the page:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/
\end{lstlisting}

If the computer does not have a default browser, open a web browser and enter the URL.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en500.png}\end{center}


Clicking on "administrative interface" takes you to the login page for the administration interface.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en600.png}\end{center}


The administrator password is the password you chose at startup.
Notice that there is only one administrator, and therefore only one administrator password. For security reasons, the developer is asked to choose a new password every time web2py starts unless the <recycle> option is specified. This is distinct from the authentication mechanism in web2py applications.

After the administrator logs into web2py, the browser is redirected to the "site" page.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en700.png}\end{center}


This page lists all installed web2py applications and allows the administrator to manage them.
web2py comes with three applications:
\inxx{admin} \inxx{examples} \inxx{welcome} \inxx{scaffolding}
\begin{itemize}
\item An {\bf admin} application, the one you are using right now.

\item An {\bf examples} application, with the online interactive documentation and a replica of the web2py official website.

\item A {\bf welcome} application. This is the basic template for any other web2py application. It is referred to as the scaffolding application. This is also the application that welcomes a user at startup.
\end{itemize}

\inxx{appliances}
Ready-to-use web2py applications are referred to as web2py {\it appliances}.  You can download many freely available appliances from~\cite{appliances}. web2py users are encouraged to submit new appliances, either in open-source or closed-source (compiled and packed) form.

From the {\bf admin} application's {\it site} page, you can perform the following operations:
\begin{itemize}
\item {\bf install} an application by completing the form on the bottom right of the page. Give a name to the application, select the file containing a packaged application or the URL where the application is located, and click "submit".

\item {\bf uninstall} an application by clicking the corresponding button. There is a confirmation page.

\item {\bf create} a new application by choosing a name and clicking "create".

\item {\bf package} an application for distribution by clicking on the corresponding button. A downloaded application is a tar file containing everything, including the database. You should not untar this file; it is automatically unpackaged by web2py when installed with {\bf admin}.

\item {\bf clean up} an application's temporary files, such as sessions, errors and cache files.

\item {\bf EDIT} an application.
\end{itemize}

\begin{quote}When you create a new application using {\bf admin}, it starts as a clone of the "welcome" scaffolding app with a "models/db.py" that creates a SQLite database, connects to it, instantiates Auth, Crud, and Service, and configures them. It also provides a "controller/default.py" which exposes actions "index", "download", "user" for user management, and "call" for services. In the following, we assume that these files have been removed; we will be creating apps from scratch.\end{quote}
web2py also comes with a {\bf wizard}, described later in this chapter, that can write an alternate scaffolding code for you based on layouts and plugins available on the web and based on high level description of the models.

\goodbreak\section{Simple examples}

\goodbreak\subsection{Say hello}

\inxx{index}

Here, as an example, we create a simple web app that displays the message "Hello from MyApp" to the user. We will call this application "myapp". We will also add a counter that counts how many times the same user visits the page.

You can create a new application simply by typing its name in the form on the top right of the {\bf site} page in {\bf admin}.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en800.png}\end{center}


After you press [create], the application is created as a copy of the built-in welcome application.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en900.png}\end{center}


To run the new application, visit:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/myapp
\end{lstlisting}

Now you have a copy of the welcome application.

To edit an application, click on the {\it edit} button for the newly created application.

The {\bf edit} page tells you what is inside the application.
Every web2py application consists of certain files, most of which fall into one of six categories:
\begin{itemize}
\item {\bf models}: describe the data representation.

\item {\bf controllers}: describe the application logic and workflow.

\item {\bf views}: describe the data presentation.

\item {\bf languages}: describe how to translate the application presentation to other languages.

\item {\bf modules}: Python modules that belong to the application.

\item {\bf static files}: static images, CSS  files~\cite{css-w,css-o,css-school}, JavaScript files~\cite{js-w,js-b}, etc.

\item {\bf plugins}: groups of files designed to work together.
\end{itemize}

Everything is neatly organized following the Model-View-Controller design pattern. Each section in the {\it edit} page corresponds to a subfolder in the application folder.

Notice that clicking on section headings will toggle their content. Folder names under static files are also collapsible.

\begin{quote}Each file listed in the section corresponds to a file physically located in the subfolder. Any operation performed on a file via the {\bf admin} interface (create, edit, delete) can be performed directly from the shell using your favorite editor.\end{quote}
The application contains other types of files (database, session files, error files, etc.), but they are not listed on the {\it edit} page because they are not created or modified by the administrator; they are created and modified by the application itself.

The controllers contain the logic and workflow of the application. Every URL gets mapped into a call to one of the functions in the controllers (actions). There are two default controllers: "appadmin.py" and "default.py". {\bf appadmin} provides the database administrative interface; we do not need it now. "default.py" is the controller that you need to edit, the one that is called by default when no controller is specified in the URL. Edit the "index" function as follows:
\begin{lstlisting}
def index():
    return "Hello from MyApp"
\end{lstlisting}

Here is what the online editor looks like:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1000.png}\end{center}


Save it and go back to the {\it edit} page. Click on the index link to visit the newly created page.

When you visit the URL
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/myapp/default/index
\end{lstlisting}
\noindent the index action in the default controller of the myapp application is called. It returns a string that the browser displays for us. It should look like this:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1100.png}\end{center}


Now, edit the "index" function as follows:
\begin{lstlisting}
def index():
    return dict(message="Hello from MyApp")
\end{lstlisting}

Also from the {\it edit} page, edit the view "default/index.html" (the view file associated with the action) and completely replace the existing contents of that file with the following:
\begin{lstlisting}[keywords={}]
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
   </body>
</html>
\end{lstlisting}

Now the action returns a dictionary defining a {\ft message}. When an action returns a dictionary, web2py looks for a view with the name

{\ft [controller]/[function].[extension]}
\noindent and executes it. Here [extension] is the requested extension. If no extension is specified, it defaults to "html", and that is what we will assume here. Under this assumption, the view is an HTML file that embeds Python code using special \{\{ \}\} tags. In particular, in the example, the {\ft \{\{=message\}\}} instructs web2py to replace the tagged code with the value of the {\ft message} returned by the action. Notice that {\ft message} here is not a web2py keyword but is defined in the action. So far we have not used any web2py keywords.

If web2py does not find the requested view, it uses the "generic.html" view that comes with every application.

\begin{quote}\inxx{Mac Mail} \inxx{Google Maps} \inxx{jsonp}
If an extension other than "html" is specified ("json" for example), and the view file "[controller]/[function].json" is not found, web2py looks for the view "generic.json". web2py comes with generic.html, generic.json, generic.jsonp, generic.xml, generic.rss, generic.ics (for Mac Mail Calendar), generic.map (for embedding Google Maps), and generic.pdf (based on fpdf). These generic views can be modified for each application individually, and additional views can be added easily.\end{quote}
\begin{quote}Generic views are a development tool. In production every action should have its own view. In fact, by default, generic views are only enabled from localhost.\end{quote}
\begin{quote}You can also specify a view with {\ft response.view = 'default/something.html'}\end{quote}
Read more on this topic in Chapter 10.

If you go back to "EDIT" and click on index, you will now see the following HTML page:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1200.png}\end{center}


For debugging purposes you can always append

\begin{lstlisting}[keywords={}]
{{=response.toolbar()}}
\end{lstlisting}
\noindent to the code in a view and it will show you some useful information, including the request, response and session objects, and list all db queries with their timing.

\goodbreak\subsection{Let's count}

\inxx{session}
Let's now add a counter to this page that will count how many times the same visitor displays the page.
\noindent web2py automatically and transparently tracks visitors using sessions and cookies. For each new visitor, it creates a session and assigns a unique "session\_id". The session is a container for variables that are stored server-side. The unique id is sent to the browser via a cookie. When the visitor requests another page from the same application, the browser sends the cookie back, it is retrieved by web2py, and the corresponding session is restored.

To use the session, modify the default controller:
\begin{lstlisting}
def index():
    if not session.counter:
        session.counter = 1
    else:
        session.counter += 1
    return dict(message="Hello from MyApp", counter=session.counter)
\end{lstlisting}

Notice that {\ft counter} is not a web2py keyword but {\ft session} is. We are asking web2py to check whether there is a counter variable in the session and, if not, to create one and set it to 1. If the counter is there, we ask web2py to increase the counter by 1. Finally we pass the value of the counter to the view.

A more compact way to code the same function is this:
\begin{lstlisting}
def index():
    session.counter = (session.counter or 0) + 1
    return dict(message="Hello from MyApp", counter=session.counter)
\end{lstlisting}

Now modify the view to add a line that displays the value of the counter:
\begin{lstlisting}[keywords={}]
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
      <h2>Number of visits: {{=counter}}</h2>
   </body>
</html>
\end{lstlisting}

When you visit the index page again (and again) you should get the following HTML page:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1300.png}\end{center}


The counter is associated with each visitor, and is incremented each time the visitor reloads the page. Different visitors see different counters.

\goodbreak\subsection{Say my name}

\inxx{form} \inxx{request.vars}

Now create two pages (first and second), where the first page creates a form, asks the visitor's name, and redirects to the second page, which greets the visitor by name.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1400.png}\end{center}


Write the corresponding actions in the default controller:
\begin{lstlisting}
def first():
    return dict()

def second():
    return dict()
\end{lstlisting}

Then create a view "default/first.html" for the first action,
and enter:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>What is your name?</h1>
<form action="second">
  <input name="visitor_name" />
  <input type="submit" />
</form>
\end{lstlisting}

Finally, create a view "default/second.html" for the second action:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Hello {{=request.vars.visitor_name}}</h1>
\end{lstlisting}

\inxx{layout}
In both views we have extended the basic "layout.html" view that comes with web2py. The layout view keeps the look and feel of the two pages consistent. The layout file can be edited and replaced easily, since it mainly contains HTML code.

If you now visit the first page, type your name:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1500.png}\end{center}

\noindent and submit the form, you will receive a greeting:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1600.png}\end{center}


\goodbreak\subsection{Postbacks}

\inxx{redirect} \inxx{URL} \inxx{postback}

The mechanism for form submission that we used before is very common, but it is not good programming practice. All input should be validated and, in the above example, the burden of validation would fall on the second action. Thus the action that performs the validation is different from the action that generated the form. This tends to cause redundancy in the code.

A better pattern for form submission is to submit forms to the same action that generated them, in our example the "first". The "first" action should receive the variables, process them, store them server-side, and redirect the visitor to the "second" page, which retrieves the variables. This mechanism is called a {\it postback}.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1700.png}\end{center}


Modify the default controller to implement self-submission:
\begin{lstlisting}
def first():
    if request.vars.visitor_name:
        session.visitor_name = request.vars.visitor_name
        redirect(URL('second'))
    return dict()

def second():
    return dict()
\end{lstlisting}

Then modify the "default/first.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
What is your name?
<form>
  <input name="visitor_name" />
  <input type="submit" />
</form>
\end{lstlisting}
\noindent and the "default/second.html" view needs to retrieve the data from the {\ft session} instead of from the {\ft request.vars}:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Hello {{=session.visitor_name or "anonymous"}}</h1>
\end{lstlisting}

From the point of view of the visitor, the self-submission behaves exactly the same as the previous implementation. We have not added validation yet, but it is now clear that validation should be performed by the first action.

This approach is better also because the name of the visitor stays in the session, and can be accessed by all actions and views in the applications without having to be passed around explicitly.

Note that if the "second" action is ever called before a visitor name is set, it will display "Hello anonymous" because  {\ft session.visitor\_name} returns {\ft None}. Alternatively we could have added the following code in the controller (inside the {\ft second} function):

\begin{lstlisting}
if not request.function=='first' and not session.visitor_name:
    redirect(URL('first'))
\end{lstlisting}

This is a general mechanism that you can use to enforce authorization on controllers, though see Chapter 9 for a more powerful method.

\inxx{FORM} \inxx{INPUT} \inxx{requires} \inxx{IS\_NOT\_EMPTY} \inxx{accepts}

With web2py we can move one step further and ask web2py to generate the form for us, including validation. web2py provides helpers (FORM, INPUT, TEXTAREA, and SELECT/OPTION) with the same names as the equivalent HTML tags. They can be used to build forms either in the controller or in the view.

For example, here is one possible way to rewrite the first action:
\begin{lstlisting}
def first():
    form = FORM(INPUT(_name='visitor_name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
\end{lstlisting}
\noindent where we are saying that the FORM tag contains two INPUT tags. The attributes of the input tags are specified by the named arguments starting with underscore. The {\ft requires} argument is not a tag attribute (because it does not start by underscore) but it sets a validator for the value of visitor\_name.

Here is yet another better way to create the same form:

\begin{lstlisting}
def first():
    form = SQLFORM.factory(Field('visitor_name',
                                 label='what is your name?',
                                 requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
\end{lstlisting}

The {\ft form} object can be easily serialized in HTML by embedding it in the "default/first.html" view.
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=form}}
\end{lstlisting}

The {\ft form.process()} method applies the validators and returns the form itself. The {\ft form.accepted} variable is set to True if the form was processed and passed validation. If the self-submitted form passes validation, it stores the variables in the session and redirects as before. If the form does not pass validation, error messages are inserted into the form and shown to the user, as below:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1800.png}\end{center}


In the next section we will show how forms can be generated automatically from a model.

In all our examples we have used the session to pass the user name from the first action to the second. We could have used a different mechanism and passed data as part of a redirect URL:

\begin{lstlisting}
def first():
    form = SQLFORM.factory(Field('visitor_name', requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        name = form.vars.visitor_name
        redirect(URL('second',vars=dict(name=name)))
    return dict(form=form)

def second():
    name = request.vars.visitor_name or redirect(URL('first'))
    return dict(name=name)
\end{lstlisting}

\goodbreak\subsection{Internationalization}

Your code is likely to include hardcoded strings such as "What is your name?". You should be able to customize strings without editing the code and in particular insert translations for these strings in different languages. In this way if a visitor has the language preference of the browser set to "Italian", web2py will use the Italian translation for the strings, if available. This feature of web2py is called "internationalization" and it is described in more detail in the next chapter.

Here we just observe that in order to use this feature you should markup strings that needs translation. This is done by wrapping a quoted string in code such as

\begin{lstlisting}
"What is your name?"
\end{lstlisting}
\noindent with the {\ft T} operator:

\begin{lstlisting}
T("What is your name?")
\end{lstlisting}

You can also mark for translations strings hardcoded in views. For example

\begin{lstlisting}[keywords={}]
<h1>What is your name?</h1>
\end{lstlisting}
\noindent becomes

\begin{lstlisting}[keywords={}]
<h1>{{=T("What is your name?")}}</h1>
\end{lstlisting}

It is good practice to do this for every string in the code (field labels, flash messages, etc.) except for tables and field names.

Once the strings are identified and marked up, web2py takes care of almost everything else. The admin interface also provides a page where you can translate each string in the languages you desire to support.

\goodbreak\section{An image blog}

\inxx{upload}

Here, as another example, we wish to create a web application that allows the administrator to post images and give them a name, and allows the visitors of the web site to view the named images and submit comments (posts).

As before, from the {\bf site} page in {\bf admin}, create a new application called {\ft images}, and navigate to the {\it edit} page:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en1900.png}\end{center}


We start by creating a model, a representation of the persistent data in the application (the images to upload, their names, and the comments). First, you need to create/edit a model file which, for lack of imagination, we call "db.py". We assume the code below will replace any existing code in "db.py". Models and controllers must have a {\ft .py} extension since they are Python code. If the extension is not provided, it is appended by web2py. Views instead have a {\ft .html} extension since they mainly contain HTML code.

Edit the "db.py" file by clicking the corresponding "edit" button:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2000.png}\end{center}

\noindent and enter the following:

\inxx{IS\_EMAIL} \inxx{IS\_NOT\_EMPTY} \inxx{IS\_IN\_DB}
\begin{lstlisting}
db = DAL("sqlite://storage.sqlite")

db.define_table('image',
   Field('title', unique=True),
   Field('file', 'upload'),
   format = '%(title)s')

db.define_table('post',
   Field('image_id', 'reference image'),
   Field('author'),
   Field('email'),
   Field('body', 'text'))

db.image.title.requires = IS_NOT_IN_DB(db, db.image.title)
db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
db.post.author.requires = IS_NOT_EMPTY()
db.post.email.requires = IS_EMAIL()
db.post.body.requires = IS_NOT_EMPTY()

db.post.image_id.writable = db.post.image_id.readable = False
\end{lstlisting}

Let's analyze this line by line.

Line 1 defines a global variable called {\ft db} that represents the database connection. In this case it is a connection to a SQLite database stored in the file  "applications/images/databases/storage.sqlite". When using SQLite, if the database file does not exist, it is created. You can change the name of the file, as well as the name of the global variable {\ft db}, but it is convenient to give them the same name, to make it easy to remember.

Lines 3-5 define a table "image". {\ft define\_table} is a method of the {\ft db} object. The first argument, "image", is the name of the table we are defining. The other arguments are the fields belonging to that table. This table has a field called "title", a field called "file", and a field called "id" that serves as the table primary key ("id" is not explicitly declared because all tables have an id field by default). The field "title" is a string, and the field "file" is of type "upload". "upload" is a special type of field used by the web2py Data Abstraction Layer (DAL) to store the names of uploaded files. web2py knows how to upload files (via streaming if they are large), rename them safely, and store them.

When a table is defined, web2py takes one of several possible actions:
\begin{itemize}
\item if the table does not exist, the table is created;

\item if the table exists and does not correspond to the definition, the table is altered accordingly, and if a field has a different type, web2py tries to convert its contents;

\item if the table exists and corresponds to the definition, web2py does nothing.
\end{itemize}

This behavior is called "migration". In web2py migrations are automatic, but can be disabled for each table by passing {\ft migrate=False} as the last argument of {\ft define\_table}.

Line 6 defines a format string for the table. It determines how a record should be represented as a string. Notice that the {\ft format} argument can also be a function that takes a record and returns a string. For example:

\begin{lstlisting}
format=lambda row: row.title
\end{lstlisting}

Lines 8-12 define another table called "post".
A post has an "author", an "email" (we intend to store the email address of the author of the post), a "body" of type "text" (we intend to use it to store the actual comment posted by the author), and an "image\_id" field of type reference that points to {\ft db.image} via the "id" field.

In line 14, {\ft db.image.title} represents the field "title" of table "image". The attribute {\ft requires} allows you to set requirements/constraints that will be enforced by web2py forms. Here we require that the "title" is unique:

{\ft IS\_NOT\_IN\_DB(db, db.image.title)}

{\it Notice this is optional because it is set automatically given that {\ft Field('title', unique=True)}}.

The objects representing these constraints are called validators. Multiple validators can be grouped in a list. Validators are executed in the order they appear.
{\ft IS\_NOT\_IN\_DB(a, b)} is a special validator that checks that the value of a field {\ft b} for a new record is not already in {\ft a}.

Line 15 requires that the field "image\_id" of table "post" is in {\ft db.image.id}. As far as the database is concerned, we had already declared this  when we defined the table "post".
Now we are explicitly telling the model that this condition should be enforced by web2py, too, at the form processing level when a new comment is posted, so that invalid values do not propagate from input forms to the database. We also require that the "image\_id" be represented by the "title", {\ft '\%(title)s'}, of the corresponding record.

Line 20 indicates that the field "image\_id" of table "post" should not be shown in forms, {\ft writable=False} and not even in read-only forms, {\ft readable=False}.

The meaning of the validators in lines 15-17 should be obvious.

\inxx{format}
Notice that the validator
\begin{lstlisting}
db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
\end{lstlisting}
\noindent can be omitted (and would be automatic) if we specify a format for referenced table:
\begin{lstlisting}
db.define_table('image', ..., format='%(title)s')
\end{lstlisting}
\noindent where the format can be a string or a function that takes a record and returns a string.

\inxx{appadmin}
Once a model is defined, if there are no errors, web2py creates an application administration interface to manage the database. You access it via the "database administration" link in the {\it edit} page or directly:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/images/appadmin
\end{lstlisting}

Here is a screenshot of the {\bf appadmin} interface:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2100.png}\end{center}


This interface is coded in the controller called "appadmin.py" and the corresponding view "appadmin.html". From now on, we will refer to this interface simply as {\bf appadmin}. It allows the administrator to insert new database records, edit and delete existing records, browse tables, and perform database joins.

The first time {\bf appadmin} is accessed, the model is executed and the tables are created. The web2py DAL translates Python code into SQL statements that are specific to the selected database back-end (SQLite in this example). You can see the generated SQL from the {\it edit} page by clicking on the "sql.log" link under "models". Notice that the link is not present until the tables have been created.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2200.png}\end{center}


If you were to edit the model and access {\bf appadmin} again, web2py would generate SQL to alter the existing tables. The generated SQL is logged into "sql.log".

Now go back to {\bf appadmin} and try to insert a new image record:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2300.png}\end{center}

\noindent web2py has translated the {\ft db.image.file} "upload" field into an upload form for the file. When the form is submitted and an image file is uploaded, the file is renamed in a secure way that preserves the extension, it is saved with the new name under the application "uploads" folder, and the new name is stored in the {\ft db.image.file} field. This process is designed to prevent directory traversal attacks.

Notice that each field type is rendered by a {\it widget}. Default widgets can be overridden.

When you click on a table name in {\bf appadmin}, web2py performs a select of all records on the current table, identified by the DAL query
\begin{lstlisting}
db.image.id > 0
\end{lstlisting}
\noindent and renders the result.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2400.png}\end{center}


You can select a different set of records by editing the DAL query and pressing [Submit].

To edit or delete a single record, click on the record id number.

Because of the {\ft IS\_IN\_DB} validator, the reference field "image\_id" is rendered by a drop-down menu. The items in the drop-down are stored as keys ({\ft db.image.id}), but are represented by their {\ft db.image.title}, as specified by the validator.

Validators are powerful objects that know how to represent fields, filter field values, generate errors, and format values extracted from the field.

The following figure shows what happens when you submit a form that does not pass validation:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2500.png}\end{center}


The same forms that are automatically generated by {\bf appadmin} can also be generated programmatically via the {\ft SQLFORM} helper and embedded in user applications. These forms are CSS-friendly, and can be customized.

Every application has its own {\bf appadmin}; therefore, {\bf appadmin} itself can be modified without affecting other applications.

So far, the application knows how to store data, and we have seen how to access the database via {\bf appadmin}. Access to {\bf appadmin} is restricted to the administrator, and it is not intended as a production web interface for the application; hence the next part of this walk-through. Specifically we want to create:
\begin{itemize}
\item An "index" page that lists all available images sorted by title and links to detail pages for the images.

\item A "show/[id]" page that shows the visitor the requested image and allows the visitor to view and post comments.

\item A "download/[name]" action to download uploaded images.
\end{itemize}

This is represented schematically here:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2600.png}\end{center}


Go back to the {\it edit} page and edit the "default.py" controller, replacing its contents with the following:

\inxx{select}
\begin{lstlisting}
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)
\end{lstlisting}

This action returns a dictionary. The keys of the items in the dictionary are interpreted as variables passed to the view associated to the action. When developing, if there is no view, the action is rendered by the "generic.html" view that is provided with every web2py application.

The index action performs a select of all fields ({\ft db.image.ALL}) from table image, ordered by {\ft db.image.title}. The result of the select is a {\ft Rows} object containing the records. Assign it to a local variable called {\ft images} returned by the action to the view. {\ft images} is iterable and its elements are the selected rows. For each row the columns can be accessed as dictionaries:
{\ft images[0]['title']} or equivalently as {\ft images[0].title}.

If you do not write a view, the dictionary is rendered by "views/generic.html" and a call to the index action would look like this:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2700.png}\end{center}


You have not created a view for this action yet, so web2py renders the set of records in plain tabular form.

Proceed to create a view for the index action. Return to admin, edit "default/index.html" and replace its content with the following:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
\end{lstlisting}

The first thing to notice is that a view is pure HTML with special \{\{...\}\} tags. The code embedded in \{\{...\}\} is pure Python code with one caveat: indentation is irrelevant. Blocks of code start with lines ending in colon (:) and end in lines beginning with the keyword {\ft pass}. In some cases the end of a block is obvious from context and the use of {\ft pass} is not required.

Lines 5-7 loop over the image rows and for each row image display:
\begin{lstlisting}
LI(A(image.title, _href=URL('show', args=image.id))
\end{lstlisting}

This is a {\ft <li>...</li>} tag that contains an {\ft <a href="...">...</a>} tag which contains the {\ft image.title}. The value of the hypertext reference (href attribute) is:
\begin{lstlisting}
URL('show', args=image.id)
\end{lstlisting}
\noindent i.e., the URL within the same application and controller as the current request that calls the function called "show", passing a single argument to the function, {\ft args=image.id}.
{\ft LI}, {\ft A}, etc. are web2py helpers that map to the corresponding HTML tags. Their unnamed arguments are interpreted as objects to be serialized and inserted in the tag's innerHTML. Named arguments starting with an underscore (for example {\ft \_href}) are interpreted as tag attributes but without the underscore. For example {\ft \_href} is the {\ft href} attribute, {\ft \_class} is the {\ft class} attribute, etc.

As an example, the following statement:
\begin{lstlisting}[keywords={}]
{{=LI(A('something', _href=URL('show', args=123))}}
\end{lstlisting}
\noindent is rendered as:
\begin{lstlisting}[keywords={}]
<li><a href="/images/default/show/123">something</a></li>
\end{lstlisting}

A handful of helpers ({\ft INPUT}, {\ft TEXTAREA}, {\ft OPTION} and {\ft SELECT}) also support some special named attributes not starting with underscore ({\ft value}, and {\ft requires}). They are important for building custom forms and will be discussed later.

Go back to the {\it edit} page. It now indicates that "default.py exposes index". By clicking on "index", you can visit the newly created page:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/images/default/index
\end{lstlisting}
\noindent which looks like:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2800.png}\end{center}


If you click on the image name link, you are directed to:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/images/default/show/1
\end{lstlisting}
\noindent and this results in an error, since you have not yet created an action called "show" in controller "default.py".

Let's edit the "default.py" controller and replace its content with:

\inxx{SQLFORM} \inxx{accepts} \inxx{response.flash} \inxx{request.args}
\inxx{response.download}
\begin{lstlisting}
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)

def show():
    image = db.image(request.args(0,cast=int)) or redirect(URL('index'))
    db.post.image_id.default = image.id
    form = SQLFORM(db.post)
    if form.process().accepted:
        response.flash = 'your comment is posted'
    comments = db(db.post.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)

def download():
    return response.download(request, db)
\end{lstlisting}

The controller contains two actions: "show" and "download".
The "show" action selects the image with the {\ft id} parsed from the request args and all comments related to the image. "show" then passes everything to the view "default/show.html".

The image id referenced by:
\begin{lstlisting}
URL('show', args=image.id)
\end{lstlisting}
\noindent in "default/index.html", can be accessed as:

{\ft request.args(0,cast=int)}
\noindent from the "show" action. The {\ft cast=int} argument is optional but very important. It attempts to cast the string value passed in the PATH\_INFO into an int. On failure it raises a proper exception instead of causing a ticket. One can also specify a redirect in case of failure to cast:

{\ft request.args(0,cast=int,otherwise=URL('error'))}

Moreover {\ft db.image(...)} is a shortcut for

\begin{lstlisting}
db(db.image.id==...).select().first()
\end{lstlisting}

The "download" action expects a filename in {\ft request.args(0)}, builds a path to the location where that file is supposed to be, and sends it back to the client. If the file is too large, it streams the file without incurring any memory overhead.

Notice the following statements:
\begin{itemize}
\item Line 7 creates an insert form SQLFORM for the {\ft db.post} table using only the specified fields.

\item Line 8 sets the value for the reference field, which is not part of the input form because it is not in the list of fields specified above.

\item Line 9 processes the submitted form (the submitted form variables are in {\ft request.vars}) within the current session (the session is used to prevent double submissions, and to enforce navigation). If the submitted form variables are validated, the new comment is inserted in the {\ft db.post} table; otherwise the form is modified to include error messages (for example, if the author's email address is invalid). This is all done in line 9!.

\item Line 10 is only executed if the form is accepted, after the record is inserted into the database table. {\ft response.flash} is a web2py variable that is displayed in the views and used to notify the visitor that something happened.

\item Line 11 selects all comments that reference the current image.
\end{itemize}

\begin{quote}The "download" action is already defined in the "default.py" controller of the scaffolding application.\end{quote}
The "download" action does not return a dictionary, so it does not need a view. The "show" action, though, should have a view, so return to {\bf admin} and create a new view called "default/show.html".

Edit this new file and replace its content with the following:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Image: {{=image.title}}</h1>
<center>
<img width="200px"
     src="{{=URL('download', args=image.file)}}" />
</center>
{{if len(comments):}}
  <h2>Comments</h2><br /><p>
  {{for post in comments:}}
    <p>{{=post.author}} says <i>{{=post.body}}</i></p>
  {{pass}}</p>
{{else:}}
  <h2>No comments posted yet</h2>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
\end{lstlisting}

This view displays the {\bf image.file} by calling the "download" action inside an {\ft <img ... />} tag.
If there are comments, it loops over them and displays each one.

Here is how everything will appear to a visitor.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en2900.png}\end{center}


When a visitor submits a comment via this page, the comment is stored in the database and appended at the bottom of the page.

\goodbreak\subsection{Adding authentication}

The web2py API for Role-Based Access Control is quite sophisticated, but for now we will limit ourselves to restricting access to the show action to authenticated users, deferring a more detailed discussion to Chapter 9.

To limit access to authenticated users, we need to complete three steps. In a model, for example "db.py", we need to add:
\begin{lstlisting}
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables(username=True)
\end{lstlisting}

In our controller, we need to add one action:
\begin{lstlisting}
def user():
    return dict(form=auth())
\end{lstlisting}

This is sufficient to enable login, register, logout, etc. pages. The default layout will also show options to the corresponding pages in the top right corner.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3000.png}\end{center}


We can now decorate the functions that we want to restrict, for example:
\begin{lstlisting}
@auth.requires_login()
def show():
    ...
\end{lstlisting}

Any attempt to access
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/images/default/show/[image_id]
\end{lstlisting}
\noindent will require login. If the user is not logged it, the user will be redirected to
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/images/default/user/login
\end{lstlisting}


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3100.png}\end{center}


The {\ft user} function also exposes, among others, the following actions:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/images/default/user/logout
http://127.0.0.1:8000/images/default/user/register
http://127.0.0.1:8000/images/default/user/profile
http://127.0.0.1:8000/images/default/user/change_password
http://127.0.0.1:8000/images/default/user/request_reset_password
http://127.0.0.1:8000/images/default/user/retrieve_username
http://127.0.0.1:8000/images/default/user/retrieve_password
http://127.0.0.1:8000/images/default/user/verify_email
http://127.0.0.1:8000/images/default/user/impersonate
http://127.0.0.1:8000/images/default/user/not_authorized
\end{lstlisting}

Now, a first-time user needs to register in order to be able to log in and read or post comments.

\begin{quote}Both the {\ft auth} object and the {\ft user} function are already defined in the scaffolding application. The {\ft auth} object is highly customizable and can deal with email verification, registration approvals, CAPTCHA, and alternate login methods via plugins.\end{quote}
\goodbreak\subsection{Adding grids}

We can improve this further using the {\ft SQLFORM.grid} and {\ft SQLFORM.smartgrid} gadgets to create a management interface for our application:

\begin{lstlisting}
@auth.requires_membership('manager')
def manage():
    grid = SQLFORM.smartgrid(db.image,linked_tables=['post'])
    return dict(grid=grid)
\end{lstlisting}
\noindent with associated "views/default/manage.html"

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h2>Management Interface</h2>
{{=grid}}
\end{lstlisting}

Using appadmin create a group "manager" and make some users members of the group. They will not be able to access

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/images/default/manage
\end{lstlisting}
\noindent and browse, search:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3200.png}\end{center}

\noindent create, update and delete images and their comments:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3300.png}\end{center}


\goodbreak\subsection{Configuring the layout}

You can configure the default layout by editing "views/layout.html" but you can also configure it without editing the HTML. In fact, the "static/base.css" stylesheet is well documented and described in Chapter 5. You can change color, columns, size, borders and background without editing the HTML. If you want to edit the menu, the title or the subtitle, you can do so in any model file. The scaffolding app, sets default values of these parameters in the file "models/menu.py":

\begin{lstlisting}
response.title = request.application
response.subtitle = 'customize me!'
response.meta.author = 'you'
response.meta.description = 'describe your app'
response.meta.keywords = 'bla bla bla'
response.menu = [ [ 'Index', False, URL('index') ] ]
\end{lstlisting}

\goodbreak\section{A simple wiki}

\inxx{wiki} \inxx{RSS} \inxx{Ajax} \inxx{XMLRPC}

In this section, we build a simple wiki from scratch using only low level APIs (as opposed to using the built-in wiki capabilities of web2py demonstrated in the next section). The visitor will be able to create pages, search them (by title), and edit them. The visitor will also be able to post comments (exactly as in the previous applications), and also post documents (as attachments to the pages) and link them from the pages. As a convention, we adopt the Markmin syntax for our wiki syntax. We will also implement a search page with Ajax, an RSS feed for the pages, and a handler to search the pages via XML-RPC~\cite{xmlrpc}. The following diagram lists the actions that we need to implement and the links we intend to build among them.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3400.png}\end{center}


Start by creating a new scaffolding app, naming it "mywiki".

The model must contain three tables: page, comment, and document. Both comment and document reference page because they belong to page. A document contains a file field of type upload as in the previous images application.

Here is the complete model:
\begin{lstlisting}
db = DAL('sqlite://storage.sqlite')

from gluon.tools import *
auth = Auth(db)
auth.define_tables()
crud = Crud(db)

db.define_table('page',
    Field('title'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(title)s')

db.define_table('post',
    Field('page_id', 'reference page'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id))

db.define_table('document',
    Field('page_id', 'reference page'),
    Field('name'),
    Field('file', 'upload'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(name)s')

db.page.title.requires = IS_NOT_IN_DB(db, 'page.title')
db.page.body.requires = IS_NOT_EMPTY()
db.page.created_by.readable = db.page.created_by.writable = False
db.page.created_on.readable = db.page.created_on.writable = False

db.post.body.requires = IS_NOT_EMPTY()
db.post.page_id.readable = db.post.page_id.writable = False
db.post.created_by.readable = db.post.created_by.writable = False
db.post.created_on.readable = db.post.created_on.writable = False

db.document.name.requires = IS_NOT_IN_DB(db, 'document.name')
db.document.page_id.readable = db.document.page_id.writable = False
db.document.created_by.readable = db.document.created_by.writable = False
db.document.created_on.readable = db.document.created_on.writable = False
\end{lstlisting}

Edit the controller "default.py" and create the following actions:
\begin{itemize}
\item index: list all wiki pages

\item create: add a new wiki page

\item show: show a wiki page and its comments, and add new comments

\item edit: edit an existing page

\item documents: manage the documents attached to a page

\item download: download a document (as in the images example)

\item search: display a search box and, via an Ajax callback, return all matching titles as the visitor types

\item callback: the Ajax callback function. It returns the HTML that gets embedded in the search page while the visitor types.
\end{itemize}

Here is the "default.py" controller:
\begin{lstlisting}
def index():
     """ this controller returns a dictionary rendered by the view
         it lists all wiki pages
     >>> index().has_key('pages')
     True
     """
     pages = db().select(db.page.id,db.page.title,orderby=db.page.title)
     return dict(pages=pages)

@auth.requires_login()
def create():
     """creates a new empty wiki page"""
     form = SQLFORM(db.page).process(next=URL('index'))
     return dict(form=form)

def show():
     """shows a wiki page"""
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.post.page_id.default = this_page.id
     form = SQLFORM(db.post).process() if auth.user else None
     pagecomments = db(db.post.page_id==this_page.id).select()
     return dict(page=this_page, comments=pagecomments, form=form)

@auth.requires_login()
def edit():
     """edit an existing wiki page"""
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     form = SQLFORM(db.page, this_page).process(
         next = URL('show',args=request.args))
     return dict(form=form)

@auth.requires_login()
def documents():
     """browser, edit all documents attached to a certain page"""
     page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.document.page_id.default = page.id
     db.document.page_id.writable = False
     grid = SQLFORM.grid(db.document.page_id==page.id,args=[page.id])
     return dict(page=page, grid=grid)

def user():
     return dict(form=auth())

def download():
     """allows downloading of documents"""
     return response.download(request, db)

def search():
     """an ajax wiki search page"""
     return dict(form=FORM(INPUT(_id='keyword',_name='keyword',
              _onkeyup="ajax('callback', ['keyword'], 'target');")),
              target_div=DIV(_id='target'))

def callback():
     """an ajax callback that returns a <ul> of links to wiki pages"""
     query = db.page.title.contains(request.vars.keyword)
     pages = db(query).select(orderby=db.page.title)
     links = [A(p.title, _href=URL('show',args=p.id)) for p in pages]
     return UL(*links)
\end{lstlisting}

Lines 2-6 provide a comment for the index action. Lines 4-5 inside the comment are interpreted by python as test code (doctest). Tests can be run via the admin interface. In this case the tests verify that the index action runs without errors.

Lines 18, 27, and 35 try to fetch a {\ft page} record with the id in
{\ft request.args(0)}.

Lines 13, 20 define and process create forms for a new page and a new comment and

Line 28 defines and processes an update form for a wiki page.

Line 38 creates a {\ft grid} object that allows to view, add and update the comments linked to a page.

Some magic happens in line 51. The {\ft onkeyup} attribute of the INPUT tag "keyword" is set. Every time the visitor releases a key, the JavaScript code inside the {\ft onkeyup} attribute is executed, client-side. Here is the JavaScript code:
\begin{lstlisting}
ajax('callback', ['keyword'], 'target');
\end{lstlisting}
{\ft ajax} is a JavaScript function defined in the file "web2py.js" which is included by the default "layout.html". It takes three parameters: the URL of the action that performs the synchronous callback, a list of the IDs of variables to be sent to the callback (["keyword"]), and the ID where the response has to be inserted ("target").

As soon as you type something in the search box and release a key, the client calls the server and sends the content of the 'keyword' field, and, when the sever responds, the response is embedded in the page itself as the innerHTML of the 'target' tag.

The 'target' tag is a DIV defined in line 52. It could have been defined in the view as well.

Here is the code for the view "default/create.html":
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Create new wiki page</h1>
{{=form}}
\end{lstlisting}

Assuming you are registered and logged in, if you visit the {\bf create} page, you see the following:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3500.png}\end{center}


Here is the code for the view "default/index.html":
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Available wiki pages</h1>
[ {{=A('search', _href=URL('search'))}} ]<br />
<ul>{{for page in pages:}}
     {{=LI(A(page.title, _href=URL('show', args=page.id)))}}
{{pass}}</ul>
[ {{=A('create page', _href=URL('create'))}} ]
\end{lstlisting}

It generates the following page:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3600.png}\end{center}


Here is the code for the view "default/show.html":

\inxx{markdown} \inxx{MARKMIN}
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>{{=page.title}}</h1>
[ {{=A('edit', _href=URL('edit', args=request.args))}}
| {{=A('documents', _href=URL('documents', args=request.args))}} ]<br />
{{=MARKMIN(page.body)}}
<h2>Comments</h2>
{{for post in comments:}}
  <p>{{=db.auth_user[post.created_by].first_name}} on {{=post.created_on}}
     says <i>{{=post.body}}</i></p>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
\end{lstlisting}

If you wish to use markdown syntax instead of markmin syntax:

\begin{lstlisting}
from gluon.contrib.markdown import WIKI
\end{lstlisting}
\noindent and use {\ft WIKI} instead of the {\ft MARKMIN} helper.
Alternatively, you can choose to accept raw HTML instead of markmin syntax. In this case you would replace:
\begin{lstlisting}[keywords={}]
{{=MARKMIN(page.body)}}
\end{lstlisting}
\noindent with:
\begin{lstlisting}[keywords={}]
{{=XML(page.body)}}
\end{lstlisting}

\inxx{sanitize}
(so that the XML does not get escaped, which web2py normally does by default for security reasons).

This can be done better with:
\begin{lstlisting}[keywords={}]
{{=XML(page.body, sanitize=True)}}
\end{lstlisting}

By setting {\ft sanitize=True}, you tell web2py to escape unsafe XML tags such as "<script>", and thus prevent XSS vulnerabilities.

Now if, from the index page, you click on a page title, you can see the page that you have created:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3700.png}\end{center}


Here is the code for the view "default/edit.html":
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Edit wiki page</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
{{=form}}
\end{lstlisting}

It generates a page that looks almost identical to the create page.

Here is the code for the view "default/documents.html":
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Documents for page: {{=page.title}}</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
<h2>Documents</h2>
{{=grid}}
\end{lstlisting}

If, from the "show" page, you click on documents, you can now manage the documents attached to the page.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3800.png}\end{center}


Finally here is the code for the view "default/search.html":
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Search wiki pages</h1>
[ {{=A('listall', _href=URL('index'))}}]<br />
{{=form}}<br />{{=target_div}}
\end{lstlisting}
\noindent which generates the following Ajax search form:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en3900.png}\end{center}


You can also try to call the callback action directly by visiting, for example, the following URL:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/mywiki/default/callback?keyword=wiki
\end{lstlisting}

If you look at the page source you see the HTML returned by the callback:
\begin{lstlisting}[keywords={}]
<ul><li><a href="/mywiki/default/show/4">I made a Wiki</a></li></ul>
\end{lstlisting}

\inxx{rss}
Generating an RSS feed of your wiki pages using web2py is easy because web2py includes {\ft gluon.contrib.rss2}. Just append the following action to the default controller:
\begin{lstlisting}
def news():
    """generates rss feed from the wiki pages"""
    response.generic_patterns = ['.rss']
    pages = db().select(db.page.ALL, orderby=db.page.title)
    return dict(
       title = 'mywiki rss feed',
       link = 'http://127.0.0.1:8000/mywiki/default/index',
       description = 'mywiki news',
       created_on = request.now,
       items = [
          dict(title = row.title,
               link = URL('show', args=row.id),
               description = MARKMIN(row.body).xml(),
               created_on = row.created_on
               ) for row in pages])
\end{lstlisting}
\noindent and when you visit the page
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/mywiki/default/news.rss
\end{lstlisting}
\noindent you see the feed (the exact output depends on the feed reader). Notice that the dict is automatically converted to RSS, thanks to the.rss extension in the URL.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4000.png}\end{center}

\noindent web2py also includes feedparser to read third-party feeds.

\inxx{XMLRPC}
Finally, let's add an XML-RPC handler that allows searching the wiki programmatically:
\begin{lstlisting}
service = Service()

@service.xmlrpc
def find_by(keyword):
     """finds pages that contain keyword for XML-RPC"""
     return db(db.page.title.contains(keyword)).select().as_list()

def call():
    """exposes all registered services, including XML-RPC"""
    return service()
\end{lstlisting}

Here, the handler action simply publishes (via XML-RPC), the functions specified in the list. In this case, {\ft find\_by}. {\ft find\_by} is not an action (because it takes an argument). It queries the database with {\ft .select()} and then extracts the records as a list with {\ft .response} and returns the list.

Here is an example of how to access the XML-RPC handler from an external
Python program.
\begin{lstlisting}
>>> import xmlrpclib
>>> server = xmlrpclib.ServerProxy(
    'http://127.0.0.1:8000/mywiki/default/call/xmlrpc')
>>> for item in server.find_by('wiki'):
        print item['created_on'], item['title']
\end{lstlisting}

The handler can be accessed from many other programming languages that understand XML-RPC, including C, C++, C\# and Java.

\goodbreak\subsection{On {\ft date}, {\ft datetime} and {\ft time} format}

There are three different representations for each of the field types {\ft date}, {\ft datetime} and {\ft time}:
\begin{itemize}
\item the database representation

\item the internal web2py representation

\item the string representation in forms and tables
\end{itemize}

The database representation is an internal issue and does not affect the code. Internally, at the web2py level, they are stored as {\ft datetime.date}, {\ft datetime.datetime} and {\ft datetime.time} object respectively and they can be manipulated as such:

\begin{lstlisting}
for page in db(db.page).select():
    print page.title, page.day, page.month, page.year
\end{lstlisting}

When dates are converted to strings in forms they are converted using the ISO representation
\begin{lstlisting}
%Y-%m-%d %H:%M:%S
\end{lstlisting}
\noindent yet this representation is internationalized and you can use the admin translation page to change the format to an alternate one. For example:

\begin{lstlisting}
%m/%b/%Y %H:%M:%S
\end{lstlisting}

Mind that by default English is not translated because web2py assumes the applications are written in English. If you want internationalization to work for English you need to create the translation file (using admin) and you need to declare that the application's current language is something other than english, for example:
\begin{lstlisting}
T.current_languages = ['null']
\end{lstlisting}

\goodbreak\section{The built-in web2py wiki}

Now you can forget the code we have built-in the previous section (not what you have learned about web2py APIs, just the code of the specific example) as we are going to provide an example of the built-in web2py wiki.

In fact, web2py comes with wiki capabilities including media attachments, tags, tag cloud, page permissions, and support for oembed~\cite{oembed} and components (chapter 14). This wiki can be used with any web2py application.

\begin{quote}Notice the API of the built-in wiki is still considered experimental and small changes are still possible.\end{quote}
Here we assume we are starting from scratch from a simple clone of the "welcome" application called "wikidemo". Edit the controller and replace the "index" action with

\begin{lstlisting}
def index(): return auth.wiki()
\end{lstlisting}

Done! You have a fully working wiki. At this point no page has been created and in order to create pages you must be logged-in and you must be member of a group called "wiki-editor" or "wiki-author". If you are logged-in as administrator the "wiki-editor" group is created automatically and you are made a member. The difference between editors and authors is that the editors can create pages, edit and delete any page, while the authors can create pages (with some optional restrictions) and can only edit/delete the pages they have created.

The {\ft auth.wiki()} function returns in a dictionary with a key {\ft content} which is understood by the scaffolding "views/default/index.html". You can make your own view for this action:

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=content}}
\end{lstlisting}
\noindent and add extra HTML or code as needed. There is no need to call the action "index".

To try the wiki, simply login into admin, visit the page

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/wikidemo/default/index
\end{lstlisting}

Then choose a slug (in the publishing business, a slug is a short name given to an article that is in production) and you will be redirected to an empty page where you can edit the content using MARKMIN wiki syntax. A new menu item called "[wiki]" will allow you to create, search, and edit pages. Wiki pages have URLs like:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/wikidemo/default/index/[slug]
\end{lstlisting}

Service pages have names which start by underscore:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/wikidemo/default/index/_create
http://127.0.0.1:8000/wikidemo/default/index/_search
http://127.0.0.1:8000/wikidemo/default/index/_could
http://127.0.0.1:8000/wikidemo/default/index/_recent
http://127.0.0.1:8000/wikidemo/default/index/_edit/...
http://127.0.0.1:8000/wikidemo/default/index/_editmedia/...
http://127.0.0.1:8000/wikidemo/default/index/_preview/...
\end{lstlisting}

Try to create more pages such as "index", "aboutus", and "contactus".
Try to edit them.

The {\ft wiki} method has the following signature:

\begin{lstlisting}
def wiki(self, slug=None, env=None, render='markmin',
         manage_permissions=False, force_prefix='',
         restrict_search=False, resolve=True,
         extra=None, menugroups=None)
\end{lstlisting}

It takes the following arguments:

\begin{itemize}
\item {\ft render} which defaults to {\ft 'markmin'} but can be set equal to {\ft 'html'}. It determines the syntax of the wiki. We will discuss the markmin wiki markup later. If you change it to HTML you may want to use a wysiwyg javascript editor such as TinyMCE or NicEdit.

\item {\ft manage\_permissions}. This is set to {\ft False} by default and only recognizes permissions for "wiki-editor" and "wiki-author". If you change it to {\ft True} the create/edit page will give the option to specify by names the group(s) whose members have permission to read and edit the page. There is a group "everybody" which includes all users.

\item {\ft force\_prefix}. If set to something like {\ft '\%(id)s-'} it will restrict authors (not editors) to creating pages with a prefix like "[user id]-[page name]". The prefix can contain the id ("\%(id)s") or the username ("\%(username)s") or any other field from the auth\_user table, as long as the corresponding column contains valid string that would pass URL validation.

\item {\ft restrict\_search}. This defaults to {\ft False} and any logged-in user can search all wiki pages (but not necessary read or edit them). If set to {\ft True}, authors can search only their own pages, editors can search everything, other users cannot search anything.

\item {\ft menugroups}. This defaults to {\ft None} and it indicates that wiki management menu (search, create, edit, etc.) is always displayed. You can set it to a list of group names whose members only can see this menu, for example {\ft ['wiki-editor','wiki-author']}. Notice that even if the menu is exposed to everybody that does not mean everybody is allowed to perform actions listed in the menu since they are regulated by the access control system.
\end{itemize}

The {\ft wiki} method has some additional parameters which will be explained later: {\ft slug}, {\ft env}, and {\ft extra}.

\goodbreak\subsection{MARKMIN basics}

The MARKMIN syntax allows you to markup {\bf bold} text using {\ft **bold**}, {\it italic} text with {\ft ''italic''}, {\ft code} text with {\ft {\textbackslash}`{\textbackslash}`code{\textbackslash}`{\textbackslash}}'. Titles must be prefixed by a \#, sections by \#\#, and sub-sections by \#\#\#. Use a minus(-) to prefix an un-ordered item and plus(+) to prefix an ordered item. URLs are automatically converted into links. For example:

\begin{lstlisting}
# This is a title
## this is a section title
### this is a subsection title

Text can be **bold**, ''italic'', ``code`` etc.
Learn more at:

http://web2py.com
\end{lstlisting}

You can use the {\ft extra} parameter of {\ft auth.wiki} to pass extra rendering rules to the MARKMIN helper.

You can find more information about the MARKMIN syntax in chapter 5.

{\ft auth.wiki} is more powerful than the barebones MARKMIN helpers, supporting oembed and components.

You can use the {\ft env} parameter of {\ft auth.wiki} to expose functions to your wiki.
For example:

\begin{lstlisting}
auth.wiki(env=dict(join=lambda a,b,c:"%s-%s-%s" % (a,b,c)))
\end{lstlisting}
\noindent allows you to use the markup syntax:

\begin{lstlisting}
@(join:1,2,3)
\end{lstlisting}

This calls the join function passed as extra with parameters {\ft a,b,c=1,2,3} and will be rendered as {\ft 1-2-3}.

\goodbreak\subsection{Oembed protocol}

You can type in (or cut-and-paste) any URL into a wiki page and it is rendered as a link to the URL. There are exceptions:

\begin{itemize}
\item If the URL has an image extension, the link is embedded as an image, {\ft <img/>}.

\item If the URL has an audio extension, the link is embedded as HTML5 audio {\ft <audio/>}.

\item If the URL has a video extension, the link is embedded as HTML5 video {\ft <video/>}.

\item If the URL has a MS Office or PDF extension, Google Doc Viewer is embedded, showing the content of the document (only works for public documents).

\item If the URL points to a YouTube page, a Vimeo page, or a Flickr page, web2py contacts the corresponding web service and queries it about the proper way to embed the content. This is done using the {\ft oembed} protocol.
\end{itemize}

Here is a complete list of supported formats:
\begin{lstlisting}
Image (.PNG, .GIF, .JPG, .JPEG)
Audio (.WAV, .OGG, .MP3)
Video (.MOV, .MPE, .MP4, .MPG, .MPG2, .MPEG, .MPEG4, .MOVIE)
\end{lstlisting}

Supported via Google Doc Viewer:

\begin{lstlisting}
Microsoft Excel (.XLS and .XLSX)
Microsoft PowerPoint 2007 / 2010 (.PPTX)
Apple Pages (.PAGES)
Adobe PDF (.PDF)
Adobe Illustrator (.AI)
Adobe Photoshop (.PSD)
Autodesk AutoCad (.DXF)
Scalable Vector Graphics (.SVG)
PostScript (.EPS, .PS)
TrueType (.TTF)
xml Paper Specification (.XPS)
\end{lstlisting}

Supported by oembed:

\begin{lstlisting}
flickr.com
youtube.com
hulu.com
vimeo.com
slideshare.net
qik.com
polleverywhere.com
wordpress.com
revision3.com
viddler.com
\end{lstlisting}

This is implemented in the web2py file {\ft gluon.contrib.autolinks} and specifically in the function {\ft expand\_one}. You can extend oembed support by registering more services. This is done by appending an entry to the {\ft EMBED\_MAPS} list:

\begin{lstlisting}
from gluon.contrib.autolinks import EMBED_MAPS
EMBED_MAPS.append((re.compile('http://vimeo.com/\S*'),
                   'http://vimeo.com/api/oembed.json'))
\end{lstlisting}

\goodbreak\subsection{Referencing wiki content}

If you create a wiki page with slug "contactus" you can refer to this page as

\begin{lstlisting}
@////contactus
\end{lstlisting}

Here {\ft {\textbackslash}@////} stands for

\begin{lstlisting}
@/app/controller/function/
\end{lstlisting}
\noindent but "app", "controller", and "function" are omitted thus assuming default.

Similarly you can use the wiki menu to upload a media file (for example an image) linked to the page. The "manage media" page will show all files you have uploaded and will show the proper expression to link the media file. If, for example you upload a file "test.jpg" with title "beach", the link expression will something like:

\begin{lstlisting}
@////15/beach.jpg
\end{lstlisting}

{\ft {\textbackslash}@////} is the same prefix described before. {\ft 15} is the id of the record storing the media file. {\ft beach} is the title. {\ft .jpg} is the extension of the original file.

If you cut and paste {\ft {\textbackslash}@////15/beach.jpg} into wiki pages you embed the image.

Mind that media files are linked to pages and inherit access permission from the pages.

\goodbreak\subsection{Wiki menus}

If you create a page with slug "wiki-menu" page it will be interpreted as a description of the menu. Here is an example:

\begin{lstlisting}
- Home > @////index
- Info > @////info
- web2py > http://google.com
- - About us > @////aboutus
- - Contact us > @////contactus
\end{lstlisting}

Each line a menu item. We used double dash for nested menu items. The {\ft >} symbols separates the menu item title from the menu item link.

Mind that the menu is appended to {\ft response.menu}. It does not replace it. The {\ft [wiki]} menu item with service functions is added automatically.

\goodbreak\subsection{Service functions}

If, for example, you want to use the wiki to create an editable sidebar you could create a page with {\ft slug="sidebar"} and then embed it in your layout.html with

\begin{lstlisting}[keywords={}]
{{=auth.wiki(slug='sidebar')}}
\end{lstlisting}

Notice that there is nothing special with the word "sidebar". Any wiki page can be retrieved and embedded at any point in your code. This allows you mix and match wiki functionalities with regular web2py functionalities.

\begin{quote}Also note that {\ft auth.wiki('sidebar')} is the same as {\ft auth.wiki(slug='sidebar')}, since the slug kwarg is the first in the method signature. The former gives a slightly simpler syntax.\end{quote}
You can also embed special wiki functions such as the search by tags:

\begin{lstlisting}[keywords={}]
{{=auth.wiki('_search')}}
\end{lstlisting}
\noindent or the tag cloud:

\begin{lstlisting}[keywords={}]
{{=auth.wiki('_cloud')}}
\end{lstlisting}

\goodbreak\subsection{Extending the auth.wiki feature}

When your wiki-enabled app gets more complicated, perhaps you might need to customize the wiki db records managed by the Auth interface or expose customized forms for wiki CRUD tasks. For example, you might want to customize a wiki table record representation or add a new field validator. This is not allowed by default, since the wiki model is defined only after the wiki interface is requested with the auth.wiki() method. To allow access to the wiki specific db setup within the model of your app you must add the following sentence to your model file (i.e. db.py)

\begin{lstlisting}
# Make sure this is called after the auth instance is created
# and before any change to the wiki tables
auth.wiki(resolve=False)
\end{lstlisting}

By using the line above in your model, the wiki tables will be accessible (i.e. {\ft wiki\_page}) for custom CRUD or other db tasks.

\begin{quote}Note that you still have to call auth.wiki() in the controller or view in order to expose the wiki interface, since the {\ft resolve=False} parameter instructs the auth object to just build the wiki model without any other interface setup.\end{quote}
Also, by setting resolve to {\ft False} in the method call, the wiki tables will be now accessible through the app's default db interface at {\ft <app>/appadmin} for managing wiki records.

Another customization possible is adding extra fields to the standard wiki tables (in the same way as with the {\ft auth\_user} table, as described in Chapter 9). Here is how:

\begin{lstlisting}
# Place this after auth object initialization
auth.settings.extra_fields["wiki_page"] = [Field("ablob", "blob"),]
\end{lstlisting}

The line above adds a {\ft blob} field to the {\ft wiki\_page} table. There is no need to call {\ft auth.wiki(resolve=False)} for this option, unless you need access to the wiki model for other customizations.

\goodbreak\subsection{Components}

One of the most powerful functions of the new web2py consists in the ability of embedding an action inside another action. We call this a component.

Consider the following model:

\begin{lstlisting}
db.define_table('thing',Field('name',requires=IS_NOT_EMPTY()))
\end{lstlisting}
\noindent and the following action:

\begin{lstlisting}
@auth.requires_login()
def manage_things():
    return SQLFORM.grid(db.thing)
\end{lstlisting}

This action is special because it returns a widget/helper not a dict of objects. Now we can embed this {\ft manage\_things} action into any view, with

\begin{lstlisting}[keywords={}]
{{=LOAD('default','manage_things',ajax=True)}}
\end{lstlisting}

This allows the visitor interact with the component via Ajax without reloading the host page that embeds the widget. Basically the action is called via Ajax, inherits the style of the host page, and captures all form submissions and flash messages so that they are handled within the current page. On top of this the {\ft SQLFORM.grid} widget uses digitally signed URLs to restrict access. More information about components can be found in chapter 13.

Components like the one above can be embedded into wiki pages using the MARKMIN syntax:

\begin{lstlisting}
@{component:default/manage_things}
\end{lstlisting}

This simply tells web2py that we want to include the "manage\_things" action defined in the "default" controller as an Ajax "component".

\begin{quote}Most users will be able to build relatively complex applications simply by using {\ft auth.wiki} to create pages and menus and embedded custom components into wiki pages. Wikis can be thought of as a mechanism to allow members of the group to create pages, but they can also be thought of as a way to develop applications in a modular way.\end{quote}
\goodbreak\section{More on {\bf admin}}

\inxx{admin}

The administrative interface provides additional functionality that we briefly review here.

\goodbreak\subsection{Site}

\inxx{site}

This page is the main administrative interface of web2py. It lists all installed applications on the left, while on the right side there are some special action forms.

The first of them shows the web2py version and proposes to upgrade it if new versions are available. Of course, before upgrading be sure to have a full working backup!
Then there are two other forms that allow the creation of a new application (simple or by using an online wizard) by specifying its name.

\inxx{Instant Press} \inxx{Movuca}
The following form allows uploading an existing application from either a local file or a remote URL. When you upload an application, you need to specify a name for it (using different names
allows you to install multiple copies of the same application). You can try, for example, to upload the Movuca Social Networking application app created by Bruno Rocha:

\begin{lstlisting}[keywords={}]
https://github.com/rochacbruno/Movuca
\end{lstlisting}
\noindent or Instant Press CMS created by Martin Mulone:

\begin{lstlisting}[keywords={}]
http://code.google.com/p/instant-press/
\end{lstlisting}
\noindent or one of the many example applications available at:

\begin{lstlisting}[keywords={}]
http://web2py.com/appliances
\end{lstlisting}

\begin{quote}Web2py files are packages as {\ft .w2p} files. These are tar gzipped files. Web2py uses the {\ft .w2p} extension instead of the {\ft .tgz} extension to prevent the browser from unzipping on download. They can be uncompressed manually with {\ft tar zxvf [filename]} although this is never necessary.\end{quote}

\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4100.png}\end{center}


Upon successful upload, web2py displays the MD5 checksum of the uploaded file. You can use it to verify that the file was not corrupted during upload. The InstantPress name will appear in the list of installed applications.

If you run web2py from source and you have {\ft gitpython} installed (if necessary, set it up with 'easy\_install gitpython'), you can install applications directly from git repositories
using the {\ft .git} URL in the upload form. In this case you will also be enabled to use the admin interface to push changes back into the repository, but this is an experimental feature.

For example, you can locally install the application that shows this book on the web2py site with the URL:

\begin{lstlisting}[keywords={}]
https://github.com/mdipierro/web2py-book.git
\end{lstlisting}

\begin{quote}That repository hosts the current, updated version of this book (which could be different from the stable version you can see on the web site). You are warmly invited to use it for submitting
improvements, fixes and corrections in the form of pull requests.\end{quote}
For each application installed you can use the {\it site} page to:
\begin{itemize}
\item Go directly to the application by clicking on its name.

\item Uninstall the application.

\item Jump to the {\it about} page (read below).

\item Jump to the {\it edit} page (read below).

\item Jump to the {\it errors} page (read below).

\item Clean up temporary files (sessions, errors, and cache.disk files).

\item Pack all. This returns a tar file containing a complete copy of the application. We suggest that you clean up temporary files before packing an application.

\item Compile the application. If there are no errors, this option will bytecode-compiles all models, controllers and views. Because views can extend and include other views in a tree, before bytecode compilation, the view tree for every controller is collapsed into a single file. The net effect is that a bytecode-compiled application is faster, because there is no more parsing of templates or string substitutions occurring at runtime.

\item Pack compiled. This option is only present for bytecode-compiled applications. It allows packing the application without source code for distribution as closed source. Note that Python (as any other programming language) can technically be decompiled; therefore compilation does not provide complete protection of the source code. Nevertheless, de-compilation can be difficult and can be illegal.

\item Remove compiled. It simply removes the byte-code compiled models, views and controllers from the application. If the application was packaged with source code or edited locally, there is no harm in removing the bytecode-compiled files, and the application will continue to work. If the application was installed form a packed compiled file, then this is not safe, because there is no source code to revert to, and the application will no longer work.
\end{itemize}

\inxx{admin.py}

\begin{quote}All the functionality available from the web2py admin site page is also accessible programmatically via the API defined in the module {\ft gluon/admin.py}. Simply open a python shell and import this module.\end{quote}
If the Google App Engine SDK is installed the admin {\it site} page shows a button to push your applications to GAE. If {\ft python-git} is installed, there is also a button to push your application to Open Shift. To install applications on {\ft Heroku} or other hosting system you should look into the "scripts" folder for the appropriate script.

\goodbreak\subsection{About}

\inxx{about} \inxx{license}

The {\it about} tab allows editing the description of the application and its license. These are written respectively in the ABOUT and LICENSE files in the application folder.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4300.png}\end{center}


You can use {\ft MARKMIN}, or {\ft gluon.contrib.markdown.WIKI} syntax for these files as described in ref.~\cite{markdown2}.

\goodbreak\subsection{Design}

\inxx{EDIT}
You have used the {\it edit} page already in this chapter. Here we want to point out a few more functionalities of the {\it edit} page.
\begin{itemize}
\item If you click on any file name, you can see the contents of the file with syntax highlighting.

\item If you click on edit, you can edit the file via a web interface.

\item If you click on delete, you can delete the file (permanently).

\item If you click on test, web2py will run tests. Tests are written by the developer using Python doctests, and each function should have its own tests.

\item You can add language files, scan the app to discover all strings, and edit string translations via the web interface.

\item If the static files are organized in folders and subfolders, the folder hierarchy can be toggled by clicking on a folder name.
\end{itemize}

The image below shows the output of the test page for the welcome application.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4400.png}\end{center}


The image below show the languages tab for the welcome application.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4500.png}\end{center}


The image below shows how to edit a language file, in this case the "it" (Italian) language for the welcome application.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4600.png}\end{center}


{\bf Integrated debugger}

{\it (requires Python 2.6 or later)}

The web2py admin includes a web based debugger. Using the provided web-based editor you can add breakpoints to the Python code and, from the associated debugger console, you can inspect the system variables at those breakpoints and resume execution. This is illustrated in the following screenshot:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/debugger.png}\end{center}


This functionality is based on the Qdb debugger created by Mariano Reingart.
It uses multiprocessing.connection to communicate between the backend
and frontend, with a JSON-RPC-like stream protocol.~\cite{qdb}

{\bf Shell}

If you click on the "shell" link under the controllers tab in {\it edit}, web2py will open a web based Python shell and will execute the models for the current application. This allows you to interactively talk to your application.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4700.png}\end{center}


\begin{quote}Be careful using the web based shell - because different shell requests will be executed in different threads. This easily gives errors, especially if you play with databases
creation and connections. For activities like these (i.e. if you need persistence) it's much better to use the python command line.\end{quote}
{\bf Crontab}

Also under the controllers tab in {\it edit} there is a "crontab" link. By clicking on this link you will be able to edit the web2py crontab file. This follows the same syntax as the Unix crontab but does not rely on Unix. In fact, it only requires web2py, and it works on Windows. It allows you to register actions that need to be executed in background at scheduled times.
For more information about this, see the next chapter.

\goodbreak\subsection{Errors}

\inxx{errors}

When programming web2py, you will inevitably make mistakes and introduce bugs. web2py helps in two ways: 1) it allows you to create tests for every function that can be run in the browser from the {\it edit} page; and 2) when an error manifests itself, a ticket is issued to the visitor and the error is logged.

Intentionally introduce an error in the images application as shown below:
\begin{lstlisting}
def index():
    images = db().select(db.image.ALL,orderby=db.image.title)
    1/0
    return dict(images=images)
\end{lstlisting}

When you access the index action, you get the following ticket:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4800.png}\end{center}


Only the administrator can access the ticket:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en4900.png}\end{center}


The ticket shows the traceback, and the content of the file that caused the problem, and the complete state of system (variables, request, session, etc.) If the error occurs in a view, web2py shows the view converted from HTML into Python code. This allows to easily identify the logical structure of the file.

By default tickets are stored on filesystem and displayed grouped by traceback. The administrative interface provides an aggregate views (type of traceback and number of occurrence) and a detailed view (all tickets are listed by ticket id). The administrator can switch between the two views.

Notice that everywhere {\bf admin} shows syntax-highlighted code (for example, in error reports, web2py keywords are shown in orange). If you click on a web2py keyword, you are redirected to a documentation page about the keyword.

If you fix the divide-by-zero bug in the index action and introduce one in the index view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}

<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{1/0}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
\end{lstlisting}
\noindent you get the following ticket:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5000.png}\end{center}


Note that web2py has converted the view from HTML into a Python file, and the error described in the ticket refers to the generated Python code and NOT to the original view file:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5100.png}\end{center}


This may seem confusing at first, but in practice it makes debugging easier, because the Python indentation highlights the logical structure of the code that you embedded in the views.

The code is shown at the bottom of the same page.

All tickets are listed under admin in the {\it errors} page for each application:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5200.png}\end{center}


\goodbreak\subsection{Mercurial}

\inxx{Mercurial}

If you are running from source, the administrative interface shows one more menu item called "Versioning".


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5300.png}\end{center}


Entering a comment and pressing the "commit" button in the resulting page will commit the current application. With the first commit, a local Mercurial repository for the specific
application will be created.
Under the hood, Mercurial stores information about changes you make in your code into a hidden folder ".hg" in your app subfolder. Every app has its own ".hg" folder and its own ".hgignore" file (tells Mercurial which files to ignore).
In order to use this feature, you must have the Mercurial version control libraries installed (at least version 1.9):

\begin{lstlisting}
easy_install mercurial
\end{lstlisting}

The Mercurial web interface does allow you to browse previous commit and diff files but we do recommend you use Mercurial directly from the shell or one of the many GUI-based Mercurial clients since they are more powerful. For example they will allow you sync your app with a remote source repository.

You can read more about Mercurial here:
\begin{lstlisting}[keywords={}]
http://mercurial.selenic.com/
\end{lstlisting}

\goodbreak\subsection{Application Wizard (experimental)}

The {\bf admin} interface includes a Wizard that can help you create a new applications.
You can access the wizard from the "sites" page as shown in the image below.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5400.png}\end{center}


The wizard will guide you through a series of steps involved in creating a new application:

\begin{itemize}
\item Chose a name for the application

\item Configure the application and choose required plugins

\item Build required models (it will create CRUD pages for each model)

\item Allow you to edit the views of those pages using MARKMIN syntax
\end{itemize}

The image below shows the second step of the process.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5500.png}\end{center}


You can see a dropdown to select a layout plugin (from {\ft web2py.com/layouts}), a multiple choice dropdown to check other plugins (from {\ft web2py.com/plugins}) and a "login config" field where to put the Janrain "domain:key".

The other steps are pretty much self-explanatory.

The Wizard works well for what it does but it is considered an {\it experimental feature} for two reasons:

\begin{itemize}
\item Applications created with the wizard and edited manually, cannot later be modified by the wizard.

\item The interface of the wizard will change over time to include support for more features and easier visual development.
\end{itemize}

In any case the wizard is a handy tool for fast prototyping and it can be used to bootstrap a new application with an alternate layout and optional plugins.

\goodbreak\subsection{Configuring {\bf admin}}

Normally there is no need to perform any configuration of admin but a few customizations are possible. After you login into admin you can edit the admin configuration file via the URL:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/admin/default/edit/admin/models/0.py
\end{lstlisting}
Notice that {\bf admin} can be used to edit itself. In fact {\bf admin} is an app as any other one.

The file "0.py" is very much self documented and if you are opening probably you already know what you are looking for. Anyway a few customizations exist that are more important than others:

\begin{lstlisting}
GAE_APPCFG = os.path.abspath(os.path.join('/usr/local/bin/appcfg.py'))
\end{lstlisting}
This should point to the location of the "appcfg.py" file that comes with the Google App Engine SDK. If you have the SDK you may want to change these config parameters to the correct value. It will allow you to deploy to GAE from the admin interface.

\inxx{DEMO\_MODE}

You can also set web2py admin in demo mode:
\begin{lstlisting}
DEMO_MODE = True
FILTER_APPS = ['welcome']
\end{lstlisting}
And only the apps listed in filter apps will be accessible and they will be only accessible in read-only mode.

\inxx{MULTI\_USER\_MODE}
\inxx{virtual laboratory}

If you are a teacher and want to expose the administrative interface to students so that students can share one administrative interface for their projects (think of a virtual lab), can do it by setting:
\begin{lstlisting}
MULTI_USER_MODE = True
\end{lstlisting}
In this way students will be required to login and will only be able to access their own apps via admin. You, as first user/teacher, will be able to access them all.

In multi user mode, you can register students using the "bulk register" link in admin and manage them using the "manage students" link. The system also keeps track of when students login and how many lines of code they add/remove to/from their code. This data is presented to the administrator as charts under the application "about" page.

Mind that this mechanism still assumes all users are trusted. All the apps created under admin run under the same credentials on the same filesystem. It is possible for an app created by a student to access the data and the source of an app created by another student. It is also possible for a student to create an app that locks the server.

\goodbreak\subsection{Mobile {\bf admin}}

Notice that the admin application includes "plugin\_jqmobile" which packages jQuery Mobile. When admin is accessed from a mobile device; this is detected by web2py and the interface is displayed using a mobile-friendly layout.

\goodbreak\section{More on {\bf appadmin}}

\inxx{appadmin}

{\bf appadmin} is not intended to be exposed to the public. It is designed to help you by providing an easy access to the database. It consists of only two files: a controller "appadmin.py" and a view "appadmin.html" which are used by all actions in the controller.

The {\bf appadmin} controller is relatively small and readable; it provides an example of designing a database interface.

{\bf appadmin} shows which databases are available and which tables exist in each database. You can insert records and list all records for each table individually. {\bf appadmin} paginates output 100 records at a time.

Once a set of records is selected, the header of the pages changes, allowing you to update or delete the selected records.

To update the records, enter an SQL assignment in the Query string field:
\begin{lstlisting}
title = 'test'
\end{lstlisting}
\noindent where string values must be enclosed in single quotes. Multiple fields can be separated by commas.

To delete a record, click the corresponding checkbox to confirm that you are sure.

{\bf appadmin} can also perform joins if the SQL FILTER contains a SQL condition that involves two or more tables. For example, try:
\begin{lstlisting}
db.image.id == db.post.image_id
\end{lstlisting}
\noindent web2py passes this along to the DAL, and it understands that the query links two tables; hence, both tables are selected with an INNER JOIN. Here is the output:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5600.png}\end{center}


If you click on the number of an id field, you get an edit page for the record with the corresponding id.

If you click on the number of a reference field, you get an edit page for the referenced record.

You cannot update or delete rows selected by a join, because they involve records from multiple tables and this would be ambiguous.

In addition to its database administration capabilities, {\bf appadmin} also enables you to view details about the contents of the application's {\ft cache} (at {\ft /yourapp/appadmin/cache}) as well as the contents of the current {\ft request}, {\ft response}, and {\ft session} objects (at {\ft /yourapp/appadmin/state}).

\begin{quote}{\bf appadmin} replaces {\ft response.menu} with its own menu, which provides links to the application's {\bf edit} page in {\bf admin}, the {\bf db} (database administration) page, the {\bf state} page, and the {\bf cache} page. If your application's layout does not generate a menu using {\ft response.menu}, then you will not see the {\bf appadmin} menu. In that case, you can modify the appadmin.html file and add {\ft \{\{=MENU(response.menu)\}\}} to display the menu.\end{quote}
\goodbreak\chapter{The core}

\goodbreak\section{Command line options}

It is possible to skip the GUI and start web2py directly from the command line by typing something like:
\inxx{password}

\begin{lstlisting}
python web2py.py -a 'your password' -i 127.0.0.1 -p 8000
\end{lstlisting}

When web2py starts, it creates a file called "parameters\_8000.py" where it stores the hashed password. If you use "<ask>" as the password, web2py prompts you for it.

For additional security, you can start web2py with:
\begin{lstlisting}
python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000
\end{lstlisting}

In this case web2py reuses the previously stored hashed password. If no password is provided, or if the "parameters\_8000.py" file is deleted, the web-based administrative interface is disabled.

\inxx{PAM}
On some Unix/Linux systems, if the password is
\begin{lstlisting}[keywords={}]
<pam_user:some_user>
\end{lstlisting}
\noindent web2py uses the PAM password of the Operating System account of {\ft some\_user} to authenticate the administrator, unless blocked by the PAM configuration.

\begin{quote}web2py normally runs with CPython (the C implementation of the Python interpreter created by Guido van Rossum), but it can also run with PyPy and Jython. The latter possibility allows the use of web2py in the context of a J2EE infrastructure. To use Jython, simply replace "python web2py.py..." with "jython web2py.py". Details about installing Jython, zxJDBC modules required to access the databases can be found in Chapter 14.\end{quote}
The "web2py.py" script can take many command-line arguments specifying the maximum number of threads, enabling of SSL, etc. For a complete list type:

\inxx{command line}
\begin{lstlisting}
>>> python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        IP address of the server (e.g., 127.0.0.1 or ::1);
                        Note: This value is ignored when using the
                        'interfaces' option.
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration (use -a
                        "<recycle>" to reuse the last password))
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  --ca-cert=SSL_CA_CERTIFICATE
                        Use this file containing the CA certificate to
                        validate X509 certificates from clients
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads (deprecated)
  --minthreads=MINTHREADS
                        minimum number of server threads
  --maxthreads=MAXTHREADS
                        maximum number of server threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  --socket-timeout=SOCKET_TIMEOUT
                        timeout for socket (5 second)
  -f FOLDER, --folder=FOLDER
                        folder from which to run web2py
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all, 100 means
                        none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython (if
                        installed) with specified appname (if app does not
                        exist it will be created). APPNAME like a/c/f (c,f
                        optional)
  -B, --bpython         run web2py in interactive shell or bpython (if
                        installed) with specified appname (if app does not
                        exist it will be created). Use combined with --shell
  -P, --plain           only use plain python shell; should be used with
                        --shell option
  -M, --import_models   auto import model files; default is False; should be
                        used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment; should be used
                        with --shell option
  -K SCHEDULER, --scheduler=SCHEDULER
                        run scheduled tasks for the specified apps: expects a
                        list of app names as -K app1,app2,app3 or a list of
                        app:groups as -K app1:group1:group2,app2:group1 to
                        override specific group_names. (only strings, no
                        spaces allowed. Requires a scheduler defined in the
                        models
  -X, --with-scheduler  run schedulers alongside webserver
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment; TEST_PATH like
                        a/c/f (c,f optional)
  -W WINSERVICE, --winservice=WINSERVICE
                        -W install|start|stop as Windows service
  -C, --cron            trigger a cron run manually; usually invoked from a
                        system crontab
  --softcron            triggers the use of softcron
  -Y, --run-cron        start the background cron process
  -J, --cronjob         identify cron-initiated command
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_FILENAME, --profiler=PROFILER_FILENAME
                        profiler filename
  -t, --taskbar         use web2py gui and run in taskbar (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --no-banner           Do not print header banner
  --interfaces=INTERFACES
                        listen on multiple addresses: "ip1:port1:key1:cert1:ca
                        _cert1;ip2:port2:key2:cert2:ca_cert2;..."
                        (:key:cert:ca_cert optional; no spaces; IPv6 addresses
                        must be in square [] brackets)
  --run_system_tests    runs web2py tests
\end{lstlisting}

Lower-case options are used to configure the web server. The {\ft -L} option tells web2py to read configuration options from a file, {\ft -W} installs web2py as a windows service, while {\ft -S}, {\ft -P} and {\ft -M} options start an interactive Python shell. The {\ft -T} option finds and runs controller doctests in a web2py execution environment. For example, the following example runs doctests from all controllers in the "welcome" application:
\begin{lstlisting}
python web2py.py -vT welcome
\end{lstlisting}
\noindent if you run web2py as Windows Service, {\ft -W},  it is not convenient to pass the configuration using command line arguments. For this reason, in the web2py folder there is a sample "options\_std.py" configuration file for the internal web server:

\begin{lstlisting}
import socket
import os

ip = '0.0.0.0'
port = 80
interfaces = [('0.0.0.0', 80)]
               #,('0.0.0.0',443,'ssl_private_key.pem','ssl_certificate.pem')]
password = '<recycle>'  # ## <recycle> means use the previous password
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
profiler_filename = None
ssl_certificate = None  # 'ssl_certificate.pem'  # ## path to certificate file
ssl_private_key = None  # 'ssl_private_key.pem'  # ## path to private key file
#numthreads = 50 # ## deprecated; remove
minthreads = None
maxthreads = None
server_name = socket.gethostname()
request_queue_size = 5
timeout = 30
shutdown_timeout = 5
folder = os.getcwd()
extcron = None
nocron = None
\end{lstlisting}

This file contains the web2py defaults. If you edit this file, you need to import it explicitly with the {\ft -L} command-line option. It only works if you run web2py as a Windows Service.

\goodbreak\section{Workflow}

The web2py workflow is the following:
\begin{itemize}
\item An HTTP requests arrives to the web server (the built-in Rocket server or a different server connected to web2py via WSGI or another adapter). The web server handles each request in its own thread, in parallel.

\item The HTTP request header is parsed and passed to the dispatcher (explained later in this chapter).

\item The dispatcher decides which of the installed application will handle the request and maps the PATH\_INFO in the URL into a function call. Each URL corresponds to one function call.

\item Requests for files in the static folder are handled directly, and large files are automatically streamed to the client.

\item Requests for anything but a static file are mapped into an action (i.e. a function in a controller file, in the requested application).

\item Before calling the action, a few things happen: if the request header contains a session cookie for the app, the session object is retrieved; if not, a session id is created (but the session file is not saved until later); an execution environment for the request is created; models are executed in this environment.

\item Finally the controller action is executed in the pre-built environment.

\item If the action returns a string, this is returned to the client (or if the action returns a web2py HTML helper object, it is serialized and returned to the client).

\item If the action returns an iterable, this is used to loop and stream the data to the client.

\item If the action returns a dictionary, web2py tries to locate a view to render the dictionary. The view must have the same name as the action (unless specified otherwise) and the same extension as the requested page (defaults to.html); on failure, web2py may pick up a generic view (if available and if enabled). The view sees every variable defined in the models as well as those in the dictionary returned by the action, but does not see global variables defined in the controller.

\item The entire user code is executed in a single database transaction unless specified otherwise.

\item If the user code succeeds, the transaction is committed.

\item If the user code fails, the traceback is stored in a ticket, and a ticket ID is issued to the client. Only the system administrator can search and read the tracebacks in tickets.
\end{itemize}

There are some caveats to keep in mind:
\begin{itemize}
\item Models in the same folder/subfolder are executed in alphabetical order.

\item Any variable defined in a model will be visible to other models following alphabetically, to the controllers, and to the views.

\item Models in subfolders are executed conditionally. For example, if the user has requested "/a/c/f" where "a" is the application, "c" is the controller, and "f" is the function (action), then the following models are executed:
\end{itemize}

\begin{lstlisting}
applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py
\end{lstlisting}

\begin{itemize}
\item The requested controller is executed and the requested function is called. This means all top-level code in the controller is also executed at every request for that controller.

\item The view is only called if the action returns a dictionary.

\item If a view is not found, web2py tries to use a generic view. By default, generic views are disabled, although the 'welcome' app includes a line in /models/db.py to enable them on localhost only. They can be enabled per extension type and per action (using {\ft response.generic\_patterns}). In general, generic views are a development tool and typically should not be used in production. If you want some actions to use a generic view, list those actions in {\ft response.generic\_patterns} (discussed in more detail in the chapter on Services).
\end{itemize}

The possible behaviors of an action are the following:

{\bf Return a string}
\begin{lstlisting}
def index(): return 'data'
\end{lstlisting}

{\bf Return a dictionary for a view}:
\begin{lstlisting}
def index(): return dict(key='value')
\end{lstlisting}

{\bf Return all local variables}:
\begin{lstlisting}
def index(): return locals()
\end{lstlisting}

{\bf Redirect the user to another page}:
\begin{lstlisting}
def index(): redirect(URL('other_action'))
\end{lstlisting}

{\bf Return an HTTP page other than "200 OK"}:
\begin{lstlisting}
def index(): raise HTTP(404)
\end{lstlisting}

{\bf Return a helper} (for example, a FORM):
\begin{lstlisting}
def index(): return FORM(INPUT(_name='test'))
\end{lstlisting}
(this is mostly used for Ajax callbacks and components, see chapter 12)

When an action returns a dictionary, it may contain code generated by helpers, including forms based on database tables or forms from a factory, for example:

\begin{lstlisting}
def index(): return dict(form=SQLFORM.factory(Field('name')).process())
\end{lstlisting}
(all forms generated by web2py use postbacks, see chapter 3)

\goodbreak\section{Dispatching}

\inxx{url mapping} \inxx{dispatching}
\noindent web2py maps a URL of the form:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/a/c/f.html
\end{lstlisting}
\noindent to the function {\ft f()} in controller "c.py" in application "a". If {\ft f} is not present, web2py defaults to the {\ft index} controller function. If {\ft c} is not present, web2py defaults to the "default.py" controller, and if {\ft a} is not present, web2py defaults to the {\ft init} application. If there is no {\ft init} application, web2py tries to run the {\ft welcome} application. This is shown schematically in the image below:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5700.png}\end{center}


By default, any new request also creates a new session. In addition, a session cookie is returned to the client browser to keep track of the session.

The extension {\ft .html} is optional; {\ft .html} is assumed as default. The extension determines the extension of the view that renders the output of the controller function {\ft f()}. It allows the same content to be served in multiple formats (html, xml, json, rss, etc.).

\begin{quote}Functions that take arguments or start with a double underscore are not publicly exposed and can only be called by other functions.\end{quote}
\inxx{static files}
There is an exception made for URLs of the form:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/a/static/filename
\end{lstlisting}

There is no controller called "static". web2py interprets this as a request for the file called "filename" in the subfolder "static" of the application "a".

\inxx{PARTIAL CONTENT} \inxx{IF\_MODIFIED\_SINCE}
When static files are downloaded, web2py does not create a session, nor does it issue a cookie or execute the models. web2py always streams static files in chunks of 1MB, and sends PARTIAL CONTENT when the client sends a RANGE request for a subset of the file.
\noindent web2py also supports the IF\_MODIFIED\_SINCE protocol, and does not send the file if it is already stored in the browser's cache and if the file has not changed since that version.

When linking to an audio or video file in the static folder, if you want to force the browser to download the file instead of streaming the audio/video via a media player, add {\ft ?attachment} to the URL. This tells web2py to set the {\ft Content-Disposition} header of the HTTP response to "attachment". For example:

\begin{lstlisting}[keywords={}]
<a href="/app/static/my_audio_file.mp3?attachment">Download</a>
\end{lstlisting}

When the above link is clicked, the browser will prompt the user to download the MP3 file rather than immediately streaming the audio. (As discussed {\footnotesize\href{\#response}{below}}, you can also set HTTP response headers directly by assigning a {\ft dict} of header names and their values to {\ft response.headers}.)

\inxx{request.application} \inxx{request.controller} \inxx{request.function} \inxx{GET} \inxx{POST} \inxx{request.args}
web2py maps GET/POST requests of the form:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&q=2
\end{lstlisting}
\noindent to function {\ft f} in controller "c.py" in application {\ft a}, and it stores the URL parameters in the {\ft request} variable as follows:
\begin{lstlisting}
request.args = ['x', 'y', 'z']
\end{lstlisting}
\noindent and:
\begin{lstlisting}
request.vars = {'p':1, 'q':2}
\end{lstlisting}
\noindent and:
\begin{lstlisting}
request.application = 'a'
request.controller = 'c'
request.function = 'f'
\end{lstlisting}

In the above example, both {\ft request.args[i]} and {\ft request.args(i)} can be used to retrieve the i-th element of the {\ft request.args}, but while the former raises an exception if the list does not have such an index, the latter returns None in this case.

\inxx{request.url}
\begin{lstlisting}
request.url
\end{lstlisting}
\noindent stores the full URL of the current request (not including GET variables).

\inxx{request.ajax} \inxx{request.cid}

\begin{lstlisting}
request.ajax
\end{lstlisting}
\noindent defaults False but it is True if web2py determines that the action was called by an Ajax request.

If the request is an Ajax request and it is initiated by a web2py component, the name of the component can be found in:

\begin{lstlisting}
request.cid
\end{lstlisting}

Components are discussed in more detail in Chapter 12.

\inxx{request.get\_vars} \inxx{request.post\_vars} \inxx{request.vars}
If the HTTP request is a GET, then {\ft request.env.request\_method} is set to "GET"; if it is a POST, {\ft request.env.request\_method} is set to "POST". URL query variables are stored in the {\ft request.vars} Storage dictionary; they are also stored in {\ft request.get\_vars} (following a GET request) or {\ft request.post\_vars} (following a POST request).
\noindent web2py stores WSGI and web2py environment variables in {\ft request.env}, for example:
\begin{lstlisting}
request.env.path_info = 'a/c/f'
\end{lstlisting}
\noindent and HTTP headers into environment variables, for example:
\begin{lstlisting}
request.env.http_host = '127.0.0.1:8000'
\end{lstlisting}

\begin{quote}Notice that web2py validates all URLs to prevent directory traversal attacks.\end{quote}
URLs are only allowed to contain alphanumeric characters, underscores, and slashes; the {\ft args} may contain non-consecutive dots. Spaces are replaced by underscores before validation. If the URL syntax is invalid, web2py returns an HTTP 400 error message~\cite{http-w}~\cite{http-o}.

If the URL corresponds to a request for a static file, web2py simply reads and returns (streams) the requested file.

If the URL does not request a static file, web2py processes the request in the following order:
\begin{itemize}
\item Parses cookies.

\item Creates an environment in which to execute the function.

\item Initializes {\ft request}, {\ft response}, {\ft cache}.

\item Opens the existing {\ft session} or creates a new one.

\item Executes the models belonging to the requested application.

\item Executes the requested controller action function.

\item If the function returns a dictionary, executes the associated view.

\item On success, commits all open transactions.

\item Saves the session.

\item Returns an HTTP response.
\end{itemize}

Notice that the controller and the view are executed in different copies of the same environment; therefore, the view does not see the controller, but it sees the models and it sees the variables returned by the controller action function.

If an exception (other than HTTP) is raised, web2py does the following:
\begin{itemize}
\item Stores the traceback in an error file and assigns a ticket number to it.

\item Rolls back all open database transactions.

\item Returns an error page reporting the ticket number.
\end{itemize}

If the exception is an {\ft HTTP} exception, this is assumed to be the intended behavior (for example, an {\ft HTTP} redirect), and all open database transactions are committed. The behavior after that is specified by the {\ft HTTP} exception itself. The {\ft HTTP} exception class is not a standard Python exception; it is defined by web2py.

\goodbreak\section{Libraries}

The web2py libraries are exposed to the user applications as global objects. For example ({\ft request}, {\ft response}, {\ft session}, {\ft cache}), classes (helpers,  validators, DAL API), and functions ({\ft T} and {\ft redirect}).

These objects are defined in the following core files:
\begin{lstlisting}
web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py
\end{lstlisting}

\begin{quote}Notice that many of these modules, specifically {\ft dal} (the Database Abstraction Layer), {\ft template} (the template language), {\ft rocket} (the web server), and
{\ft html} (the helpers) have no dependencies and can be used outside of web2py.\end{quote}
The tar gzipped scaffolding app that ship with web2py is
\begin{lstlisting}
welcome.w2p
\end{lstlisting}

This is created upon installation and overwritten on upgrade.

\begin{quote}The first time you start web2py, two new folders are created: deposit and applications. The deposit folder is used as temporary storage for installing and uninstalling applications.

Also, the first time you start web2py and after an upgrade, the "welcome" app is zipped into a "welcome.w2p" file to be used as a scaffolding app.\end{quote}
When web2py is upgraded it comes with a file called "NEWINSTALL". If web2py finds this file, it understands an upgrade was performed, hence it removed the file and creates a new "welcome.w2p".

The current web2py version is stored in the field "VERSION" and it follows standard semantic versioning notation where the build id is the build timestamp.
\noindent web2py unit-tests are in
\begin{lstlisting}
gluon/tests/
\end{lstlisting}

There are handlers for connecting with various web servers:
\begin{lstlisting}
cgihandler.py       # discouraged
gaehandler.py       # for Google App Engine
fcgihandler.py      # for FastCGI
wsgihandler.py      # for WSGI
isapiwsgihandler.py # for IIS
modpythonhandler.py # deprecated
\end{lstlisting}

("fcgihandler" calls  "gluon/contrib/gateways/fcgi.py" developed by Allan Saddi) and

\begin{lstlisting}
anyserver.py
\end{lstlisting}
\noindent which is a script to interface with many different web servers, described in Chapter 13.

There are three example files:
\begin{lstlisting}
options_std.py
routes.example.py
router.example.py
\end{lstlisting}

The former is an optional configuration file that can be passed to web2py.py with the {\ft -L} option. The second is an example of a URL mapping file. It is loaded automatically when renamed "routes.py". The third is an alternative syntax for URL mapping, and can also be renamed (or copied to) "routes.py".

The files
\begin{lstlisting}
app.example.yaml
queue.example.yaml
\end{lstlisting}
\noindent are example configuration files used for deployment on the Google App Engine. You can read more about them in the Deployment Recipes chapter and on the Google Documentation pages.

There are also additional libraries, some developed by a third party:

{\bf feedparser}~\cite{feedparser}  by Mark Pilgrim for reading RSS and Atom feeds:
\begin{lstlisting}
gluon/contrib/__init__.py
gluon/contrib/feedparser.py
\end{lstlisting}

{\bf markdown2}~\cite{markdown2}  by Trent Mick for wiki markup:
\begin{lstlisting}
gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py
\end{lstlisting}

{\bf markmin} markup:
\begin{lstlisting}
gluon/contrib/markmin
\end{lstlisting}

{\bf fpdf} created my Mariano Reingart for generating PDF documents:
\begin{lstlisting}
gluon/contrib/fpdf
\end{lstlisting}
This is not documented in this book but it is hosted and documented here:
\begin{lstlisting}[keywords={}]
http://code.google.com/p/pyfpdf/
\end{lstlisting}

{\bf pysimplesoap} is a lightweight SOAP server implementation created by Mariano Reingart:

\begin{lstlisting}
gluon/contrib/pysimplesoap/
\end{lstlisting}

{\bf simplejsonrpc} is a lightweight JSON-RPC client also created by Mariano Reingart: \inxx{jsonrpc}

\begin{lstlisting}
gluon/contrib/simplejsonrpc.py
\end{lstlisting}

{\bf memcache}~\cite{memcache}  Python API by Evan Martin:
\begin{lstlisting}
gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py
\end{lstlisting}

{\bf redis\_cache} \inxx{redis} is a module to store cache in the redis database:
\begin{lstlisting}
gluon/contrib/redis_cache.py
\end{lstlisting}

{\bf gql}, a port of the DAL to the Google App Engine:
\begin{lstlisting}
gluon/contrib/gql.py
\end{lstlisting}

{\bf memdb}, a port of the DAL on top of memcache:
\begin{lstlisting}
gluon/contrib/memdb.py
\end{lstlisting}

{\bf gae\_memcache} is an API to use memcache on the Google App Engine:
\begin{lstlisting}
gluon/contrib/gae_memcache.py
\end{lstlisting}

{\bf pyrtf}~\cite{pyrtf}  for generating Rich Text Format (RTF) documents, developed by Simon Cusack and revised by Grant Edwards:
\begin{lstlisting}
gluon/contrib/pyrtf/
\end{lstlisting}

{\bf PyRSS2Gen}~\cite{pyrss2gen}  developed by Dalke Scientific Software, to generate RSS feeds:
\begin{lstlisting}
gluon/contrib/rss2.py
\end{lstlisting}

{\bf simplejson}~\cite{simplejson}  by Bob Ippolito, the standard library for parsing and writing JSON objects:
\begin{lstlisting}
gluon/contrib/simplejson/
\end{lstlisting}

{\bf Google Wallet}~\cite{googlewallet}
provides "pay now" buttons which link Google as payment processor:
\begin{lstlisting}
gluon/contrib/google_wallet.py
\end{lstlisting}

{\bf Stripe.com}~\cite{stripe} provides a simple API for accepting credit card payments:
\begin{lstlisting}
gluon/contrib/stripe.py
\end{lstlisting}

{\bf AuthorizeNet}~\cite{authorizenet}  provides API to accept credit card payments via Authorize.net network
\begin{lstlisting}
gluon/contrib/AuthorizeNet.py
\end{lstlisting}

{\bf Dowcommerce}~\cite{dowcommerce} credit card processing API:
\begin{lstlisting}
gluon/contrib/DowCommerce.py
\end{lstlisting}

{\bf PaymentTech} credit card processing API:

\begin{lstlisting}
gluon/contrib/paymentech.py
\end{lstlisting}

{\bf PAM}~\cite{PAM}  authentication API created by Chris AtLee:
\begin{lstlisting}
gluon/contrib/pam.py
\end{lstlisting}

A Bayesian classifier to populate the database with dummy data for testing purposes:
\begin{lstlisting}
gluon/contrib/populate.py
\end{lstlisting}

A file with API for running on Heroku.com : \inxx{heroku}

\begin{lstlisting}
gluon/contrib/heroku.py
\end{lstlisting}

A file that allows interaction with the taskbar in windows, when web2py is running as a service:
\begin{lstlisting}
gluon/contrib/taskbar_widget.py
\end{lstlisting}

Optional {\bf login\_methods} and login\_forms to be used for authentication:
\begin{lstlisting}
gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/browserid_account.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/oneall_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py
\end{lstlisting}
\noindent web2py also contains a folder with useful scripts including
\begin{lstlisting}
scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/setup-web2py-heroku.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py
\end{lstlisting}

The first three are particularly useful because they attempt a complete installation and setup of a web2py production environment from scratch.
Some of these are discussed in Chapter 14, but all of them contain a documentation string inside that explains their purpose and usage.

Finally web2py includes these files required to build the binary distributions.
\begin{lstlisting}
Makefile
setup_exe.py
setup_app.py
\end{lstlisting}

These are setup scripts for {\bf py2exe} and {\bf py2app}, respectively, and they are only required to build the binary distributions of web2py. YOU SHOULD NEVER NEED TO RUN THEM.
\noindent web2py applications contain additional files, particularly third-party JavaScript libraries, such as jQuery, calendar, and Codemirror. Their authors are acknowledged in the files themselves.

\goodbreak\section{Applications}

Applications developed in web2py are composed of the following parts:
\begin{itemize}
\item {\bf models} describe a representation of the data as database tables and relations between tables.

\item {\bf controllers} describe the application logic and workflow.

\item {\bf views} describe how data should be presented to the user using HTML and JavaScript.

\item {\bf languages} describe how to translate strings in the application into various supported languages.

\item {\bf static files} do not require processing (e.g. images, CSS stylesheets, etc).

\item {\bf ABOUT} and {\bf README} documents are self-explanatory.

\item {\bf errors} store error reports generated by the application.

\item {\bf sessions} store information related to each particular user.

\item {\bf databases} store SQLite databases and additional table information.

\item {\bf cache} store cached application items.

\item {\bf modules} are other optional Python modules.

\item {\bf private} files are accessed by the controllers but not directly by the developer.

\item {\bf uploads} files are accessed by the models but not directly by the developer (e.g., files uploaded by users of the application).

\item {\bf tests} is a directory for storing test scripts, fixtures and mocks.
\end{itemize}

Models, views, controllers, languages, and static files are accessible via the web administration [design] interface. ABOUT, README, and errors are also accessible via the administration interface through the corresponding menu items. Sessions, cache, modules and private files are accessible to the applications but not via the administration interface.

Everything is neatly organized in a clear directory structure that is replicated for every installed web2py application, although the user never needs to access the filesystem directly:

\inxx{about} \inxx{license} \inxx{cache} \inxx{controllers} \inxx{databases} \inxx{errors} \inxx{languages} \inxx{models} \inxx{modules} \inxx{private} \inxx{session} \inxx{static} \inxx{tests} \inxx{uploads} \inxx{views} \inxx{\_\_init\_\_.py}
\begin{lstlisting}
__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static
\end{lstlisting}

"\_\_init\_\_.py" is an empty file which is required in order to allow Python (and web2py) to import the modules in the {\ft modules} directory.

Notice that the {\bf admin} application simply provides a web interface to web2py applications on the server file system. web2py applications can also be created and developed from the command-line or your preferred text editor/IDE; you don't have to use the browser {\bf admin} interface.  A new application can be created manually by replicating the above directory structure under,e.g., "applications/newapp/" (or simply untar the {\ft welcome.w2p} file into your new application directory). Application files can also be created and edited from the command-line without having to use the web {\bf admin} interface.

\goodbreak\section{API}

Models, controllers, and views are executed in an environment where the following objects are already imported for us:

{\bf Global Objects:} \inxx{request} \inxx{response} \inxx{session} \inxx{cache}

\begin{lstlisting}
request, response, session, cache
\end{lstlisting}

{\bf Internationalization:} \inxx{T} \inxx{internationalization}

\begin{lstlisting}
T
\end{lstlisting}

{\bf Navigation:} \inxx{redirect} \inxx{HTTP}

\begin{lstlisting}
redirect, HTTP
\end{lstlisting}

{\bf Helpers:} \inxx{helpers}

\begin{lstlisting}
XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON
\end{lstlisting}

{\bf Forms and tables}

\begin{lstlisting}
SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)
\end{lstlisting}

{\bf Validators:} \inxx{validators}

\begin{lstlisting}
CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL
\end{lstlisting}

{\bf Database:} \inxx{DAL}

\begin{lstlisting}
DAL, Field
\end{lstlisting}

For backward compatibility {\ft SQLDB=DAL} and {\ft SQLField=Field}. We encourage you to use the new syntax {\ft DAL} and {\ft Field}, instead of the old syntax.

Other objects and modules are defined in the libraries, but they are not automatically imported since they are not used as often.

The core API entities in the web2py execution environment are {\ft request}, {\ft response}, {\ft session}, {\ft cache}, {\ft URL}, {\ft HTTP}, {\ft redirect} and {\ft T} and are discussed below.

A few objects and functions, including {\bf Auth}, {\bf Crud} and {\bf Service}, are defined in "gluon/tools.py" and they need to be imported as necessary:
\begin{lstlisting}
from gluon.tools import Auth, Crud, Service
\end{lstlisting}

\goodbreak\subsection{Accessing the API from Python modules}

Your models or controller may import python modules, and these may need to use some of the web2py API. The way to do it is by importing them:

\begin{lstlisting}
from gluon import *
\end{lstlisting}

In fact, any Python module, even if not imported by a web2py application, can import the web2py API as long as web2py is in the {\ft sys.path}.

There is one caveat, though. Web2py defines some global objects (request, response, session, cache, T) that can only exist when an HTTP request is present (or is faked). Therefore, modules can access them only if they are called from an application. For this reasons they are placed into a container caller {\ft current}, which is a thread local object. Here is an example.

Create a module "/myapp/modules/test.py" that contains:
\begin{lstlisting}
from gluon import *
def ip(): return current.request.client
\end{lstlisting}
Now from a controller in "myapp" you can do
\begin{lstlisting}
import test
def index():
    return "Your ip is " + test.ip()
\end{lstlisting}

Notice a few things:

\begin{itemize}
\item {\ft import test} looks for the module first in the current app's modules folder, then in the folders listed in {\ft sys.path}. Therefore, app-level modules always take precedence over Python modules. This allows different apps to ship with different versions of their modules, without conflicts.

\item Different users can call the same action {\ft index} concurrently, which calls the function in the module, and yet there is no conflict because {\ft current.request} is a different object in different threads. Just be careful not to access {\ft current.request} outside of functions or classes (i.e., at the top level) in the module.

\item {\ft import test} is a shortcut for {\ft from applications.appname.modules import test}. Using the longer syntax, it is possible to import modules from other applications.
\end{itemize}

For uniformity with normal Python behavior, by default web2py does not reload modules when changes are made. Yet this can be changed. To turn on the auto-reload feature for modules, use the {\ft track\_changes} function as follows (typically in a model file, before any imports):

\begin{lstlisting}
from gluon.custom_import import track_changes; track_changes(True)
\end{lstlisting}

From now on, every time a module is imported, the importer will check if the Python source file (.py) has changed. If it has changed, the module will be reloaded. This applies to all Python modules, even Python modules outside web2py. The mode is global and applies to all applications. Changes made to models, controllers, and views are always reloaded regardless of the mode used. To turn the mode off, use the same function with {\ft False} as the argument. To know the actual tracking state, use the {\ft is\_tracking\_changes()} function, also from {\ft gluon.custom\_import}.

Modules that import {\ft current} can access:
\begin{itemize}
\item {\ft current.request}

\item {\ft current.response}

\item {\ft current.session}

\item {\ft current.cache}

\item {\ft current.T}
\end{itemize}
and any other variable your application chooses to store in current. For example a model could do

\begin{lstlisting}
auth = Auth(db)
from gluon import current
current.auth = auth
\end{lstlisting}
\noindent and now all modules imported can access

\begin{itemize}
\item {\ft current.auth}
\end{itemize}

{\ft current} and {\ft import} create a powerful mechanism to build extensible and reusable modules for your applications.

\begin{quote}There is one major caveat. Given {\ft from gluon import current}, it is correct to use {\ft current.request} and any of the other thread local objects but one should never assign them to global variables in the module, such as in
\begin{lstlisting}
request = current.request # WRONG! DANGER!
\end{lstlisting}
nor one should use it assign class attributes
\begin{lstlisting}
class MyClass:
    request = current.request # WRONG! DANGER!
\end{lstlisting}
This is because the thread local object must be extracted at runtime. Global variables instead are defined only once when the model is imported for the first time.\end{quote}
Another caveat has to do with cache. You cannot use the {\ft cache} object to decorate functions in modules, that is because it would not behave as expected. In order to cache a function {\ft f} in a module you must use {\ft lazy\_cache}:

\begin{lstlisting}
from gluon.cache import lazy_cache

lazy_cache('key', time_expire=60, cache_model='ram')
def f(a,b,c,): ....
\end{lstlisting}

Mind that the key is user defined but must be uniquely associated to the function. If omitted web2py will automatically determine a key.

\goodbreak\section{{\ft request}}

\inxx{request} \inxx{Storage} \inxx{request.cookies} \inxx{user\_agent}

The {\ft request} object is an instance of the ubiquitous web2py class that is called {\ft gluon.storage.Storage}, which extends the Python {\ft dict} class. It is basically a dictionary, but the item values can also be accessed as attributes:
\begin{lstlisting}
request.vars
\end{lstlisting}
\noindent is the same as:
\begin{lstlisting}
request['vars']
\end{lstlisting}

Unlike a dictionary, if an attribute (or key) does not exist, it does not raise an exception. Instead, it returns {\ft None}.

\begin{quote}It is sometimes useful to create your own Storage objects. You can do so as follows:
\begin{lstlisting}
from gluon.storage import Storage
my_storage = Storage() # empty storage object
my_other_storage = Storage(dict(a=1, b=2)) # convert dictionary to Storage
\end{lstlisting}\end{quote}
{\ft request} has the following items/attributes, some of which are also an instance of the {\ft Storage} class:
\begin{itemize}
\item {\ft request.cookies}: a {\ft Cookie.SimpleCookie()} object containing the cookies passed with the HTTP request. It acts like a dictionary of cookies. Each cookie is a Morsel object (see http://docs.python.org/2/library/cookie.html\#id2).

\item {\ft request.env}: a {\ft Storage} object containing the environment variables passed to the controller, including HTTP header variables from the HTTP request and standard WSGI parameters. The environment variables are all converted to lower case, and dots are converted to underscores for easier memorization.

\item {\ft request.application}: the name of the requested application (parsed from {\ft request.env.path\_info}).

\item {\ft request.controller}: the name of the requested controller (parsed from the {\ft request.env.path\_info}).

\item {\ft request.function}: the name of the requested function (parsed from the {\ft request.env.path\_info}).

\item {\ft request.extension}: the extension of the requested action. It defaults to "html". If the controller function returns a dictionary and does not specify a view, this is used to determine the extension of the view file that will render the dictionary (parsed from the {\ft request.env.path\_info}).

\item {\ft request.folder}: the application directory. For example if the application is "welcome", {\ft request.folder} is set to the absolute path "/path/to/welcome". In your programs, you should always use this variable and the {\ft os.path.join} function to build paths to the files you need to access. Although web2py always uses absolute paths, it is a good rule never to explicitly  change the current working folder (whatever that is) since this is not a thread-safe practice.

\item {\ft request.now}: a {\ft datetime.datetime} object storing the datetime of the current request.

\item {\ft request.utcnow}: a {\ft datetime.datetime} object storing the UTC datetime of the current request.

\item {\ft request.args}: A list of the URL path components following the controller function name; equivalent to {\ft request.env.path\_info.split('/')[3:]}

\item {\ft request.vars}: a {\ft gluon.storage.Storage} object containing both the HTTP GET and HTTP POST query variables.

\item {\ft request.get\_vars}: a {\ft gluon.storage.Storage} object containing only the HTTP GET query variables.

\item {\ft request.post\_vars}: a {\ft gluon.storage.Storage} object containing only the HTTP POST query variables.

\item {\ft request.client}: The ip address of the client as determined by, if present, {\ft request.env.http\_x\_forwarded\_for} or by {\ft request.env.remote\_addr} otherwise. While this is useful it should not be trusted because the {\ft http\_x\_forwarded\_for} can be spoofed.

\item {\ft request.is\_local}: {\ft True} if the client is localhost, {\ft False} otherwise. Should work behind a proxy if the proxy supports {\ft http\_x\_forwarded\_for}.

\item {\ft request.is\_https}: {\ft True} if the request is using the HTTPS protocol, {\ft False} otherwise.

\item {\ft request.body}: a read-only file stream that contains the body of the HTTP request. This is automatically parsed to get the {\ft request.post\_vars} and then rewinded. It can be read with {\ft request.body.read()}.

\item {\ft request.ajax} is True if the function is being called via an Ajax request.

\item {\ft request.cid} is the {\ft id} of the component that generated the Ajax request (if any). You can read more about components in Chapter 12.

\item {\ft request.requires\_https()} prevents further code execution if the request is not over HTTPS and redirects the visitor to the current page over HTTPS.

\item {\ft request.restful} this is a new and very useful decorator that can be used to change the default behavior of web2py actions by separating GET/POST/PUSH/DELETE requests. It will be discussed in some detail in Chapter 10.

\item {\ft request.user\_agent()} parses the user\_agent field from the client and returns the information in the form of a dictionary. It is useful to detect mobile devices. It uses "gluon/contrib/user\_agent\_parser.py" created by Ross Peoples. To see what it does, try to embed the following code in a view:
\end{itemize}
\begin{lstlisting}[keywords={}]
{{=BEAUTIFY(request.user_agent())}}
\end{lstlisting}

\begin{itemize}
\item {\ft request.global\_settings} \inxx{request.global\_settings} contains web2py system wide settings. They are set automatically and you should not change them. For example {\ft request.global\_settings.gluon\_parent} contains the full path to the web2py folder, {\ft request.global\_settings.is\_pypy} determines if web2py is running on PyPy.

\item {\ft request.wsgi} is a hook that allows you to call third party WSGI applications from inside actions
\end{itemize}

The latter includes:
\begin{itemize}
\item {\ft request.wsgi.environ}

\item {\ft request.wsgi.start\_response}

\item {\ft request.wsgi.middleware}
\end{itemize}
their usage is discussed at the end of this Chapter.

As an example, the following call on a typical system:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&q=2
\end{lstlisting}
\noindent results in the following {\ft request} object:
\inxx{request} \inxx{env}

\newpage
\goodbreak\begin{center}
{\begin{tabular}{ll}\hline
{\bf variable} & {\bf value}\\ \hline
{\ft request.application} & {\ft examples}\\
{\ft request.controller} & {\ft default}\\
{\ft request.function} & {\ft index}\\
{\ft request.extension} & {\ft html}\\
{\ft request.view} & {\ft status}\\
{\ft request.folder} & {\ft applications/examples/}\\
{\ft request.args} & {\ft ['x', 'y', 'z']}\\
{\ft request.vars} & {\ft <Storage \{'p': 1, 'q': 2\}>}\\
{\ft request.get\_vars} & {\ft <Storage \{'p': 1, 'q': 2\}>}\\
{\ft request.post\_vars} & {\ft <Storage \{\}>}\\
{\ft request.is\_local} & {\ft False}\\
{\ft request.is\_https} & {\ft False}\\
{\ft request.ajax} & {\ft False}\\
{\ft request.cid} & {\ft None}\\
{\ft request.wsgi} & {\ft <hook>}\\
{\ft request.env.content\_length} & {\ft 0}\\
{\ft request.env.content\_type} & {\ft }\\
{\ft request.env.http\_accept} & {\ft text/xml,text/html;}\\
{\ft request.env.http\_accept\_encoding} & {\ft gzip, deflate}\\
{\ft request.env.http\_accept\_language} & {\ft en}\\
{\ft request.env.http\_cookie} & {\ft session\_id\_examples=127.0.0.1.119725}\\
{\ft request.env.http\_host} & {\ft 127.0.0.1:8000}\\
{\ft request.env.http\_referer} & {\ft http://web2py.com/}\\
{\ft request.env.http\_user\_agent} & {\ft Mozilla/5.0}\\
{\ft request.env.path\_info} & {\ft /examples/simple\_examples/status}\\
{\ft request.env.query\_string} & {\ft remote\_addr:127.0.0.1}\\
{\ft request.env.request\_method} & {\ft GET}\\
{\ft request.env.script\_name} & {\ft }\\
{\ft request.env.server\_name} & {\ft 127.0.0.1}\\
{\ft request.env.server\_port} & {\ft 8000}\\
{\ft request.env.server\_protocol} & {\ft HTTP/1.1}\\
{\ft request.env.server\_software} & {\ft Rocket 1.2.6}\\
{\ft request.env.web2py\_path} & {\ft /Users/mdipierro/web2py}\\
{\ft request.env.web2py\_version} & {\ft Version 2.4.1}\\
{\ft request.env.wsgi\_errors} & {\ft <open file, mode 'w' at >}\\
{\ft request.env.wsgi\_input} & {\ft }\\
{\ft request.env.wsgi\_url\_scheme} & {\ft http} \\ \hline
\end{tabular}}
\end{center}
Which environment variables are actually defined depends on the web server. Here we are assuming the built-in Rocket wsgi server. The set of variables is not much different when using the Apache web server.

The {\ft request.env.http\_*} variables are parsed from the request HTTP header.

The {\ft request.env.web2py\_*} variables are not parsed from the web server environment, but are created by web2py in case your applications need to know about the web2py location and version, and whether it is running on the Google App Engine (because specific optimizations may be necessary).

Also notice the {\ft request.env.wsgi\_*} variables. They are specific to the wsgi adapter.

\goodbreak\section{{\ft response}}

\inxx{response}
\inxx{response.body}
\inxx{response.cookies}
\inxx{response.download}
\inxx{response.files}
\inxx{response.flash}
\inxx{response.headers}
\inxx{response.meta}
\inxx{response.menu}
\inxx{response.postprocessing}
\inxx{response.render}
\inxx{response.status}
\inxx{response.stream}
\inxx{response.subtitle}
\inxx{response.title}
\inxx{response.toolbar}
\inxx{response.view}
\inxx{response.delimiters}
\inxx{response.js}
\inxx{response.write}
\inxx{response.include\_files}
\inxx{response.include\_meta}
\inxx{response.optimize\_css}
\inxx{response.optimize\_js}
\inxx{response.\_caller}

{\ft response} is another instance of the {\ft Storage} class. It contains the following:

\begin{itemize}
\item {\ft response.body}: a {\ft StringIO} object into which web2py writes the output page body. NEVER CHANGE THIS VARIABLE.

\item {\ft response.cookies}: similar to {\ft request.cookies}, but while the latter contains the cookies sent from the client to the server, the former contains cookies sent by the server to the client. The session cookie is handled automatically.

\item {\ft response.download(request, db)}: a method used to implement the controller function that allows downloading of uploaded files. {\ft request.download} expects the last {\ft arg} in {\ft request.args} to be the encoded filename (i.e., the filename generated at upload time and stored in the upload field). It extracts the upload field name and table name as well as the original filename from the encoded filename. {\ft response.download} takes two optional arguments: {\ft chunk\_size} sets the size in bytes for chunked streaming (defaults to 64K), and {\ft attachments} determines whether the downloaded file should be treated as an attachment or not (default to {\ft True}). Note, {\ft response.download} is specifically for downloading files associated with {\ft db} upload fields. Use {\ft response.stream} (see below) for other types of file downloads and streaming. Also, note that it is not necessary to use {\ft response.download} to access files uploaded to the /static folder -- static files can (and generally should) be accessed directly via URL (e.g., /app/static/files/myfile.pdf).

\item {\ft response.files}: a list of.css,.js, coffee, and.less files required by the page. They will automatically be linked in the head of the standard "layout.html" via the included "web2py\_ajax.html". To include a new CSS, JS, COFFEE, or LESS file, just append it to this list. It will handle duplicates. The order is important.

\item {\ft response.include\_files()} generates html head tags to include all {\ft response.files} (used in "views/web2py\_ajax.html").

\item {\ft response.flash}: optional parameter that may be included in the views. Normally used to notify the user about something that happened.

\item {\ft response.headers}: a {\ft dict} for HTTP response headers. Web2py sets some headers by default, including "Content-Length", "Content-Type", and "X-Powered-By" (set equal to web2py). Web2py also sets the "Cache-Control", "Expires", and "Pragma" headers to prevent client-side caching, except for static file requests, for which client-side caching is enabled. The headers that web2py sets can be overwritten or removed, and new headers can be added (e.g., {\ft response.headers['Cache-Control'] = 'private'}). You can remove a header by removing its key from the response.headers dict, e.g.{\ft del response.headers['Custom-Header']}, however web2py's default headers will be re-added just before returning the response. To avoid this behavior, just set the header value to None, e.g. to remove the default Content-Type header, {\ft response.headers['Content-Type'] = None}

\item {\ft response.menu}: optional parameter that may be included in the views, normally used to pass a navigation menu tree to the view. It can be rendered by the MENU helper.

\item {\ft response.meta}: a storage object (like a dict) that contains optional meta information like {\ft response.meta.author}, {\ft .description}, and/or {\ft .keywords}. The content of each meta variable is automatically placed in the proper {\ft META} tag by the code in "views/web2py\_ajax.html", which is included by default in "views/layout.html".

\item {\ft response.include\_meta()} generates a string that includes all {\ft response.meta} headers serialized (used in "views/web2py\_ajax.html").

\item {\ft response.postprocessing}: this is a list of functions, empty by default. These functions are used to filter the response object at the output of an action, before the output is rendered by the view. It can be used to implement support for other template languages.

\item {\ft response.render(view, vars)}: a method used to call the view explicitly inside the controller. {\ft view} is an optional parameter which is the name of the view file, {\ft vars} is a dictionary of named values passed to the view.

\item {\ft response.session\_file}: file stream containing the session.

\item {\ft response.session\_file\_name}: name of the file where the session will be saved.

\item {\ft response.session\_id}: the id of the current session. It is determined automatically. NEVER CHANGE THIS VARIABLE.

\item {\ft response.session\_id\_name}: the name of the session cookie for this application. NEVER CHANGE THIS VARIABLE.

\item {\ft response.status}: the HTTP status code integer to be passed to the response. Default is 200 (OK).

\item {\ft response.stream(file, chunk\_size, request=request, attachment=False, filename=None, headers=None)}: when a controller returns it, web2py streams the file content back to the client in blocks of size {\ft chunk\_size}. The {\ft request} parameter is required to use the chunk start in the HTTP header. {\ft file} should be a file path (for backward compatibility, it can also be an open file object, but this is not recommended). As noted above, {\ft response.download} should be used to retrieve files stored via an upload field. {\ft response.stream} can be used in other cases, such as returning a temporary file or StringIO object created by the controller. If {\ft attachment} is True, the Content-Disposition header will be set to "attachment", and if {\ft filename} is also provided, it will be added to the Content-Disposition header as well (but only when {\ft attachment} is True). If not already included in {\ft response.headers}, the following response headers will be set automatically: Content-Type, Content-Length, Cache-Control, Pragma, and Last-Modified (the latter three are set to allow browser caching of the file). To override any of these automatic header settings, simply set them in {\ft response.headers} before calling {\ft response.stream}.

\item {\ft response.subtitle}: optional parameter that may be included in the views. It should contain the subtitle of the page.

\item {\ft response.title}: optional parameter that may be included in the views. It should contain the title of the page and should be rendered by the HTML title TAG in the header.

\item {\ft response.toolbar}: a function that allows you to embed a toolbar into page for debugging purposes {\ft \{\{=response.toolbar()\}\}}. The toolbar displays request, response, session variables and database access time for each query.

\item {\ft response.\_vars}: this variable is accessible only in a view, not in the action. It contains the value returned by the action to the view.

\item {\ft response.\_caller}: this is a function that wraps all action calls. It defaults to the identity function, but it can be modified in order to catch special types of exception to do extra logging;
\end{itemize}
\begin{lstlisting}
  response._caller = lambda f: f()
  
\end{lstlisting}
\begin{itemize}
\item {\ft response.optimize\_css}: if can be set to "concat,minify,inline" to concatenate, minify and inline the CSS files included by web2py.

\item {\ft response.optimize\_js}: if can be set to "concat,minify,inline" to concatenate, minify and inline the JavaScript files included by web2py.

\item {\ft response.view}: the name of the view template that must render the page. This is set by default to:
\end{itemize}
\begin{lstlisting}
  "%s/%s.%s" % (request.controller, request.function, request.extension)
  
\end{lstlisting}
or, if the above file cannot be located, to
\begin{lstlisting}
  "generic.%s" % (request.extension)
  
\end{lstlisting}
Change the value of this variable to modify the view file associated with a particular action.

\begin{itemize}
\item {\ft response.delimiters} defaults to {\ft ('\{\{','\}\}')}. It allows you to change the delimiter of code embedded in views.

\item {\ft response.xmlrpc(request, methods)}: when a controller returns it, this function exposes the methods via XML-RPC~\cite{xmlrpc}. This function is deprecated since a better mechanism is available and described in Chapter 10.

\item {\ft response.write(text)}: a method to write text into the output page body.

\item {\ft response.js} can contain Javascript code. This code will be executed if and only if the response is received by a web2py component as discussed in Chapter 12.
\end{itemize}

Since {\ft response} is a {\ft gluon.storage.Storage} object, it can be used to store other attributes that you may want to pass to the view. While there is no technical restriction, our recommendation is to store only variables that are to be rendered by all pages in the overall layout ("layout.html").

Anyway, we strongly suggest to stick to the variables listed here:
\begin{lstlisting}
response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*
\end{lstlisting}
\noindent because this will make it easier for you to replace the standard "layout.html" file that comes with web2py with another layout file, one that uses the same set of variables.

Old versions of web2py used {\ft response.author} instead of {\ft response.meta.author} and similar for the other meta attributes.

\goodbreak\section{{\ft session}}

\inxx{session} \inxx{session.connect} \inxx{session.forget} \inxx{session.secure}
{\ft session} is another instance of the {\ft Storage} class. Whatever is stored into {\ft session} for example:
\begin{lstlisting}
session.myvariable = "hello"
\end{lstlisting}
\noindent can be retrieved at a later time:
\begin{lstlisting}
a = session.myvariable
\end{lstlisting}
\noindent as long as the code is executed within the same session by the same user (provided the user has not deleted session cookies and the session has not expired). Because {\ft session} is a {\ft Storage} object, trying to access an attribute/key that has not been set does not raise an exception; it returns {\ft None} instead.

The session object has three important methods. One is {\ft forget}:
\begin{lstlisting}
session.forget(response)
\end{lstlisting}

It tells web2py not to save the session. This should be used in those controllers whose actions are called often and do not need to track user activity. {\ft session.forget()} prevents the session file from being written, regardless of whether it has been modified. {\ft session.forget(response)} additionally unlocks and closes the session file. You rarely need to call this method since sessions are not saved when they are not changed. However, if the page makes multiple simultaneous Ajax requests, it is a good idea for the actions called via Ajax to call {\ft session.forget(response)} (assuming the session is not needed by the action). Otherwise, each Ajax action will have to wait for the previous one to complete (and unlock the session file) before proceeding, which will slow down the page loading. Notice that sessions are not locked when stored in the database.

Another method is:

\begin{lstlisting}
session.secure()
\end{lstlisting}
\noindent which tells web2py to set the session cookie to be a secure cookie. This should be set if the app is going over https. By setting the session cookie to be secure, the server is asking the browser not to send the session cookie back to the server unless over an https connection.

The other method is {\ft connect}.
By default sessions are stored on the filesystem and a session cookie is used to store and retrieve the {\ft session.id}. Using the connect method it is possible to tell web2y to store sessions in the database or in the cookies thus eliminating need to access the filesystem for session management.

For example to {\bf store sessions in the database}:

\begin{lstlisting}
session.connect(request, response, db, masterapp=None)
\end{lstlisting}
\noindent where {\ft db} is the name of an open database connection (as returned by the DAL). It tells web2py that you want to store the sessions in the database and not on the filesystem. {\ft session.connect} must come after {\ft db=DAL(...)}, but before any other logic that requires session, for example, setting up {\ft Auth}.
\noindent web2py creates a table:
\begin{lstlisting}
db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))
\end{lstlisting}
\noindent and stores cPickled sessions in the {\ft session\_data} field.

The option {\ft masterapp=None}, by default, tells web2py to try to retrieve an existing session for the application with name in {\ft request.application}, in the running application.

If you want two or more applications to share sessions, set {\ft masterapp} to the name of the master application.

To {\bf store sessions in cookies} instead you can do:

\begin{lstlisting}
session.connect(request,response,cookie_key='yoursecret',compression_level=None)
\end{lstlisting}

Here {\ft cookie\_key} is a symmetric encryption key.
{\ft compression\_level} is an optional {\ft zlib} encryption level.

While sessions in cookie are often recommended for scalability reason they are limited in size. Large sessions will result in broken cookies.

You can check the state of your application at any time by printing the {\ft request}, {\ft session} and {\ft response} system variables. One way to do it is to create a dedicated action:
\begin{lstlisting}
def status():
    return dict(request=request, session=session, response=response)
\end{lstlisting}

In the "generic.html" view this is done using {\ft \{\{=response.toolbar()\}\}}.

\goodbreak\subsection{Separate sessions}

If you are storing sessions on filesystems and you have lots of them, the file system access may become a bottle-neck. One solution is the following:
If you are storing sessions on filesystem and you have lots of them, the file system access may become a bottle-neck. One solution is the following:
\begin{lstlisting}
session.connect(request, response, separate=True)
\end{lstlisting}

By setting {\ft separate=True} web2py will store sessions not in the "sessions/" folder but in subfolders of the "sessions/" folder. The subfolder will be created automatically. Sessions with the same prefix will be in the same subfolder. Again, note that the above must be called before any logic that might require the session.

\goodbreak\section{{\ft cache}}

\inxx{cache} \inxx{cache.ram} \inxx{cache.disk}
{\ft cache} a global object also available in the web2py execution environment. It has two attributes:
\begin{itemize}
\item {\ft cache.ram}: the application cache in main memory.

\item {\ft cache.disk}: the application cache on disk.
\end{itemize}
{\ft cache} is callable, this allows it to be used as a decorator for caching actions and views.

The following example caches the {\ft time.ctime()} function in RAM:
\begin{lstlisting}
def cache_in_ram():
    import time
    t = cache.ram('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
\end{lstlisting}

The output of {\ft lambda: time.ctime()} is cached in RAM for 5 seconds. The string {\ft 'time'} is used as cache key.

The following example caches the {\ft time.ctime()} function on disk:
\begin{lstlisting}
def cache_on_disk():
    import time
    t = cache.disk('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
\end{lstlisting}

The output of {\ft lambda: time.ctime()} is cached on disk (using the shelve module) for 5 seconds.

Note, the second argument to {\ft cache.ram} and {\ft cache.disk} must be a function or callable object. If you want to cache an existing object rather than the output of a function, you can simply return it via a lambda function:
\begin{lstlisting}
cache.ram('myobject', lambda: myobject, time_expire=60*60*24)
\end{lstlisting}

The next example caches the {\ft time.ctime()} function to both RAM and disk:
\begin{lstlisting}
def cache_in_ram_and_disk():
    import time
    t = cache.ram('time', lambda: cache.disk('time',
                       lambda: time.ctime(), time_expire=5),
                       time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
\end{lstlisting}

The output of {\ft lambda: time.ctime()} is cached on disk (using the shelve module) and then in RAM for 5 seconds. web2py looks in RAM first and if not there it looks on disk. If it is not in RAM or on disk, {\ft lambda: time.ctime()} is executed and the cache is updated. This technique is useful in a multiprocessor environment. The two times do not have to be the same.

The following example is caching in RAM the output of the controller function (but not the view):

\inxx{cache controller}
\begin{lstlisting}
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_in_ram():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click me', _href=request.url))
\end{lstlisting}

The dictionary returned by {\ft cache\_controller\_in\_ram} is cached in RAM for 5 seconds. Note that the result of a database select cannot be cached without first being serialized. A better way is to cache the database select directly using the {\ft select} method's {\ft cache} argument.

The following example is caching the output of the controller function on disk (but not the view):
\begin{lstlisting}
@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_controller_on_disk():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click to reload',
                              _href=request.url))
\end{lstlisting}

The dictionary returned by {\ft cache\_controller\_on\_disk}  is cached on disk for 5 seconds. Remember that web2py cannot cache a dictionary that contains un-pickleable objects.

It is also possible to cache the view. The trick is to render the view in the controller function, so that the controller returns a string. This is done by returning {\ft response.render(d)} where {\ft d} is the dictionary we intended to pass to the view. The following example caches the output of the controller function in RAM (including the rendered view):

\inxx{cache view}
\begin{lstlisting}
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_and_view():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('click to reload', _href=request.url))
    return response.render(d)
\end{lstlisting}
{\ft response.render(d)} returns the rendered view as a string, which is now cached for 5 seconds. This is the best and fastest way of caching.

Note, {\ft time\_expire} is used to compare the current time with the time the requested object was last saved in the cache. It does not affect future requests. This enables {\ft time\_expire} to be set dynamically when an object is requested rather than being fixed when the object is saved. For example:
\begin{lstlisting}
message = cache.ram('message', lambda: 'Hello', time_expire=5)
\end{lstlisting}

Now, suppose the following call is made 10 seconds after the above call:
\begin{lstlisting}
message = cache.ram('message', lambda: 'Goodbye', time_expire=20)
\end{lstlisting}

Because {\ft time\_expire} is set to 20 seconds in the second call and only 10 seconds has elapsed since the message was first saved, the value "Hello" will be retrieved from the cache, and it will not be updated with "Goodbye". The {\ft time\_expire} value of 5 seconds in the first call has no impact on the second call.

Setting {\ft time\_expire=0} (or a negative value) forces the cached item to be refreshed (because the elapsed time since the last save will always be > 0), and setting {\ft time\_expire=None} forces retrieval of the cached value, regardless of the time elapsed since it was saved (if {\ft time\_expire} is always {\ft None}, the cached item will effectively never expire).

You can clear one or more cache variables with
\inxx{cache clear}

\begin{lstlisting}
cache.ram.clear(regex='...')
\end{lstlisting}
\noindent where {\ft regex} is a regular expression matching all the keys you want removed from the cache. You can also clear a single item with:
\begin{lstlisting}
cache.ram(key, None)
\end{lstlisting}
\noindent where {\ft key} is the key of the cached item.

It is also possible to define other caching mechanisms such as memcache. Memcache is available via {\ft gluon.contrib.memcache} and is discussed in more details in Chapter 14.

\begin{quote}Be careful when caching to remeber that caching is usually at the app-level not at the user level. If you need, for example, to cache user specific content, choose a key that includes the user id.\end{quote}
\goodbreak\section{{\ft URL}}

\inxx{URL}
The {\ft URL} function is one of the most important functions in web2py. It generates internal URL paths for the actions and the static files.

Here is an example:

\begin{lstlisting}
URL('f')
\end{lstlisting}
\noindent is mapped into

\begin{lstlisting}
/[application]/[controller]/f
\end{lstlisting}

Notice that the output of the {\ft URL} function depends on the name of the current application, the calling controller, and other parameters. web2py supports URL mapping and reverse URL mapping. URL mapping allows you to redefine the format of external URLs. If you use the {\ft URL} function to generate all the internal URLs, then additions or changes to URL mappings will prevent broken links within the web2py application.

You can pass additional parameters to the {\ft URL} function, i.e., extra terms in the URL path (args) and URL query variables (vars):

\begin{lstlisting}
URL('f', args=['x', 'y'], vars=dict(z='t'))
\end{lstlisting}
\noindent is mapped into

\begin{lstlisting}
/[application]/[controller]/f/x/y?z=t
\end{lstlisting}

The {\ft args} attributes are automatically parsed, decoded, and finally stored in {\ft request.args} by web2py. Similarly, the {\ft vars} are parsed, decoded, and then stored in {\ft request.vars}.
{\ft args} and {\ft vars} provide the basic mechanism by which web2py exchanges information with the client's browser.

If args contains only one element, there is no need to pass it in a list.

You can also use the {\ft URL} function to generate URLs to actions in other controllers and other applications:

\begin{lstlisting}
URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))
\end{lstlisting}
\noindent is mapped into

\begin{lstlisting}
/a/c/f/x/y?z=t
\end{lstlisting}

It is also possible to specify application, controller and function using named arguments:

\begin{lstlisting}
URL(a='a', c='c', f='f')
\end{lstlisting}

If the application name a is missing the current app is assumed.

\begin{lstlisting}
URL('c', 'f')
\end{lstlisting}

If the controller name is missing, the current one is assumed.

\begin{lstlisting}
URL('f')
\end{lstlisting}

Instead of passing the name of a controller function it is also possible to pass the function itself

\begin{lstlisting}
URL(f)
\end{lstlisting}

For the reasons mentioned above, you should always use the {\ft URL} function to generate URLs of static files for your applications. Static files are stored in the application's {\ft static} subfolder (that's where they go when uploaded using the administrative interface). web2py provides a virtual 'static' controller whose job is to retrieve files from the {\ft static} subfolder, determine their content-type, and stream the file to the client. The following example generates the URL for the static file "image.png":

\begin{lstlisting}
URL('static', 'image.png')
\end{lstlisting}
\noindent is mapped into

\begin{lstlisting}
/[application]/static/image.png
\end{lstlisting}

If the static file is in a subfolder within the {\ft static} folder, you can include the subfolder(s) as part of the filename. For example, to generate:

\begin{lstlisting}
/[application]/static/images/icons/arrow.png
\end{lstlisting}
\noindent one should use:

\begin{lstlisting}
URL('static', 'images/icons/arrow.png')
\end{lstlisting}

You do not need to encode/escape the {\ft args} and {\ft vars} arguments; this is done automatically for you.

By default, the extension corresponding to the current request (which can be found in {\ft request.extension}) is appended to the function, unless request.extension is html, the default. This can be overridden by explicitly including an extension as part of the function name {\ft URL(f='name.ext')} or with the extension argument:
\begin{lstlisting}
URL(..., extension='css')
\end{lstlisting}

The current extension can be explicitly suppressed:
\begin{lstlisting}
URL(..., extension=False)
\end{lstlisting}

\goodbreak\subsection{Absolute urls}

By default, {\ft URL} generates relative URLs. However, you can also generate absolute URLs by specifying the {\ft scheme} and {\ft host} arguments (this is useful, for example, when inserting URLs in email messages):

\begin{lstlisting}
URL(..., scheme='http', host='www.mysite.com')
\end{lstlisting}

You can automatically include the scheme and host of the current request by simply setting the arguments to {\ft True}.

\begin{lstlisting}
URL(..., scheme=True, host=True)
\end{lstlisting}

The {\ft URL} function also accepts a {\ft port} argument to specify the server port if necessary.

\goodbreak\subsection{Digitally signed urls}

\inxx{digitally signed URL}

When generating a URL, you have the option to digitally sign it. This will append a {\ft \_signature} GET variable that can be verified by the server. This can be done in two ways.

You can pass to the URL function the following arguments:
\begin{itemize}
\item {\ft hmac\_key}: the key for signing the URL (a string)

\item {\ft salt}: an optional string to salt the data before signing

\item {\ft hash\_vars}: an optional list of names of variables from the URL query string (i.e., GET variables) to be included in the signature. It can also be set to {\ft True} (the default) to include all variables, or {\ft False} to include none of the variables.
\end{itemize}

Here is an example of usage:

\begin{lstlisting}
KEY = 'mykey'

def one():
    return dict(link=URL('two', vars=dict(a=123), hmac_key=KEY))

def two():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # do something
    return locals()
\end{lstlisting}

This makes the action {\ft two} accessible only via a digitally signed URL. A digitally signed URL looks like this:
\begin{lstlisting}
'/welcome/default/two?a=123&_signature=4981bc70e13866bb60e52a09073560ae822224e9'
\end{lstlisting}

Note, the digital signature is verified via the {\ft URL.verify} function. {\ft URL.verify} also takes the {\ft hmac\_key}, {\ft salt}, and {\ft hash\_vars} arguments described above, and their values must match the values that were passed to the {\ft URL} function when the digital signature was created in order to verify the URL.

A second and more sophisticated but more common use of digitally signed URLs is in conjunction with Auth. This is best explained with an example:

\begin{lstlisting}
@auth.requires_login()
def one():
    return dict(link=URL('two', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def two():
    # do something
    return locals()
\end{lstlisting}

In this case the {\ft hmac\_key} is automatically generated and shared within the session. This allows action {\ft two} to delegate any access control to action {\ft one}. If the link is generated and signed, it is valid; else it is not. If the link is stolen by another user, the link will be invalid.

It is good practice to always digitally sign Ajax callbacks. If you use the web2py {\ft LOAD} function, it has a {\ft user\_signature} argument too that can be used for this purpose:

\begin{lstlisting}[keywords={}]
{{=LOAD('default', 'two', vars=dict(a=123), ajax=True, user_signature=True)}}
\end{lstlisting}

\goodbreak\section{{\ft HTTP} and {\ft redirect}}

\inxx{HTTP} \inxx{redirect}
\noindent web2py defines only one new exception called {\ft HTTP}. This exception can be raised anywhere in a model, a controller, or a view with the command:

\begin{lstlisting}
raise HTTP(400, "my message")
\end{lstlisting}

It causes the control flow to jump away from the user's code, back to web2py, and return an HTTP response like:
\begin{lstlisting}
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message
\end{lstlisting}

The first argument of {\ft HTTP} is the HTTP status code. The second argument is the string that will be returned as the body of the response. Additional optional named arguments are used to build the response HTTP header.
For example:
\begin{lstlisting}
raise HTTP(400, 'my message', test='hello')
\end{lstlisting}
\noindent generates:
\begin{lstlisting}
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message
\end{lstlisting}

If you do not want to commit the open database transaction, rollback before raising the exception.

Any exception other than {\ft HTTP} causes web2py to roll back any open database transaction, log the error traceback, issue a ticket to the visitor, and return a standard error page.

This means that only {\ft HTTP} can be used for cross-page control flow. Other exceptions must be caught by the application, otherwise they are ticketed by web2py.

The command:
\begin{lstlisting}
redirect('http://www.web2py.com')
\end{lstlisting}
\noindent is simply a shortcut for:
\begin{lstlisting}
raise HTTP(303,
           'You are being redirected <a href="%s">here</a>' % location,
           Location='http://www.web2py.com')
\end{lstlisting}

The named arguments of the {\ft HTTP} initializer method are translated into HTTP header directives, in this case, the redirection target location. {\ft redirect} takes an optional second argument, which is the HTTP status code for the redirection (303 by default). Change this number to 307 for a temporary redirect or to 301 for a permanent redirect.

The most common way to use redirect is to redirect to other pages in the same app and (optionally) pass parameters:

\begin{lstlisting}
redirect(URL('index', args=(1,2,3), vars=dict(a='b')))
\end{lstlisting}

In chapter 12 we discuss web2py components. They make Ajax requests to web2py actions. If the called action performs a redirect, you may want the Ajax request to follow the redirect or you may want the entire page performing the Ajax request redirecting. In this latter case you can set:

\begin{lstlisting}
redirect(...,type='auto')
\end{lstlisting}

\goodbreak\section{{\ft T}, Internationalization, and Pluralization}

\inxx{T} \inxx{internationalization}

The object {\ft T} is the language translator. It constitutes a single global instance of the web2py class {\ft gluon.language.translator}. All string constants (and only string constants) should be marked by {\ft T}, for example:
\begin{lstlisting}
a = T("hello world")
\end{lstlisting}

Strings that are marked with {\ft T} are identified by web2py as needing language translation and they will be translated when the code (in the model, controller, or view) is executed. If the string to be translated is not a constant but a variable, it will be added to the translation file at runtime (except on GAE) to be translated later.

The {\ft T} object can also contain interpolated variables and supports multiple equivalent syntaxes:
\begin{lstlisting}
a = T("hello %s", ('Tim',))
a = T("hello %(name)s", dict(name='Tim'))
a = T("hello %s") % ('Tim',)
a = T("hello %(name)s") % dict(name='Tim')
\end{lstlisting}

The latter syntax is recommended because it makes translation easier.
The first string is translated according to the requested language file and the {\ft name} variable is replaced independently of the language.

You can concatenating translated strings and normal strings:
\begin{lstlisting}
T("blah ") + name + T(" blah")
\end{lstlisting}

The following code is also allowed and often preferable:

\begin{lstlisting}
T("blah %(name)s blah", dict(name='Tim'))
\end{lstlisting}
\noindent or the alternative syntax
\begin{lstlisting}
T("blah %(name)s blah") % dict(name='Tim')
\end{lstlisting}

In both cases the translation occurs before the variable name is substituted in the "\%(name)s" slot. The following alternative should NOT BE USED:
\begin{lstlisting}
T("blah %(name)s blah" % dict(name='Tim'))
\end{lstlisting}
\noindent because translation would occur after substitution.

\goodbreak\subsection{Determining the language}

The requested language is determined by the "Accept-Language" field in the HTTP header, but this selection can be overwritten programmatically by requesting a specific file, for example:
\begin{lstlisting}
T.force('it-it')
\end{lstlisting}
\noindent which reads the "languages/it-it.py" language file. Language files can be created and edited via the administrative interface.

You can also force a per-string language:

\begin{lstlisting}
T("Hello World", language="it-it")
\end{lstlisting}

\begin{quote}In the case multiple languages are requested, for example "it-it, fr-ft", web2py tries to locate "it-it.py" and "fr-fr.py" translation files. If none of the requested files is present, it tries to fall back on "it.py" and "fr.py". If these files are not present it defaults to "default.py". If this is not present either, it default to no-translation. The more general rule is that web2py tries "xx-xy-yy.py", "xx-xy.py", "xx.py", "default.py" for each of the "xx-xy-yy" accepted languages trying to find the closest match to the visitor's preferences.\end{quote}
You can turn off translations completely via

\begin{lstlisting}
T.force(None)
\end{lstlisting}

Normally, string translation is evaluated lazily when the view is rendered; hence, the translator {\ft force} method should not be called inside a view.

It is possible to disable lazy evaluation via
\begin{lstlisting}
T.lazy = False
\end{lstlisting}

In this way, strings are translated immediately by the {\ft T} operator based on the currently accepted or forced language.

It is also possible to disable lazy evaluation for individual strings:

\begin{lstlisting}
T("Hello World", lazy=False)
\end{lstlisting}

A common issue is the following. The original application is in English. Suppose that there is a translation file (for example Italian, "it-it.py") and the HTTP client declares that it accepts both English (en) and Italian (it-it) in that order. The following unwanted situation occurs: web2py does not know the default is written in English (en). Therefore, it prefers translating everything into Italian (it-it) because it only found the Italian translation file. If it had not found the "it-it.py" file, it would have used the default language strings (English).

There are two solutions for this problem: create a translation language for English, which would be redundant and unnecessary, or better, tell web2py which languages should use the default language strings (the strings coded into the application). This can be done with:
\begin{lstlisting}
T.set_current_languages('en', 'en-en')
\end{lstlisting}

It stores in  {\ft T.current\_languages} a list of languages that do not require translation and forces a reload of the language files.

Notice that "it" and "it-it" are different languages from the point of view of web2py. To support both of them, one would need two translation files, always lower case. The same is true for all other languages.

The currently accepted language is stored in
\begin{lstlisting}
T.accepted_language
\end{lstlisting}

\goodbreak\subsection{Translating variables}

Mind that T(...) does not just translate strings but can also translated variables:
\begin{lstlisting}
>>> a="test"
>>> print T(a)
\end{lstlisting}

In this case the word "test" is translated but, if not found and if the filesystem is writable, it will add it to the list of words to be translated in the language file.

Notice that this can result in lots of file IO and you may want to disable it:

\begin{lstlisting}
T.is_writable = False
\end{lstlisting}
\noindent prevents T from dynamically updating language files.

\goodbreak\subsection{Comments and multiple translations}

It is possible that the same string appears in different contexts in the application and needs different translations based on context. In order to do this, one can add comments to the original string. The comments will not be rendered but will be used by web2py to determine the most appropriate translation. For example:

\begin{lstlisting}
T("hello world ## first occurrence")
T("hello world ## second occurrence")
\end{lstlisting}

The text following the {\ft \#\#}, including the double {\ft \#\#}, are comments.

\goodbreak\subsection{Pluralization engine}

Since version 2.0, web2py includes a powerful pluralization system (PS). This means that when text marked for translation depends on a numeric variable, it may be translated differently based on the numeric value. For example in English we may render:

\begin{lstlisting}
x book(s)
\end{lstlisting}
\noindent with

\begin{lstlisting}
a book (x==0)
x books (x>0)
\end{lstlisting}

English has one singular form and one plural form. The plural form is constructed by adding a "-s" or "-es" or using an exceptional form. web2py provides a way to define pluralization rules for each languages, as well as exceptions to the default rules. In fact web2py already knows pluralization rules for many languages. It knows, for example, that Slovenian has one singular form and 3 plural forms (for x==1, x==3 or x==4 and x>4). These rules are encoded in "gluon/contrib/plural\_rules/*.py" files and new files can be created. Explicit pluralizations for words are created by editing pluralization files using the administrative interface.

By default the PS is not activated. It is triggered by the {\ft symbol} argument of the {\ft T} function. For example:

\begin{lstlisting}
T("You have %s %%{book}", symbols=10)
\end{lstlisting}

Now the PS is activated for the word "book" and for the number 10.
The result in English will be: "You have 10 books". Notice that "book" has been pluralized into "books".

The PS consists of 3 parts:
\begin{itemize}
\item placeholders {\ft \%\%\{\}} to mark words in {\ft T}-messages

\item rule to give a decision which word form to use ("rules/plural\_rules/*.py")

\item dictionary with word plural forms ("app/languages/plural-*.py")
\end{itemize}

The value of symbols can be a single variable, a list/tuple of variables, or a dictionary.

The placeholder {\ft \%\%\{\}} consists of 3 parts:

\begin{lstlisting}
%%{[<modifier>]<world>[<parameter>]},
\end{lstlisting}
\noindent where:

\begin{lstlisting}[keywords={}]
<modifier>::= ! | !! | !!!
<word> ::= any word or phrase in singular in lower case (!)
<parameter> ::= [index] | (key) | (number)
\end{lstlisting}

For example:

\begin{itemize}
\item {\ft \%\%\{word\}} is equivalent to \%\%\{word[0]\} (if no modifiers are used).

\item {\ft \%\%\{word[index]\}} is used when symbols is a tuple. symbols[index] gives us a number used to make a decision on which word form to choose.

\item {\ft \%\%\{word(key)\}} is used to get the numeric parameter from symbols[key]

\item {\ft \%\%\{word(number)\}} allows to set a {\ft number} directly (e.g.: {\ft \%\%\{word(\%i)\}})

\item {\ft \%\%\{?word?number\}} returns "word" if {\ft number==1}, returns the {\ft number} otherwise

\item {\ft \%\%\{?number\} or \%\%\{??number\}} returns {\ft number} if {\ft number!=1}, return nothing otherwise
\end{itemize}

{\ft T("blabla \%s \%\%\{word\}", symbols=var)}

{\ft \%\%\{word\}} by default means {\ft \%\%\{word[0]\}},
where {\ft [0]} is an item index in symbols tuple.

{\ft T("blabla \%s \%s \%\%\{word[1]\}", (var1, var2))}
PS is used for "word" and var2 respectively.

You can use several \%\%\{\} placeholders with one index:

{\ft T("\%\%\{this\} \%\%\{is\} \%s \%\%\{book\}", var)}
\noindent or

{\ft T("\%\%\{this[0]\} \%\%\{is[0]\} \%s \%\%\{book[0]\}", var)}

Generate:

\begin{lstlisting}
var  output
------------------
 1   this is 1 book
 2   these are 2 books
 3   these are 2 books
\end{lstlisting}

Similarly you can pass a dictionary to symbols:

\begin{lstlisting}
T("blabla %(var1)s %(wordcnt)s %%{word(wordcnt)}",
  dict(var1="tututu", wordcnt=20))
\end{lstlisting}
\noindent which produces

\begin{lstlisting}
blabla tututu 20 words
\end{lstlisting}

You can replace "1" with any word you wish by this placeholder {\ft \%\%\{?word?number\}}.
For example

{\ft T("\%\%\{this\} \%\%\{is\} \%\%\{?a?\%s\} \%\%\{book\}", var)}
\noindent produces:

\begin{lstlisting}
var  output
------------------
 1   this is a book
 2   these are 2 books
 3   these are 3 books
 ...
\end{lstlisting}

Inside {\ft \%\%\{...\}} you can also use the following modifiers:

\begin{itemize}
\item {\ft !} to capitalize the text (equivalent to {\ft string.capitalize})

\item {\ft !!} to capitalize every word (equivalent to {\ft string.title})

\item {\ft !!!} to capitalize every character (equivalent to {\ft string.upper})
\end{itemize}

Notice you can use {\ft {\textbackslash}{\textbackslash}} to escape {\ft !} and {\ft ?}.

\goodbreak\subsection{Translations, pluralization, and MARKMIN}

You can also use the powerful MARKMIN syntax inside translation strings by replacing

\begin{lstlisting}
T("hello world")
\end{lstlisting}
\noindent with

\begin{lstlisting}
T.M("hello world")
\end{lstlisting}

Now the string accepts MARKMIN markup as described later in the book. You can also use the pluralization system inside MARKMIN.

\goodbreak\section{Cookies}

\inxx{cookies}
\noindent web2py uses the Python cookies modules for handling cookies.

Cookies from the browser are in {\ft request.cookies} and cookies sent by the server are in {\ft response.cookies}.

You can set a cookie as follows:
\begin{lstlisting}
response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'
\end{lstlisting}

The second line tells the browser to keep the cookie for 24 hours. The third line tells the browser to send the cookie back to any application (URL path) at the current domain. Note, if you do not specify a path for the cookie, the browser will assume the path of the URL that was requested, so the cookie will only be returned to the server when that same URL path is requested.

The cookie can be made secure with:
\begin{lstlisting}
response.cookies['mycookie']['secure'] = True
\end{lstlisting}

This tells the browser only to send the cookie back over HTTPS and not over HTTP.

The cookie can be retrieved with:
\begin{lstlisting}
if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value
\end{lstlisting}

Unless sessions are disabled, web2py, under the hood, sets the following cookie and uses it to handle sessions:
\begin{lstlisting}
response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"
\end{lstlisting}

Note, if a single application includes multiple subdomains, and you want to share the session across those subdomains (e.g., sub1.yourdomain.com, sub2.yourdomain.com, etc.), you must explicitly set the domain of the session cookie as follows:
\begin{lstlisting}
if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".yourdomain.com"
\end{lstlisting}

The above can be useful if, for example, you want to allow the user to remain logged in across subdomains.

\goodbreak\section{Application {\bf init}}

\inxx{init}

When you deploy web2py, you will want to set a default application, i.e., the application that starts when there is an empty path in the URL, as in:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000
\end{lstlisting}

By default, when confronted with an empty path, web2py looks for an application called {\bf init}. If there is no init application it looks for an application called {\bf welcome}.

\inxx{default\_application}
The name of the default application can be changed from {\bf init} to another name by setting {\ft default\_application} in routes.py:
\begin{lstlisting}
default_application = "myapp"
\end{lstlisting}

Note: {\ft default\_application} first appeared in web2py version 1.83.

Here are four ways to set the default application:
\begin{itemize}
\item Call your default application "init".

\item Set {\ft default\_application} to your application's name in routes.py

\item Make a symbolic link from "applications/init" to your application's folder.

\item Use URL rewrite as discussed in the next section.
\end{itemize}

\goodbreak\section{URL rewrite}

\inxx{url rewrite}
\inxx{routes\_in}
\inxx{routes\_out}
\noindent web2py has the ability to rewrite the URL path of incoming requests prior to calling the controller action (URL mapping), and conversely, web2py can rewrite the URL path generated by the {\ft URL} function (reverse URL mapping). One reason to do this is for handling legacy URLs, another is to simplify paths and make them shorter.
\noindent web2py includes two distinct URL rewrite systems: an easy-to-use {\it parameter-based} system for most use cases, and a flexible {\it pattern-based} system for more complex cases. To specify the URL rewrite rules, create a new file in the "web2py" folder called {\ft routes.py} (the contents of {\ft routes.py} will depend on which of the two rewrite systems you choose, as described in the next two sections). The two systems cannot be mixed.

\begin{quote}Notice that if you edit routes.py, you must reload it. This can be done in two ways: by restarting the web server or by clicking on the routes reload button in admin. If there is a bug in routes, they will not reload.\end{quote}
\goodbreak\subsection{Parameter-based system}

The parameter-based (parametric) router provides easy access to several "canned" URL-rewrite methods. Its capabilities include:

* Omitting default application, controller and function names from externally-visible URLs (those created by the URL() function)

* Mapping domains (and/or ports) to applications or controllers

* Embedding a language selector in the URL

* Removing a fixed prefix from incoming URLs and adding it back to outgoing URLs

* Mapping root files such as /robots.txt to an applications static directory

The parametric router also provides somewhat more flexible validation of incoming URLs.

Suppose you've written an application called {\ft myapp} and wish to make it the default, so that the application name is no longer part of the URL as seen by the user. Your default controller is still {\ft default}, and you want to remove its name from user-visible URLs as well. Here's what you put in {\ft routes.py}:
\begin{lstlisting}
routers = dict(
  BASE  = dict(default_application='myapp'),
)
\end{lstlisting}

That's it. The parametric router is smart enough to know how to do the right thing with URLs such as:
\begin{lstlisting}[keywords={}]
http://domain.com/myapp/default/myapp
\end{lstlisting}
or
\begin{lstlisting}[keywords={}]
http://domain.com/myapp/myapp/index
\end{lstlisting}
where normal shortening would be ambiguous. If you have two applications, {\ft myapp} and {\ft myapp2}, you'll get the same effect, and additionally {\ft myapp2}'s default controller will be stripped from the URL whenever it's safe (which is mostly all the time).

Here is another case: suppose you want to support URL-based languages, where your URLs look like this:
\begin{lstlisting}[keywords={}]
http://myapp/en/some/path
\end{lstlisting}
or (rewritten)
\begin{lstlisting}[keywords={}]
http://en/some/path
\end{lstlisting}

Here's how:
\begin{lstlisting}
routers = dict(
  BASE  = dict(default_application='myapp'),
  myapp = dict(languages=['en', 'it', 'jp'], default_language='en'),
)
\end{lstlisting}

Now an incoming URL like this:
\begin{lstlisting}[keywords={}]
http:/domain.com/it/some/path
\end{lstlisting}
will be routed to {\ft /myapp/some/path}, and request.uri\_language will be set to 'it', so you can force the translation. You can also have language-specific static files.

\begin{lstlisting}[keywords={}]
http://domain.com/it/static/filename
\end{lstlisting}
will be mapped to:
\begin{lstlisting}
applications/myapp/static/it/filename
\end{lstlisting}
if that file exists. If it doesn't, then URLs like:
\begin{lstlisting}[keywords={}]
http://domain.com/it/static/base.css
\end{lstlisting}
will still map to:
\begin{lstlisting}
applications/myapp/static/base.css
\end{lstlisting}
(because there is no {\ft static/it/base.css}).

So you can now have language-specific static files, including images, if you need to.  Domain mapping is supported as well:
\begin{lstlisting}
routers = dict(
  BASE  = dict(
      domains = {
          'domain1.com' : 'app1',
          'domain2.com' : 'app2',
      }
  ),
)
\end{lstlisting}
does what you'd expect.

\begin{lstlisting}
routers = dict(
  BASE  = dict(
      domains = {
          'domain.com:80'  : 'app/insecure',
          'domain.com:443' : 'app/secure',
      }
  ),
)
\end{lstlisting}
maps {\ft http://domain.com} accesses to the controller named {\ft insecure}, while {\ft HTTPS} accesses go to the {\ft secure} controller. Alternatively, you can map different ports to different apps, in the obvious way.

For further information, please consult the file {\footnotesize\href{http://code.google.com/p/web2py/source/browse/router.example.py}{{\ft router.example.py}}} provided in the base folder of the standard web2py distribution.

Note: The {\it parameter-based} system first appeared in web2py version 1.92.1.

\goodbreak\subsection{Pattern-based system}

Although the {\it parameter-based} system just described should be sufficient for most use cases, the alternative {\it pattern-based} system provides some additional flexibility for more complex cases. To use the pattern-based system, instead of defining routers as dictionaries of routing parameters, you define two lists (or tuples) of 2-tuples, {\ft routes\_in} and {\ft routes\_out}. Each tuple contains two elements: the pattern to be replaced and the string that replaces it. For example:
\begin{lstlisting}
routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)
\end{lstlisting}

With these routes, the URL:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/testme
\end{lstlisting}
\noindent is mapped into:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/examples/default/index
\end{lstlisting}

To the visitor, all links to
the page URL looks like {\ft /testme}.

The patterns have the same syntax as Python regular expressions. For example:
\begin{lstlisting}
  ('.*\.php', '/init/default/index'),
\end{lstlisting}
\noindent maps all URLs ending in ".php" to the index page.

The second term of a rule can also be a redirection to another page:
\begin{lstlisting}
  ('.*\.php', '303->http://example.com/newpage'),
\end{lstlisting}

Here 303 is the HTTP code for the redirect response.

Sometimes you want to get rid of the application prefix from the URLs because you plan to expose only one application. This can be achieved with:
\begin{lstlisting}
routes_in = (
  ('/(?P<any>.*)', '/init/\g<any>'),
)
routes_out = (
  ('/init/(?P<any>.*)', '/\g<any>'),
)
\end{lstlisting}

There is also an alternative syntax that can be mixed with the regular expression notation above. It consists of using {\ft \$name} instead of {\ft (?P<name>{\textbackslash}w+)} or {\ft {\textbackslash}g<name>}. For example:
\begin{lstlisting}
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)
\end{lstlisting}
\noindent would also eliminate the "/example" application prefix in all URLs.

Using the {\ft \$name} notation, you can automatically map {\ft routes\_in} to {\ft routes\_out}, provided you don't use any regular expressions. For example:
\begin{lstlisting}
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]
\end{lstlisting}

If there are multiple routes, the first to match the URL is executed. If no pattern matches, the path is left unchanged.

You can use {\ft \$anything} to match anything ({\ft .*}) until the end of the line.

Here is a minimal "routes.py" for handling favicon and robots requests:

\inxx{favicon} \inxx{robots}
\begin{lstlisting}
routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()
\end{lstlisting}

Here is a more complex example that exposes a single app "myapp" without unnecessary prefixes but also exposes {\bf admin}, {\bf appadmin} and static:

\begin{lstlisting}
routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]
\end{lstlisting}

The general syntax for routes is more complex than the simple examples we have seen so far. Here is a more general and representative example:
\begin{lstlisting}
routes_in = (
 ('140\.191\.\d+\.\d+:https?://www.web2py.com:post /(?P<any>.*)\.php',
  '/test/default/index?vars=\g<any>'),
)
\end{lstlisting}

It maps {\ft http} or {\ft https} {\ft POST} requests (note lower case "post") to host {\ft www.web2py.com} from a remote IP matching the regular expression
\begin{lstlisting}
'140\.191\.\d+\.\d+'
\end{lstlisting}
\noindent requesting a page matching the regular expression
\begin{lstlisting}
'/(?P<any>.*)\.php'
\end{lstlisting}
\noindent into
\begin{lstlisting}
'/test/default/index?vars=\g<any>'
\end{lstlisting}
\noindent where {\ft {\textbackslash}g<any>} is replaced by the matching regular expression.

The general syntax is
\begin{lstlisting}
'[remote address]:[protocol]://[host]:[method] [path]'
\end{lstlisting}

If the first section of the pattern (all but {\ft [path]}) is missing, web2py provides a default:
\begin{lstlisting}
'.*?:https?://[^:/]+:[a-z]+'
\end{lstlisting}

The entire expression is matched as a regular expression, so "." must be escaped and any matching subexpression can be captured using {\ft (?P<...>...)} using Python regex syntax. The request method (typically GET or POST) must be lower case. The URL being matched has had any {\ft \%xx} escapes unquoted.

This allows to reroute requests based on the client IP address or domain, based on the type of the request, on the method, and the path. It also allows web2py to map different virtual hosts into different applications. Any matched subexpression can be used to build the target URL and, eventually, passed as a GET variable.

All major web servers, such as Apache and lighttpd, also have the ability to rewrite URLs. In a production environment that may be an option instead of {\ft routes.py}. Whatever you decide to do we strongly suggest that you do not hardcode internal URLs in your app and use the URL function to generate them. This will make your application more portable in case routes should change.

{\bf Application-Specific URL rewrite}

\inxx{routes\_app}
When using the pattern-based system, an application can set its own routes in an application-specific routes.py file located in the applications base folder. This is enabled by configuring {\ft routes\_app} in the base routes.py to determine from an incoming URL the name of the application to be selected. When this happens, the application-specific routes.py is used in place of the base routes.py.

The format of {\ft routes\_app} is identical to {\ft routes\_in}, except that the replacement pattern is simply the application name. If applying {\ft routes\_app} to the incoming URL does not result in an application name, or the resulting application-specific routes.py is not found, the base routes.py is used as usual.

Note: {\ft routes\_app} first appeared in web2py version 1.83.

{\bf Default application, controller, and function}

\inxx{default\_application}
\inxx{default\_controller}
\inxx{default\_function}

When using the pattern-based system, the name of the default application, controller, and function can be changed from {\bf init}, {\bf default}, and {\bf index} respectively to another name by setting the appropriate value in routes.py:
\begin{lstlisting}
default_application = "myapp"
default_controller = "admin"
default_function = "start"
\end{lstlisting}

Note: These items first appeared in web2py version 1.83.

\goodbreak\subsection{Routes on error}

\inxx{routes\_onerror}

You can also use {\ft routes.py} to re-route requests to special actions in case there is an error on the server. You can specify this mapping globally, for each app, for each error code, or for each app and error code. Here is an example:
\begin{lstlisting}
routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]
\end{lstlisting}

For each tuple, the first string is matched against "[app name]/[error code]". If a match is found, the failed request is re-routed to the URL in the second string of the matching tuple. If the error handling URL is a not a static file, the following GET variables will be passed to the error action:
\begin{itemize}
\item {\ft code}: the HTTP status code (e.g., 404, 500)

\item {\ft ticket}: in the form of "[app name]/[ticket number]" (or "None" if no ticket)

\item {\ft requested\_uri}: equivalent to {\ft request.env.request\_uri}

\item {\ft request\_url}: equivalent to {\ft request.url}
\end{itemize}

These variables will be accessible to the error handling action via {\ft request.vars} and can be used in generating the error response. In particular, it is a good idea for the error action to return the original HTTP error code instead of the default 200 (OK) status code. This can be done by setting {\ft response.status = request.vars.code}. It is also possible to have the error action send (or queue) an email to an administrator, including a link to the ticket in {\ft admin}.

Unmatched errors display a default error page. This default error page can also be customized here (see {\ft router.example.py} and {\ft routes.example.py} in the root web2py folder):
\begin{lstlisting}
error_message = '<html><body><h1>%s</h1></body></html>'
error_message_ticket = '''<html><body><h1>Internal error</h1>
     Ticket issued: <a href="/admin/default/ticket/%(ticket)s"
     target="_blank">%(ticket)s</a></body></html>'''
\end{lstlisting}

The first variable contains the error message when an invalid application or function is requested. The second variable contains the error message when a ticket is issued.

{\ft routes\_onerror} work with both routing mechanisms.

\inxx{error\_handler}
In "routes.py" you can also specify an action in charge of error handling:

\begin{lstlisting}
error_handler = dict(application='error',
                      controller='default',
                      function='index')
\end{lstlisting}

If the {\ft error\_handler} is specified the action is called without user redirection and the handler action will be in charge of dealing with the error. In the event that the error-handling page itself returns an error, web2py will fall back to its old static responses.

\goodbreak\subsection{Static asset management}

Since version 2.1.0, web2py has the ability to manage static assets.

When an application is in development, static file can change often, therefore web2py sends static files with no cache headers. This has the side-effect of "forcing" the browser to request static files at every request. This results in low performance when loading the page.

In a "production" site, you may want to serve static files with {\ft cache} headers to prevent un-necessary downloads since static files do not change.

{\ft cache} headers allow the browser to fetch each file only once, thus saving bandwidth and reducing loading time.

Yet there is a problem: What should the cache headers declare? When should the files expire? When the files are first served, the server cannot forecast when they will be changed.

A manual approach consists of creating subfolders for different versions of static files. For example an early version of "layout.css" can be made available at the URL "/myapp/static/css/1.2.3/layout.css". When you change the file, you create a new subfolder and you link it as "/myapp/static/css/1.2.4/layout.css".

This procedure works but it is pedantic since every time you update the css file, you must remember to move it to another folder, change the URL of the file in your layout.html and deploy.

Static asset management solves the problem by allowing the developer to declare a version for a group of static files and they will be requested again only when the version number changes. The version number of made part of the file url as in the previous example. The difference from the previous approach is that the version number only appears in the URL, not in the file system.

If you want to serve "/myapp/static/layout.css" with the cache headers, you just need to include the file with a modified URL that includes a version number:
\begin{lstlisting}
/myapp/static/_1.2.3/layout.css
\end{lstlisting}
(notice the URL defines a version number, it does not appear anywhere else).

Notice that the URL starts with "/myapp/static/", followed by a version number composed by an underscore and 3 integers separated by a period (as described in {\footnotesize\href{http://semver.org/}{SemVer}}), then followed by the filename. Also notice that you do not have to create a "\_1.2.3/" folder.

Every time the static file is requested with a version in the url, it will be served with "far in the future" cache headers, specifically:
\begin{lstlisting}
Cache-Control : max-age=315360000
Expires: Thu, 31 Dec 2037 23:59:59 GMT
\end{lstlisting}
This means that the browser will fetch those files only once, and they will be saved "forever" in the browser's cache.

Every time the "\_1.2.3/filename" is requested, web2py will remove the version part from the path and serve your file with far in the future headers so they will be cached forever. If you changed the version number in the URL, this tricks the browser into thinking it is requesting a different file, and the file is fetched again.

You can use "\_1.2.3", "\_0.0.0", "\_999.888.888", as long as the version starts with underscore followed by three numbers separated by period.

When in development, you can use {\ft response.files.append(...)} to link the static URLs of static files. In this case you can include the "\_1.2.3/" part manually, or you take advantage of a new parameter of the response object: {\ft response.static\_version}.
Just include the files the way you used to, for example
\begin{lstlisting}[keywords={}]
{{response.files.append(URL('static','layout.css'))}}
\end{lstlisting}
and in models set
\begin{lstlisting}
response.static_version = '1.2.3'
\end{lstlisting}
This will rewrite automatically every "/myapp/static/layout.css" url as "/myapp/static/\_1.2.3/layout.css", for every file included in {\ft response.files}.

Often in production you let the webserver (apache, nginx, etc.) serve the static files. You need to adjust your configuration in such a way that it will "skip" the "\_1.2.3/" part.

For example, in Apache, change this:
\begin{lstlisting}
AliasMatch ^/([^/]+)/static/(.*) \
   /home/www-data/web2py/applications/$1/static/$2
\end{lstlisting}
into this:
\begin{lstlisting}
AliasMatch ^/([^/]+)/static/(?:/_[\d]+\.[\d]+\.[\d]+)?(.*) \
   /home/www-data/web2py/applications/$1/static/$2
\end{lstlisting}

Similarly, in Nginx change this:
\begin{lstlisting}
location ~* /(\w+)/static/ {
    root /home/www-data/web2py/applications/;
    expires max;
}
\end{lstlisting}
into this:
\begin{lstlisting}
location ~* /(\w+)/static(?:/_[\d]+\.[\d]+\.[\d]+)?/(.*)$ {
   alias /home/www-data/web2py/applications/$1/static/$2;
   expires max;
}
\end{lstlisting}

\goodbreak\section{Running tasks in the background}

In web2py, every http request is served in its own thread. Threads are recycled for efficiency and managed by the web server. For security, the web server sets a time-out on each request. This means that actions should not run tasks that take too long, should not create new threads, and should not fork processes (it is possible but not recommended).

The proper way to run time-consuming tasks is doing it in the background. There is not a single way of doing it, but here we describe three mechanisms that are built into web2py: {\bf cron}, {\bf homemade task queues}, and {\bf scheduler}.

By {\bf cron} we refer to a web2py functionality not to the Unix Cron mechanism. The web2py cron works on windows too.
\noindent web2py cron is the way to go if you need tasks in the background at scheduled times and these tasks take a relatively short time compared to the time interval between two calls. Each task runs in its own process, and multiple tasks can run concurrently, but you have no control over how many tasks run. If accidentally one task overlaps with itself, it can cause a database lock and a spike in memory usage.
\noindent web2py scheduler takes a different approach. The number of running processes is fixed, and they can run on different machines. Each process is called a worker. Each worker picks a task when available and executes it as soon as possible after the time when it is scheduled to run, but not necessarily at that exact time. There cannot be more processes running than the number of scheduled tasks and therefore no memory spikes. Scheduler tasks can be defined in models and are stored in the database. The web2py scheduler does not implement a distributed queue since it assumes that the time to distribute tasks is negligible compared with the time to run the tasks. Workers pick up the task from the database.

Homemade tasks queues can be a simpler alternative to the web2py scheduler in some cases.

\goodbreak\subsection{Cron}

\inxx{cron}

The web2py cron provides the ability for applications to execute tasks at preset times, in a platform-independent manner.

For each application, cron functionality is defined by a crontab file:

\begin{lstlisting}
app/cron/crontab
\end{lstlisting}

It follows the syntax defined in ref.~\cite{cron} (with some extensions that are specific to web2py).

\begin{quote}Before web2py 2.1.1, cron was enabled by default and could be disabled with the {\ft -N} command line option, Since 2.1.1, cron is disabled by default and can be enabled by the {\ft -Y} option. This change was motivated by the desire to push users toward using the new scheduler (which is superior to the cron mechanism) and also because cron may impact on performance.\end{quote}
This means that every application can have a separate cron configuration and that cron config can be changed from within web2py without affecting the host OS itself.

Here is an example:
\begin{lstlisting}
0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py
\end{lstlisting}

The last two lines in this example use extensions to regular cron syntax to provide additional web2py functionality.

\begin{quote}The file "applications/admin/cron/expire\_sessions.py" actually exists and ships with the {\bf admin} app. It checks for expired sessions and deletes them. "applications/admin/cron/crontab" runs this task hourly.\end{quote}
If the task/script is prefixed with an asterisk ({\ft *}) and ends with {\ft .py}, it will be executed in the web2py environment. This means you will have all the controllers and models at your disposal. If you use two asterisks ({\ft **}), the {\ft MODEL}s will not be executed. This is the recommended way of calling, as it has less overhead and avoids potential locking problems.

Notice that scripts/functions executed in the web2py environment require a manual {\ft db.commit()} at the end of the function or the transaction will be reverted.
\noindent web2py does not generate tickets or meaningful tracebacks in shell mode, which is how cron is run, so make sure that your web2py code runs without errors before you set it up as a cron task as you will likely not be able to see those errors when run from cron. Moreover, be careful how you use models: while the execution happens in a separate process, database locks have to be taken into account in order to avoid pages waiting for cron tasks that may be blocking the database. Use the {\ft **} syntax if you don't need to use the database in your cron task.

You can also call a controller function, in which case there is no need to specify a path. The controller and function will be that of the invoking application. Take special care about the caveats listed above. Example:
\begin{lstlisting}
*/30  *  *  *  *  root *mycontroller/myfunction
\end{lstlisting}

If you specify {\ft @reboot} in the first field in the crontab file, the given task will be executed only once, at web2py startup. You can use this feature if you want to pre-cache, check, or initialize data for an application on web2py startup. Note that cron tasks are executed in parallel with the application --- if the application is not ready to serve requests until the cron task is finished, you should implement checks to reflect this. Example:
\begin{lstlisting}
@reboot  *  *  *  *  root *mycontroller/myfunction
\end{lstlisting}

Depending on how you are invoking web2py, there are four modes of operation for web2py cron.
\begin{itemize}
\item {\it soft cron}: available under all execution modes

\item {\it hard cron}: available if using the built-in web server (either directly or via Apache mod\_proxy)

\item {\it external cron}: available if you have access to the system's own cron service

\item No cron
\end{itemize}

The default is hard cron if you are using the built-in web server; in all other cases, the default is soft cron.  Soft cron is the default method if you are using CGI, FASTCGI or WSGI (but note that soft cron is not {\ft enabled} by default in the standard {\ft wsgihandler.py} file provided with web2py).

Your tasks will be executed on the first call (page load) to web2py after the time specified in crontab; but only after processing the page, so no delay will be observed by the user. Obviously, there is some uncertainty regarding precisely when the task will be executed, depending on the traffic the site receives. Also, the cron task may get interrupted if the web server has a page load timeout set. If these limitations are not acceptable, see {\it external cron}. Soft cron is a reasonable last resort, but if your web server allows other cron methods, they should be preferred over soft cron.

Hard cron is the default if you are using the built-in web server (either directly or via Apache mod\_proxy). Hard cron is executed in a parallel thread, so unlike soft cron, there are no limitations with regard to run time or execution time precision.

External cron is not default in any scenario, but requires you to have access to the system cron facilities. It runs in a parallel process, so none of the limitations of soft cron apply. This is the recommended way of using cron under WSGI or FASTCGI.

Example of line to add to the system crontab, (usually /etc/crontab):
\begin{lstlisting}
0-59/1 * * * * web2py cd /var/www/web2py/ && python web2py.py -J -C -D 1 >> /tmp/cron.output 2>&1
\end{lstlisting}

With external {\ft cron}, make sure to add either {\ft -J} (or {\ft --cronjob}, which is the same) as indicated above so that web2py knows that task is executed by cron. Web2py sets this internally with soft and hard {\ft cron}.

\goodbreak\subsection{Homemade task queues}

While cron is useful to run tasks at regular time intervals, it is not always the best solution to run a background task. For this purpose web2py provides the ability to run any python script as if it were inside a controller:
\begin{lstlisting}
python web2py.py -S app -M -R applications/app/private/myscript.py -A a b c
\end{lstlisting}
\noindent where {\ft -S app} tells web2py to run "myscript.py" as "app", {\ft -M} tells web2py to execute models, and {\ft -A a b c} passes optional command line arguments {\ft sys.args=['a','b','c']} to "myscript.py".

This type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time. With cron it is possible that a process starts at cron iteration 1 and is not completed by cron iteration 2, so cron starts it again, and again, and again - thus jamming the mail server.

In chapter 8, we will provide an example of how to use the above method to send emails.

\goodbreak\subsection{Scheduler (experimental)}

The web2py scheduler works very much like the task queue described in the previous sub-section with some differences:
\begin{itemize}
\item It provides a standard mechanism for creating and scheduling tasks.

\item There is not a single background process but a set of workers processes.

\item The job of worker nodes can be monitored because their state, as well as the state of the tasks, is stored in the database.

\item It works without web2py but that is not documented here.
\end{itemize}

The scheduler does not use cron, although one can use cron @reboot to start the worker nodes.

More information about deploying the scheduler under Linux and Windows is in the Deployment recipes chapter.

In the scheduler, a task is simply a function defined in a model (or in a module and imported by a model). For example:

\begin{lstlisting}
def task_add(a,b):
    return a+b
\end{lstlisting}

Tasks will always be called in the same environment seen by controllers and therefore they see all the global variables defined in models, including database connections ({\ft db}). Tasks differ from a controller action because they are not associated with an HTTP request and therefore there is no {\ft request.env}.

\begin{quote}NB: remind to call db.commit() at the end of every task if it involves inserts/updates to the database. Web2py commits by default at the end of a successful function call but the scheduler doesn't\end{quote}
To enable the scheduler you should put into a model its instantiation.
The recommended way to enable the scheduler to your app is to create a model file named {\ft scheduler.py} and define your function there. After the functions, you can put the following code into the model:

\begin{lstlisting}
from gluon.scheduler import Scheduler
scheduler = Scheduler(db)
\end{lstlisting}

NB: If your tasks are defined in a module (as opposed to a model) you may have to restart the workers.

The task is scheduled with

\begin{lstlisting}
scheduler.queue_task(task_add,pvars=dict(a=1,b=2))
\end{lstlisting}

{\bf Parameters}

The first argument of the {\ft Scheduler} class must be the database to be used by the scheduler to communicate with the workers. This can be the {\ft db} of the app or another dedicated {\ft db}, perhaps one shared by multiple apps. If you use SQLite it's recommended to use a separate db from the one used by your app in order to keep the app responsive.
Once the tasks are defined and the {\ft Scheduler} is instantiated, all that is needed to do is to start the workers. You can do that in several ways:

\begin{lstlisting}
python web2py.py -K myapp
\end{lstlisting}
starts a worker for the app {\ft myapp}. If you want start multiple workers for the same app, you can do so just passing {\ft myapp,myapp}. You can pass also the {\ft group\_names} (overriding the one set in your model) with

\begin{lstlisting}
python web2py.py -K myapp:group1:group2,myotherapp:group1
\end{lstlisting}

If you have a model called {\ft scheduler.py} you can start/stop the workers from web2py's default window (the one you use to set the ip address and the port).

One last nice addition: if you use the embedded webserver, you can start the webserver and the scheduler with just one line of code (this assumes you don't want the web2py window popping up, else you can use the "Schedulers" menu instead)

\begin{lstlisting}
python web2py.py -a yourpass -K myapp -X
\end{lstlisting}
You can pass the usual parameters (-i, -p, here -a prevents the window from showing up), pass whatever app in the -K parameter and append a -X. The scheduler will run alongside the webserver!

Scheduler's complete signature is:

\begin{lstlisting}
Scheduler(
    db,
    tasks=None,
    migrate=True,
    worker_name=None,
    group_names=None,
    heartbeat=HEARTBEAT,
    max_empty_runs=0,
    discard_results=False,
    utc_time=False
)
\end{lstlisting}

Let's see them in order:

\begin{itemize}
\item {\ft db} is the database DAL instance where you want the scheduler tables be placed.

\item {\ft tasks} can be a dict. Must be defined if you want to call a function not by his name, i.e. {\ft tasks=dict(mynameddemo1=task\_add)} will let you execute function demo1 with {\ft scheduler.queue\_task('mynameddemo1')} instead of {\ft scheduler.queue\_task('task\_add')}. If you don't pass this parameter, function will be searched in the app environment.

\item {\ft worker\_name} is None by default. As soon as the worker is started, a worker name is generated as hostname-uuid. If you want to specify that, be sure that it's unique.

\item {\ft group\_names} is by default set to {\bf [main]}. All tasks have a {\ft group\_name} parameter, set to {\bf main} by default. Workers can only pick up tasks of their assigned group.
\end{itemize}

\begin{quote}NB: This is useful if you have different workers instances (e.g. on different machines) and you want to assign tasks to a specific worker.

NB2: It's possible to assign a worker more groups, and they can be also all the same, as\end{quote}{\ft ['mygroup','mygroup']}. Tasks will be distributed taking into consideration that
a worker with group\_names {\ft ['mygroup','mygroup']} is able to process the double of the tasks
a worker with group\_names {\ft ['mygroup']} is.
\begin{itemize}
\item {\ft heartbeat} is by default set to 3 seconds. This parameter is the one controlling how often a scheduler will check its status on the {\ft scheduler\_worker} table and see if there are any {\bf ASSIGNED} tasks to itself to process.

\item {\ft max\_empty\_runs} is 0 by default, that means that the worker will continue to process tasks as soon as they are {\bf ASSIGNED}. If you set this to a value of, let's say, 10, a worker will die automatically if it's {\bf ACTIVE} and no tasks are {\bf ASSIGNED} to it for 10 loops. A loop is when a worker searches for tasks, every 3 seconds (or the set {\ft heartbeat})

\item {\ft discard\_results} is False by default. If set to True, no scheduler\_run records will be created.
\end{itemize}

\begin{quote}NB: scheduler\_run records will be created as before for {\bf FAILED}, {\bf TIMEOUT} and {\bf STOPPED} tasks's statuses.\end{quote}
\begin{itemize}
\item {\ft utc\_time} is False by default. If you need to coordinate with workers living in different timezones, or don't have problems with solar/DST times, supplying datetimes from different countries, etc, you can set this to True. The scheduler will honor the UTC time and work leaving the local time aside. Caveat: you need to schedule tasks with UTC times (for start\_time, stop\_time, and so on.)
\end{itemize}

Now we have the infrastructure in place: defined the tasks, told the scheduler about them, started the worker(s). What remains is to actually schedule the tasks

{\bf Tasks}

Tasks can be scheduled programmatically or via appadmin. In fact, a task is scheduled simply by adding an entry in the table "scheduler\_task", which you can access via appadmin:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/myapp/appadmin/insert/db/scheduler_task
\end{lstlisting}

The meaning of the fields in this table is obvious. The "args" and "vars"" fields are the values to be passed to the task in JSON format. In the case of the "task\_add" above, an example of "args" and "vars" could be:

\begin{lstlisting}
args = [3, 4]
vars = {}
\end{lstlisting}
\noindent or

\begin{lstlisting}
args = []
vars = {'a':3, 'b':4}
\end{lstlisting}

The {\ft scheduler\_task} table is the one where tasks are organized.

All tasks follow a lifecycle


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/ce8edcc3.png}\end{center}


Let's go with order. By default, when you send a task to the scheduler, you'll want that to be executed. It's in {\bf QUEUED} status.
If you need it to be executed later, use the {\ft start\_time} parameter (default = now).
If for some reason you need to be sure that the task don't get executed after a certain point in time (maybe a request to a web service
that shuts down at 1AM, a mail that needs to be sent not after the working hours, etc...) you can set a {\ft stop\_time} (default = None) for it.
If your task is NOT picked up by a worker before stop\_time, it will be set as {\bf EXPIRED}.
Tasks with no stop\_time set or picked up {\bf BEFORE} stop\_time are {\bf ASSIGNED} to a worker. When a workers picks up them, they become {\bf RUNNING}.
{\bf RUNNING} tasks may end up:
\begin{itemize}
\item {\bf TIMEOUT} when more than n seconds passed with {\ft timeout} parameter (default = 60 seconds)

\item {\bf FAILED} when an exception is detected

\item {\bf COMPLETED} when all went ok
\end{itemize}

Values for {\ft start\_time} and {\ft stop\_time} should be datetime objects. To schedule "mytask" to run at 30 seconds from the current time, for example, you would do the following:

\begin{lstlisting}
from datetime import timedelta as timed
scheduler.queue_task('mytask',
    start_time=request.now + timed(seconds=30))
\end{lstlisting}

Additionally, you can control how many times a task should be repeated (i.e. you need to aggregate some data at specified intervals). To do so, set the {\ft repeats}
parameter (default = 1 time only, 0 = unlimited). You can influence how many seconds should pass between executions with the {\ft period} parameter (default = 60 seconds).

\begin{quote}NB: the time is not calculated between the END of the first round and the START of the next, but from the START time of the first round to the START time of the next cycle)\end{quote}
Another nice addition, you can set how many times the function can raise an exception (i.e. requesting data from a slow web service) and be queued again instead of stopping in {\bf FAILED}  status with the parameter {\ft retry\_failed} (default = 0, -1 = unlimited).


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/7d8b85e4.png}\end{center}


Summary: you have
\begin{itemize}
\item {\ft period} and {\ft repeats} to get an automatically rescheduled function

\item {\ft timeout} to be sure that a function doesn't exceed a certain amount of time

\item {\ft retry\_failed} to control how many times the task can "fail"

\item {\ft start\_time} and {\ft stop\_time} to schedule a function in a restricted timeframe
\end{itemize}

{\bf queue\_task() and task\_status()}

\begin{itemize}
\item {\ft scheduler.queue\_task(function, pargs=[], pvars=\{\}, **kwargs)} : accepts a lot of arguments, to make your life easier....
\end{itemize}
-- {\ft function} : required. This can be a string as {\ft 'demo2'} or directly the function, i.e. you can use {\ft scheduler.queue\_task(demo2)}
-- {\ft pargs} : p stands for "positional". pargs will accept your args as a list, without the need to jsonify them first.
\begin{quote}{\ft scheduler.queue\_task(demo1, [1,2])}
\noindent does the exact same thing as

{\ft st.validate\_and\_insert(function\_name = 'demo1', args=dumps([1,2]))}
\noindent and in a lot less characters

{\bf NB}: if you do {\ft scheduler.queue\_task(demo1, [1,2], args=dumps([2,3]))}, {\ft args} will prevail and the task will be queued with {\bf 2,3}\end{quote}-- {\ft pvars} : as with {\ft pargs}, will accept your vars as a dict, without the need to jsonify them first.
\begin{quote}{\ft scheduler.queue\_task(demo1, [], \{'a': 1, 'b' : 2\})} or {\ft scheduler.queue\_task(demo1, pvars=\{'a': 1, 'b' : 2\})}
\noindent does the exact same thing as

{\ft st.validate\_and\_insert(function\_name = 'demo1', vars=dumps(\{'a': 1, 'b' : 2\}))}

{\bf NB}:  if you do {\ft scheduler.queue\_task(demo1, None, \{'a': 1, 'b': 2\}, vars=dumps(\{'a': 2, 'b' : 3\}))}, {\ft vars} will prevail and the task will be queued with {\bf \{'a': 2, 'b' : 3\}}\end{quote}-- {\ft kwargs} : all other scheduler\_task columns can be passed as keywords arguments, e.g. :
... \begin{lstlisting}
       scheduler.queue_task(
          demo1, [1,2], {a: 1, b : 2},
          repeats = 0,
          period = 180,
       ....
      )
\end{lstlisting}
-- since version 2.4.1 if you pass an additional parameter {\ft immediate=True} it will force the main worker to reassign tasks. Until 2.4.1, the worker checks for new tasks every 5 cycles (so, {\ft 5*heartbeats} seconds). If you had an app that needed to check frequently for new tasks, to get a {\it snappy} behaviour you were forced to lower the {\ft heartbeat} parameter, putting the db under pressure for no reason. With {\ft immediate=True} you can force the check for new tasks: it will happen at most as {\ft heartbeat} seconds are passed

The method returns the result of validate\_and\_insert, with the {\ft uuid} of the task you queued (can be the one you passed or the auto-generated one).

{\ft <Row \{'errors': \{\}, 'id': 1, 'uuid': '08e6433a-cf07-4cea-a4cb-01f16ae5f414'\}>}

If there are errors (e.g. you used {\ft period = 'a'}), you'll get the result of the validation, and id and uuid will be None

{\ft <Row \{'errors': \{'period': 'enter an integer greater than or equal to 0'\}, 'id': None, 'uuid': None\}>}

{\bf Results and output}

The table "scheduler\_run" stores the status of all running tasks. Each record references a task that has been picked up by a worker.  One task can have multiple runs. For example, a task scheduled to repeat 10 times an hour will probably have 10 runs (unless one fails or they take longer than 1 hour). Beware that if the task has no return values, it is removed from the scheduler\_run table as soon as it is finished.

Possible run statuses are:

\begin{lstlisting}
RUNNING, COMPLETED, FAILED, TIMEOUT
\end{lstlisting}

If the run is completed, no exceptions are thrown, and there is no task timeout, the run is marked as {\ft COMPLETED} and the task is marked as {\ft QUEUED} or {\ft COMPLETED} depending on whether it is supposed to run again at a later time. The output of the task is serialized in JSON and stored in the run record.

When a {\ft RUNNING} task throws an exception, the run is mark as {\ft FAILED} and the task is marked as {\ft FAILED}. The traceback is stored in the run record.

Similarly, when a run exceeds the timeout, it is stopped and marked as {\ft TIMEOUT}, and the task is marked as {\ft TIMEOUT}.

In any case, the stdout is captured and also logged into the run record.

Using appadmin, one can check all {\ft RUNNING} tasks, the output of {\ft COMPLETED} tasks, the error of {\ft FAILED} tasks, etc.

The scheduler also creates one more table called "scheduler\_worker", which stores the workers' heartbeat and their status. Possible worker statuses are:

{\bf Managing processes}

Worker fine management is hard. This module tries not to leave behind any platform (Mac, Win, Linux).

When you start a worker, you may want later to:
\begin{itemize}
\item kill it "no matter what it's doing"

\item kill it only if it's not processing tasks

\item put it to sleep
\end{itemize}
Maybe you have yet some tasks queued, and you want to save some resources.
You know you want them processed every hour, so, you'll want to:
\begin{itemize}
\item process all queued tasks and die automatically
\end{itemize}
All of these things are possible managing {\ft Scheduler} parameters or the {\ft scheduler\_worker} table.
To be more precise, for started workers you will change the {\ft status} value of any worker to influence
its behavior.
As tasks, workers can be in some fixed statuses : ACTIVE, DISABLED, TERMINATE or KILLED.

{\bf ACTIVE} and {\bf DISABLED} are "persistent", while {\bf TERMINATE} or {\bf KILL}, as statuses
name suggest, are more "commands" than real statuses.
Hitting ctrl+c is equal to set a worker to {\bf KILL}


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/bd891eed.png}\end{center}


There are a few commodity functions since version 2.4.1 (self-explanatory)
\begin{lstlisting}
scheduler.disable()
scheduler.resume()
scheduler.terminate()
scheduler.kill()
\end{lstlisting}
\noindent each function take an optional parameter, that can be a string or a list, to manage workers based on their {\ft group\_names}. It defaults to the {\ft group\_names} defined in the scheduler istantiation.

An example is better than a thousand words: {\ft scheduler.terminate('high\_prio')} will TERMINATE all the workers that are processing the {\ft high\_prio} tasks, while {\ft scheduler.terminate(['high\_prio', 'low\_prio'])} will terminate all {\ft high\_prio} and {\ft low\_prio} workers.
\begin{quote}Watch out: if you have a worker processing {\ft high\_prio} and {\ft low\_prio}, {\ft scheduler.terminate('high\_prio')} will terminate the worker alltogether, even if you didn't want to terminate {\ft low\_prio} too.\end{quote}
Everything that one can do via appadmin one can do programmatically by inserting and updating records in these tables.

Anyway, one should not update records relative to {\ft RUNNING} tasks as this may create an un-expected behavior. The best practice is to queue tasks using the "queue\_task" method.

For example:

\begin{lstlisting}
scheduler.queue_task(
    function_name='task_add',
    pargs=[],
    pvars={'a':3,'b':4},
    repeats = 10, # run 10 times
    period = 3600, # every 1h
    timeout = 120, # should take less than 120 seconds
    )
\end{lstlisting}

Notice that fields "times\_run", "last\_run\_time" and "assigned\_worker\_name" are not provided at schedule time but are filled automatically by the workers.

You can also retrieve the output of completed tasks:

\begin{lstlisting}
completed_runs = db(db.scheduler_run.run_status='COMPLETED').select()
\end{lstlisting}

\begin{quote}The scheduler is experimental because it needs more extensive testing and because the table structure may change as more features are added.\end{quote}
{\bf Reporting percentages}

A special "word" encountered in the print statements of your functions clear all
the previous output. That word is {\ft !clear!}.
This, coupled with the {\ft sync\_output} parameter, allows to report percentages
a breeze. Let's see how that works:

\begin{lstlisting}
def reporting_percentages():
    time.sleep(5)
    print '50%'
    time.sleep(5)
    print '!clear!100%'
    return 1
\end{lstlisting}

The function {\ft reporting\_percentages} sleeps for 5 seconds, outputs {\ft 50\%}.
Then, it sleeps other 5 seconds and outputs {\ft 100\%}. Note that the output in the scheduler\_run table is synced every 2 seconds and that the second print statement that contains {\ft !clear!100\%} gets the {\ft 50\%} output cleared and replaced by {\ft 100\%} only.

\begin{lstlisting}
scheduler.queue_task(reporting_percentages,
                     sync_output=2)
\end{lstlisting}

\goodbreak\section{Third party modules}

\inxx{import}
\noindent web2py is written in Python, so it can import and use any Python module, including third party modules. It just needs to be able to find them. As with any Python application, modules can be installed in the official Python "site-packages" directory, and they can then be imported from anywhere inside your code.

Modules in the "site-packages" directory are, as the name suggests, site-level packages. Applications requiring site-packages are not portable unless these modules are installed separately. The advantage of having modules in "site-packages" is that multiple applications can share them. Let's consider, for example, the plotting package called "matplotlib". You can install it from the shell using the PEAK {\ft easy\_install} command~\cite{easy-install} (or its modern replacement {\ft pip}~\cite{PIP} ):
\begin{lstlisting}
easy_install py-matplotlib
\end{lstlisting}
\noindent and then you can import it into any model/controller/view with:
\begin{lstlisting}
import matplotlib
\end{lstlisting}

The web2py source distribution, and the Windows binary distribution has a site-packages in the top-level folder. The Mac binary distribution has a site-packages folder in the folder:

{\ft web2py.app/Contents/Resources/site-packages}

The problem with using site-packages is that it becomes difficult to use different versions of a single module at the same time, for example there could be two applications but each one uses a different version of the same file.  In this example, {\ft sys.path} cannot be altered because it would affect both applications.

For this kind of situation, web2py provides another way to import modules in such a way that the global {\ft sys.path} is not altered: by placing them in the "modules" folder of an application. One side benefit is that the module will be automatically copied and distributed with the application.

\begin{quote}Once a module "mymodule.py" is placed into an app "modules/" folder, it can be imported from anywhere inside a web2py application (without need to alter {\ft sys.path} with):
\begin{lstlisting}
import mymodule
\end{lstlisting}\end{quote}
\goodbreak\section{Execution environment}

\inxx{exec\_environment}

\begin{quote}While everything discussed here works fine, we recommend instead building your application using components, as described in chapter 12.\end{quote}
web2py model and controller files are not Python modules in that they cannot be imported using the Python {\ft import} statement. The reason for this is that models and controllers are designed to be executed in a prepared environment that has been pre-populated with web2py global objects (request, response, session, cache and T) and helper functions. This is necessary because Python is a statically (lexically) scoped language, whereas the web2py environment is created dynamically.
\noindent web2py provides the {\ft exec\_environment} function to allow you to access models and controllers directly. {\ft exec\_environment} creates a web2py execution environment, loads the file into it and then returns a Storage object containing the environment. The Storage object also serves as a namespace mechanism. Any Python file designed to be executed in the execution environment can be loaded using {\ft exec\_environment}. Uses for {\ft exec\_environment} include:
\begin{itemize}
\item Accessing data (models) from other applications.

\item Accessing global objects from other models or controllers.

\item Executing controller functions from other controllers.

\item Loading site-wide helper libraries.
\end{itemize}

This example reads rows from the {\ft user} table in the {\ft cas} application:
\begin{lstlisting}
from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)
\end{lstlisting}

Another example: suppose you have a controller "other.py" that contains:
\begin{lstlisting}
def some_action():
    return dict(remote_addr=request.env.remote_addr)
\end{lstlisting}

Here is how you can call this action from another controller (or from the web2py shell):
\begin{lstlisting}
from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()
\end{lstlisting}

In line 2, {\ft request=request} is optional. It has the effect of passing the current request to the environment of "other". Without this argument, the environment would contain a new and empty (apart from {\ft request.folder}) request object. It is also possible to pass a response and a session object to {\ft exec\_environment}. Be careful when passing request, response and session objects --- modification by the called action or coding dependencies in the called action could lead to unexpected side effects.

The function call in line 3 does not execute the view; it simply returns the dictionary unless {\ft response.render} is called explicitly by "some\_action".

One final caution: don't use {\ft exec\_environment} inappropriately. If you want the results of actions in another application, you probably should implement an XML-RPC API (implementing an XML-RPC API with web2py is almost trivial). Don't use {\ft exec\_environment} as a redirection mechanism; use the {\ft redirect} helper.

\goodbreak\section{Cooperation}

\inxx{cooperation}

There are many ways applications can cooperate:
\begin{itemize}
\item Applications can connect to the same database and thus share tables. It is not necessary that all tables in the database are defined by all applications, but they must be defined by those applications that use them. All applications that use the same table, but one, must define the table with {\ft migrate=False}.

\item Applications can embed components from other applications using the LOAD helper (described in Chapter 12).

\item Applications can share sessions.

\item Applications can call each other's actions remotely via XML-RPC.

\item Applications can access each other's files via the filesystem (assuming they share the same filesystem).

\item Applications can call each other's actions locally using {\ft exec\_environment} as discussed above.

\item Applications can import each other's modules using the syntax:
\end{itemize}
\begin{lstlisting}
from applications.appname.modules import mymodule
\end{lstlisting}

\begin{itemize}
\item Applications can import any module in the {\ft PYTHONPATH} search path, {\ft sys.path}.
\end{itemize}

One app can load the session of another app using the command:

\begin{lstlisting}
session.connect(request, response, masterapp='appname', db=db)
\end{lstlisting}

Here "appname" is the name of the master application, the one that sets the initial session\_id in the cookie. {\ft db} is a database connection to the database that contains the session table ({\ft web2py\_session}). All apps that share sessions must use the same database for session storage.

One application can load a module from another app using

\begin{lstlisting}
import applications.otherapp.modules.othermodule
\end{lstlisting}

\goodbreak\section{Logging}

Python provides logging APIs. Web2py provides a mechanism to configure it so
that apps can use it.

In your application, you can create a logger, for example in a model:

\begin{lstlisting}
import logging
logger = logging.getLogger("web2py.app.myapp")
logger.setLevel(logging.DEBUG)
\end{lstlisting}
\noindent and you can use it to log messages of various importance

\begin{lstlisting}
logger.debug("Just checking that %s" % details)
logger.info("You ought to know that %s" % details)
logger.warn("Mind that %s" % details)
logger.error("Oops, something bad happened %s" % details)
\end{lstlisting}

{\ft logging} is a standard python module described here:
\begin{lstlisting}[keywords={}]
http://docs.python.org/library/logging.html
\end{lstlisting}
The string "web2py.app.myapp" defines an app-level logger.

For this to work properly, you need a configuration file for the logger.
One is provided by web2py in the root web2py folder "logging.example.conf". You need to rename the file "logging.conf" and customize it as necessary.

This file is self documenting, so you should open it and read it.

To create a configurable logger for application "myapp", you must add myapp to
the [loggers] keys list:

\begin{lstlisting}
[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,myapp
\end{lstlisting}
\noindent and you must add a [logger\_myapp] section, using [logger\_welcome] as a starting point.

\begin{lstlisting}
[logger_myapp]
level=WARNING
qualname=web2py.app.myapp
handlers=consoleHandler
propagate=0
\end{lstlisting}

The "handlers" directive specifies the type of logging and here it is logging "myapp" to the console.

\goodbreak\section{WSGI}

\inxx{WSGI}
\noindent web2py and WSGI have a love-hate relationship. Our perspective is that WSGI was developed as a protocol to connect web servers to web applications in a portable way, and we use it for that purpose. web2py at its core is a WSGI application: {\ft gluon.main.wsgibase}. Some developers have pushed WSGI to its limits as a protocol for middleware communications and develop web applications as an onion with many layers (each layer being a WSGI middleware developed independently of the entire framework). web2py does not adopt this structure internally. This is because we feel the core functionality of a frameworks (handling cookies, session, errors, transactions, dispatching) can be better optimized for speed and security if they are handled by a single comprehensive layer.

Yet web2py allows you to use third party WSGI applications and middleware in three ways (and their combinations):
\begin{itemize}
\item You can edit the file "wsgihandler.py" and include any third party WSGI middleware.

\item You can connect third party WSGI middleware to any specific action in your apps.

\item You can call a third party WSGI app from your actions.
\end{itemize}

The only limitation is that you cannot use third party middleware to replace core web2py functions.

\goodbreak\subsection{External middleware}

Consider the file "wsgibase.py":
\begin{lstlisting}
#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase
\end{lstlisting}

When {\ft LOGGING} is set to {\ft True}, {\ft gluon.main.wsgibase} is wrapped by the middleware function {\ft gluon.main.appfactory}. It provides logging to the "httpserver.log" file. In a similar fashion you can add any third party middleware. We refer to the official WSGI documentation for more details.

\goodbreak\subsection{Internal middleware}

Given any action in your controllers (for example {\ft index}) and any third party middleware application (for example {\ft MyMiddleware}, which converts output to upper case), you can use a web2py decorator to apply the middleware to that action. Here is an example:
\begin{lstlisting}
class MyMiddleware:
    """converts output to upper case"""
    def __init__(self,app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'
\end{lstlisting}

We cannot promise that all third party middleware will work with this mechanism.

\goodbreak\subsection{Calling {\it WSGI} applications}

It is easy to call WSGI app from a web2py action. Here is an example:
\begin{lstlisting}
def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that calls the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()
\end{lstlisting}

In this case, the {\ft index} action calls {\ft test\_wsgi\_app} and escapes the returned value before returning it. Notice that {\ft index} is not itself a WSGI app and it must use the normal web2py API (such as {\ft response.write} to write to the socket).

\goodbreak\chapter{The views}

\inxx{views} \inxx{template language} \inxx{HTML}
\noindent web2py uses Python for its models, controllers, and views, although it uses a slightly modified Python syntax in the views to allow more readable code without imposing any restrictions on proper Python usage.

The purpose of a view is to embed code (Python) in an HTML document. In general, this poses some problems:
\begin{itemize}
\item How should embedded code be escaped?

\item Should indenting be based on Python or HTML rules?
\end{itemize}
\noindent web2py uses {\ft \{\{ ... \}\}} to escape Python code embedded in HTML. The advantage of using curly brackets instead of angle brackets is that it's transparent to all common HTML editors. This allows the developer to use those editors to create web2py views. These delimiters can be changed for example with

\begin{lstlisting}
response.delimiters = ('<?','?>')
\end{lstlisting}

If this line is in a model it will be applied everywhere, if in a controller only to views for the controller actions, if inside an action only to the view for that action.

Since the developer is embedding Python code into HTML, the document should be indented according to HTML rules, and not Python rules. Therefore, we allow unindented Python inside the {\ft \{\{ ... \}\}} tags. Since Python normally uses indentation to delimit blocks of code, we need a different way to delimit them; this is why the web2py template language makes use of the Python keyword {\ft pass}.

\begin{quote}A code block starts with a line ending with a colon and ends with a line beginning with {\ft pass}. The keyword {\ft pass} is not necessary when the end of the block is obvious from the context.\end{quote}
Here is an example:

\begin{lstlisting}[keywords={}]
{{
if i == 0:
response.write('i is 0')
else:
response.write('i is not 0')
pass
}}
\end{lstlisting}

Note that {\ft pass} is a Python keyword, not a web2py keyword. Some Python editors, such as Emacs, use the keyword {\ft pass} to signify the division of blocks and use it to re-indent code automatically.

The web2py template language does exactly the same. When it finds something like:

\begin{lstlisting}[keywords={}]
<html><body>
{{for x in range(10):}}{{=x}}hello<br />{{pass}}
</body></html>
\end{lstlisting}
\noindent it translates it into a program:
\begin{lstlisting}
response.write("""<html><body>""", escape=False)
for x in range(10):
    response.write(x)
    response.write("""hello<br />""", escape=False)
response.write("""</body></html>""", escape=False)
\end{lstlisting}
{\ft response.write} writes to the {\ft response.body}.

When there is an error in a web2py view, the error report shows the generated view code, not the actual view as written by the developer. This helps the developer debug the code by highlighting the actual code that is executed (which is something that can be debugged with an HTML editor or the DOM inspector of the browser).

Also note that:
\begin{lstlisting}[keywords={}]
{{=x}}
\end{lstlisting}
\noindent generates
\inxx{response.write} \inxx{escape}
\begin{lstlisting}
response.write(x)
\end{lstlisting}

Variables injected into the HTML in this way are escaped by default.
The escaping is ignored if {\ft x} is an {\ft XML} object, even if escape is set to {\ft True}.

Here is an example that introduces the {\ft H1} helper:
\begin{lstlisting}[keywords={}]
{{=H1(i)}}
\end{lstlisting}
\noindent which is translated to:
\begin{lstlisting}
response.write(H1(i))
\end{lstlisting}
\noindent upon evaluation, the {\ft H1} object and its components are recursively serialized, escaped and written to the response body. The tags generated by {\ft H1} and inner HTML are not escaped. This mechanism guarantees that all text --- and only text --- displayed on the web page is always escaped, thus preventing XSS vulnerabilities. At the same time, the code is simple and easy to debug.

The method {\ft response.write(obj, escape=True)} takes two arguments, the object to be written and whether it has to be escaped (set to {\ft True} by default). If {\ft obj} has an {\ft .xml()} method, it is called and the result written to the response body (the {\ft escape} argument is ignored). Otherwise it uses the object's {\ft \_\_str\_\_} method to serialize it and, if the escape argument is {\ft True}, escapes it. All built-in helper objects ({\ft H1} in the example) are objects that know how to serialize themselves via the {\ft .xml()} method.

This is all done transparently. You never need to (and never should) call the {\ft response.write} method explicitly.

\goodbreak\section{Basic syntax}

The web2py template language supports all Python control structures. Here we provide some examples of each of them. They can be nested according to usual programming practice.

\goodbreak\subsection{{\ft for...in}}

\inxx{for}

In templates you can loop over any iterable object:
\begin{lstlisting}[keywords={}]
{{items = ['a', 'b', 'c']}}
<ul>
{{for item in items:}}<li>{{=item}}</li>{{pass}}
</ul>
\end{lstlisting}
\noindent which produces:
\begin{lstlisting}[keywords={}]
<ul>
<li>a</li>
<li>b</li>
<li>c</li>
</ul>
\end{lstlisting}

Here {\ft item} is any iterable object such as a Python list, Python tuple, or Rows object, or any object that is implemented as an iterator. The elements displayed are first serialized and escaped.

\goodbreak\subsection{{\ft while}}

\inxx{while}

You can create a loop using the while keyword:
\begin{lstlisting}[keywords={}]
{{k = 3}}
<ul>
{{while k > 0:}}<li>{{=k}}{{k = k - 1}}</li>{{pass}}
</ul>
\end{lstlisting}
\noindent which produces:
\begin{lstlisting}[keywords={}]
<ul>
<li>3</li>
<li>2</li>
<li>1</li>
</ul>
\end{lstlisting}

\goodbreak\subsection{{\ft if...elif...else}}

\inxx{if} \inxx{elif} \inxx{else}

You can use conditional clauses:
\begin{lstlisting}[keywords={}]
{{
import random
k = random.randint(0, 100)
}}
<h2>
{{=k}}
{{if k % 2:}}is odd{{else:}}is even{{pass}}
</h2>
\end{lstlisting}
\noindent which produces:
\begin{lstlisting}[keywords={}]
<h2>
45 is odd
</h2>
\end{lstlisting}

Since it is obvious that {\ft else} closes the first {\ft if} block, there is no need for a {\ft pass} statement, and using one would be incorrect. However, you must explicitly close the {\ft else} block with a {\ft pass}.

Recall that in Python "else if" is written {\ft elif} as in the following example:
\begin{lstlisting}[keywords={}]
{{
import random
k = random.randint(0, 100)
}}
<h2>
{{=k}}
{{if k % 4 == 0:}}is divisible by 4
{{elif k % 2 == 0:}}is even
{{else:}}is odd
{{pass}}
</h2>
\end{lstlisting}

It produces:
\begin{lstlisting}[keywords={}]
<h2>
64 is divisible by 4
</h2>
\end{lstlisting}

\goodbreak\subsection{{\ft try...except...else...finally}}

\inxx{try} \inxx{except} \inxx{else} \inxx{finally}

It is also possible to use {\ft try...except} statements in views with one caveat. Consider the following example:
\begin{lstlisting}[keywords={}]
{{try:}}
Hello {{= 1 / 0}}
{{except:}}
division by zero
{{else:}}
no division by zero
{{finally}}
<br />
{{pass}}
\end{lstlisting}

It will produce the following output:
\begin{lstlisting}
Hello
division by zero
<br />
\end{lstlisting}

This example illustrates that all output generated before an exception occurs is rendered (including output that preceded the exception) inside the try block. "Hello" is written because it precedes the exception.

\goodbreak\subsection{{\ft def...return}}

\inxx{def} \inxx{return}

The web2py template language allows the developer to define and implement functions that can return any Python object or a text/html string. Here we consider two examples:
\begin{lstlisting}[keywords={}]
{{def itemize1(link): return LI(A(link, _href="http://" + link))}}
<ul>
{{=itemize1('www.google.com')}}
</ul>
\end{lstlisting}
\noindent produces the following output:
\begin{lstlisting}[keywords={}]
<ul>
<li><a href="http:/www.google.com">www.google.com</a></li>
</ul>
\end{lstlisting}

The function {\ft itemize1} returns a helper object that is inserted at the location where the function is called.

Consider now the following code:
\begin{lstlisting}[keywords={}]
{{def itemize2(link):}}
<li><a href="http://{{=link}}">{{=link}}</a></li>
{{return}}
<ul>
{{itemize2('www.google.com')}}
</ul>
\end{lstlisting}

It produces exactly the same output as above. In this case, the function {\ft itemize2} represents a piece of HTML that is going to replace the web2py tag where the function is called. Notice that there is no '=' in front of the call to {\ft itemize2}, since the function does not return the text, but it writes it directly into the response.

There is one caveat: functions defined inside a view must terminate with a return statement, or the automatic indentation will fail.

\goodbreak\section{HTML helpers}

\inxx{helpers}

Consider the following code in a view:
\begin{lstlisting}[keywords={}]
{{=DIV('this', 'is', 'a', 'test', _id='123', _class='myclass')}}
\end{lstlisting}
\noindent it is rendered as:
\begin{lstlisting}[keywords={}]
<div id="123" class="myclass">thisisatest</div>
\end{lstlisting}
{\ft DIV} is a helper class, i.e., something that can be used to build HTML programmatically. It corresponds to the HTML {\ft <div>} tag.

Positional arguments are interpreted as objects contained between the open and close tags. Named arguments that start with an underscore are interpreted as HTML tag attributes (without the underscore). Some helpers also have named arguments that do not start with underscore; these arguments are tag-specific.

Instead of a set of unnamed arguments, a helper can also take a single list or tuple as its set of components using the {\ft *} notation and it can take a single dictionary as its set of attributes using the {\ft **}, for example:
\begin{lstlisting}[keywords={}]
{{
contents = ['this','is','a','test']
attributes = {'_id':'123', '_class':'myclass'}
=DIV(*contents,**attributes)
}}
\end{lstlisting}
(produces the same output as before).

The following set of helpers:

{\ft A},  {\ft B},  {\ft BEAUTIFY},  {\ft BODY},  {\ft BR},  {\ft CAT},  {\ft CENTER},  {\ft CODE},  {\ft COL}, {\ft COLGROUP}, {\ft DIV},  {\ft EM},  {\ft EMBED},  {\ft FIELDSET},  {\ft FORM},  {\ft H1},  {\ft H2},  {\ft H3},  {\ft H4},  {\ft H5},  {\ft H6},  {\ft HEAD},  {\ft HR},  {\ft HTML},  {\ft I},  {\ft IFRAME},  {\ft IMG},  {\ft INPUT},  {\ft LABEL},  {\ft LEGEND},  {\ft LI},  {\ft LINK},  {\ft MARKMIN},  {\ft MENU},  {\ft META},  {\ft OBJECT},  {\ft ON},  {\ft OL},  {\ft OPTGROUP},  {\ft OPTION},  {\ft P},  {\ft PRE},  {\ft SCRIPT},  {\ft SELECT},  {\ft SPAN},  {\ft STYLE},  {\ft TABLE},  {\ft TAG},  {\ft TBODY},  {\ft TD},  {\ft TEXTAREA},  {\ft TFOOT},  {\ft TH},  {\ft THEAD},  {\ft TITLE},  {\ft TR},  {\ft TT}, {\ft UL},   {\ft URL},  {\ft XHTML},  {\ft XML},  {\ft embed64},  {\ft xmlescape}
\noindent can be used to build complex expressions that can then be serialized to XML~\cite{xml-w}~\cite{xml-o}. For example:
\begin{lstlisting}[keywords={}]
{{=DIV(B(I("hello ", "<world>"))), _class="myclass")}}
\end{lstlisting}
\noindent is rendered:
\begin{lstlisting}[keywords={}]
<div class="myclass"><b><i>hello &lt;world&gt;</i></b></div>
\end{lstlisting}

Helpers can also be serialized into strings, equivalently, with the {\ft \_\_str\_\_} and the {\ft xml} methods:

\begin{lstlisting}
>>> print str(DIV("hello world"))
<div>hello world</div>
>>> print DIV("hello world").xml()
<div>hello world</div>
\end{lstlisting}

\inxx{Document Object Model (DOM)}
The helpers mechanism in web2py is more than a system to generate HTML without concatenating strings. It provides a server-side representation of the Document Object Model (DOM).

Components of helpers can be referenced via their position, and helpers act as lists with respect to their components:
\begin{lstlisting}
>>> a = DIV(SPAN('a', 'b'), 'c')
>>> print a
<div><span>ab</span>c</div>
>>> del a[1]
>>> a.append(B('x'))
>>> a[0][0] = 'y'
>>> print a
<div><span>yb</span><b>x</b></div>
\end{lstlisting}

Attributes of helpers can be referenced by name, and helpers act as dictionaries with respect to their attributes:
\begin{lstlisting}
>>> a = DIV(SPAN('a', 'b'), 'c')
>>> a['_class'] = 's'
>>> a[0]['_class'] = 't'
>>> print a
<div class="s"><span class="t">ab</span>c</div>
\end{lstlisting}

Note, the complete set of components can be accessed via a list called {\ft a.components}, and the complete set of attributes can be accessed via a dictionary called {\ft a.attributes}. So, {\ft a[i]} is equivalent to {\ft a.components[i]} when {\ft i} is an integer, and {\ft a[s]} is equivalent to {\ft a.attributes[s]} when {\ft s} is a string.

Notice that helper attributes are passed as keyword arguments to the helper. In some cases, however, attribute names include special characters that are not allowed in Python identifiers (e.g., hyphens) and therefore cannot be used as keyword argument names. For example:

\begin{lstlisting}
DIV('text', _data-role='collapsible')
\end{lstlisting}
\noindent will not work because "\_data-role" includes a hyphen, which will produce a Python syntax error.

In such cases, you can instead pass the attributes as a dictionary and make use of Python's {\ft **} function arguments notation, which map a dictionary of (key:value) pairs into a set of keyword arguments:

\begin{lstlisting}
>>> print DIV('text', **{'_data-role': 'collapsible'})
<div data-role="collapsible">text</div>
\end{lstlisting}

You can also dynamically create special TAGs:

\begin{lstlisting}
>>> print TAG['soap:Body']('whatever',**{'_xmlns:m':'http://www.example.org'})
<soap:Body xmlns:m="http://www.example.org">whatever</soap:Body>
\end{lstlisting}

\goodbreak\subsection{{\ft XML}}

\inxx{XML}
{\ft XML} is an object used to encapsulate text that should not be escaped. The text may or may not contain valid XML. For example, it could contain JavaScript.

The text in this example is escaped:
\begin{lstlisting}
>>> print DIV("<b>hello</b>")
&lt;b&gt;hello&lt;/b&gt;
\end{lstlisting}
\noindent by using {\ft XML} you can prevent escaping:
\begin{lstlisting}
>>> print DIV(XML("<b>hello</b>"))
<b>hello</b>
\end{lstlisting}

Sometimes you want to render HTML stored in a variable, but the HTML may contain unsafe tags such as scripts:
\begin{lstlisting}
>>> print XML('<script>alert("unsafe!")</script>')
<script>alert("unsafe!")</script>
\end{lstlisting}

Un-escaped executable input such as this (for example, entered in the body of a comment in a blog) is unsafe, because it can be used to generate Cross Site Scripting (XSS) attacks against other visitors to the page.

\inxx{sanitize}
The web2py {\ft XML} helper can sanitize our text to prevent injections and escape all tags except those that you explicitly allow. Here is an example:
\begin{lstlisting}
>>> print XML('<script>alert("unsafe!")</script>', sanitize=True)
&lt;script&gt;alert(&quot;unsafe!&quot;)&lt;/script&gt;
\end{lstlisting}

The {\ft XML} constructors, by default, consider the content of some tags and some of their attributes safe. You can override the defaults using the optional {\ft permitted\_tags} and {\ft allowed\_attributes} arguments. Here are the default values of the optional arguments of the {\ft XML} helper.
\begin{lstlisting}
XML(text, sanitize=False,
    permitted_tags=['a', 'b', 'blockquote', 'br/', 'i', 'li',
       'ol', 'ul', 'p', 'cite', 'code', 'pre', 'img/'],
    allowed_attributes={'a':['href', 'title'],
       'img':['src', 'alt'], 'blockquote':['type']})
\end{lstlisting}

\goodbreak\subsection{Built-in helpers}

{\bf {\ft A}}

This helper is used to build links.

\inxx{A}
\begin{lstlisting}
>>> print A('<click>', XML('<b>me</b>'),
            _href='http://www.web2py.com')
<a href='http://www.web2py.com'>&lt;click&gt;<b>me/b></a>
\end{lstlisting}

Instead of {\ft \_href} you can pass the URL using the {\ft callback} argument. For example in a view:

\begin{lstlisting}[keywords={}]
{{=A('click me', callback=URL('myaction'))}}
\end{lstlisting}
\noindent and the effect of pressing the link will be an ajax call to "myaction" instead of a redirection.
In this case, optionally you can specify two more arguments: {\ft target} and {\ft delete}:
\begin{lstlisting}[keywords={}]
{{=A('click me', callback=URL('myaction'), target="t")}}
<div id="t"><div>
\end{lstlisting}
and the response of the ajax callback will be stored in the DIV with id equal to "t".

\begin{lstlisting}[keywords={}]
<div id="b">{{=A('click me', callback=URL('myaction'), delete='div#b")}}</div>
\end{lstlisting}
and upon response, the closest tag matching "div\#b" will be deleted. In this case, the button will be deleted.
A typical application is:

\begin{lstlisting}[keywords={}]
{{=A('click me', callback=URL('myaction'), delete='tr")}}
\end{lstlisting}
\noindent in a table. Pressing the button will perform the callback and delete the table row.

{\ft callback} and {\ft delete} can be combined.

The A helper takes a special argument called {\ft cid}. It works as follows:

\begin{lstlisting}[keywords={}]
{{=A('linked page', _href='http://example.com', cid='myid')}}
<div id="myid"></div>
\end{lstlisting}
\noindent and a click on the link causes the content to be loaded in the div. This is similar but more powerful than the above syntax since it is designed to refresh page components. We discuss applications of {\ft cid} in more detail in Chapter 12, in the context of components.

These ajax features require jQuery and "static/js/web2py\_ajax.js", which are automatically included by placing {\ft \{\{include 'web2py\_ajax.html'\}\}} in the layout head. "views/web2py\_ajax.html" defines some variables based on {\ft request} and includes all necessary js and css files.

{\bf {\ft B}}

\inxx{B}

This helper makes its contents bold.
\begin{lstlisting}
>>> print B('<hello>', XML('<i>world</i>'), _class='test', _id=0)
<b id="0" class="test">&lt;hello&gt;<i>world</i></b>
\end{lstlisting}

{\bf {\ft BODY}}

\inxx{BODY}
This helper makes the body of a page.
\begin{lstlisting}
>>> print BODY('<hello>', XML('<b>world</b>'), _bgcolor='red')
<body bgcolor="red">&lt;hello&gt;<b>world</b></body>
\end{lstlisting}

{\bf {\ft BR}}

\inxx{BR}

This helper creates a line break.
\begin{lstlisting}
>>> print BR()
<br />
\end{lstlisting}

Notice that helpers can be repeated using the multiplication operator:

\begin{lstlisting}
>>> print BR()*5
<br /><br /><br /><br /><br />
\end{lstlisting}

{\bf {\ft CAT}}

\inxx{CAT}

This helper concatenates other helpers, same as TAG[''].
\begin{lstlisting}
>>> print CAT('Here is a ', A('link',_href=URL()), ', and here is some ', B('bold text'), '.')
Here is a <a href="/app/default/index">link</a>, and here is some <b>bold text</b>.
\end{lstlisting}

{\bf {\ft CENTER}}

\inxx{CENTER}

This helper centers its content.
\begin{lstlisting}
>>> print CENTER('<hello>', XML('<b>world</b>'),
>>>              _class='test', _id=0)
<center id="0" class="test">&lt;hello&gt;<b>world</b></center>
\end{lstlisting}

{\bf {\ft CODE}}

\inxx{CODE}

This helper performs syntax highlighting for Python, C, C++, HTML and web2py code, and is preferable to {\ft PRE} for code listings. {\ft CODE} also has the ability to create links to the web2py API documentation.

Here is an example of highlighting sections of Python code.
\begin{lstlisting}
>>> print CODE('print "hello"', language='python').xml()
<table><tr valign="top"><td style="width:40px; text-align: right;"><pre style="
        font-size: 11px;
        font-family: Bitstream Vera Sans Mono,monospace;
        background-color: transparent;
            margin: 0;
            padding: 5px;
            border: none;
        background-color: #E0E0E0;
        color: #A0A0A0;
    ">1.</pre></td><td><pre style="
        font-size: 11px;
        font-family: Bitstream Vera Sans Mono,monospace;
        background-color: transparent;
            margin: 0;
            padding: 5px;
            border: none;
            overflow: auto;
    "><span style="color:#185369; font-weight: bold">print </span>
    <span style="color: #FF9966">"hello"</span></pre></td></tr>
</table>
\end{lstlisting}

Here is a similar example for HTML
\begin{lstlisting}
>>> print CODE(
>>>   '<html><body>{{=request.env.remote_add}}</body></html>',
>>>   language='html')
\end{lstlisting}
\begin{lstlisting}[keywords={}]
<table>...<code>...
<html><body>{{=request.env.remote_add}}</body></html>
...</code>...</table>
\end{lstlisting}

These are the default arguments for the {\ft CODE} helper:
\begin{lstlisting}
CODE("print 'hello world'", language='python', link=None, counter=1, styles={})
\end{lstlisting}

Supported values for the {\ft language} argument are "python", "html\_plain", "c", "cpp", "web2py", and "html". The "html" language interprets \{\{ and \}\} tags as "web2py" code, while "html\_plain" doesn't.

If a {\ft link} value is specified, for example "/examples/global/vars/", web2py API references in the code are linked to documentation at the link URL. For example "request" would be linked to "/examples/global/vars/request". In the above example, the link URL is handled by the "vars" action in the "global.py" controller that is distributed as part of the web2py "examples" application.

The {\ft counter} argument is used for line numbering. It can be set to any of three different values. It can be {\ft None} for no line numbers, a numerical value specifying the start number, or a string. If the counter is set to a string, it is interpreted as a prompt, and there are no line numbers.

The {\ft styles} argument is a bit tricky. If you look at the generated HTML above, it contains a table with two columns, and each column has its own style declared inline using CSS. The {\ft styles} attributes allows you to override those two CSS styles. For example:

\begin{lstlisting}[keywords={}]
{{=CODE(...,styles={'CODE':'margin: 0;padding: 5px;border: none;'})}}
\end{lstlisting}

The {\ft styles} attribute must be a dictionary, and it allows two possible keys: {\ft CODE} for the style of the actual code, and {\ft LINENUMBERS} for the style of the left column, which contains the line numbers. Mind that these styles completely replace the default styles and are not simply added to them.

{\bf {\ft COL}}

\inxx{COL}

\begin{lstlisting}
>>> print COL('a','b')
<col>ab</col>
\end{lstlisting}

{\bf {\ft COLGROUP}}

\inxx{COLGROUP}

\begin{lstlisting}
>>> print COLGROUP('a','b')
<colgroup>ab</colgroup>
\end{lstlisting}

{\bf {\ft DIV}}

All helpers apart from {\ft XML} are derived from {\ft DIV} and inherit its basic methods.

\inxx{DIV}
\begin{lstlisting}
>>> print DIV('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<div id="0" class="test">&lt;hello&gt;<b>world</b></div>
\end{lstlisting}

{\bf {\ft EM}}

Emphasizes its content.

\inxx{EM}
\begin{lstlisting}
>>> print EM('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<em id="0" class="test">&lt;hello&gt;<b>world</b></em>
\end{lstlisting}

{\bf {\ft FIELDSET}}

\inxx{FIELDSET}

This is used to create an input field together with its label.
\begin{lstlisting}
>>> print FIELDSET('Height:', INPUT(_name='height'), _class='test')
<fieldset class="test">Height:<input name="height" /></fieldset>
\end{lstlisting}

{\bf {\ft FORM}}

\inxx{FORM}

This is one of the most important helpers. In its simple form, it just makes a {\ft <form>...</form>} tag, but because helpers are objects and have knowledge of what they contain, they can process submitted forms (for example, perform validation of the fields). This will be discussed in detail in Chapter 7.
\begin{lstlisting}
>>> print FORM(INPUT(_type='submit'), _action='', _method='post')
<form enctype="multipart/form-data" action="" method="post">
<input type="submit" /></form>
\end{lstlisting}

The "enctype" is "multipart/form-data" by default.

\inxx{hidden}
The constructor of a {\ft FORM}, and of {\ft SQLFORM}, can also take a special argument called {\ft hidden}. When a dictionary is passed as {\ft hidden}, its items are translated into "hidden" INPUT fields. For example:
\begin{lstlisting}
>>> print FORM(hidden=dict(a='b'))
<form enctype="multipart/form-data" action="" method="post">
<input value="b" type="hidden" name="a" /></form>
\end{lstlisting}

{\bf {\ft H1}, {\ft H2}, {\ft H3}, {\ft H4}, {\ft H5}, {\ft H6}}

\inxx{H1}

These helpers are for paragraph headings and subheadings:
\begin{lstlisting}
>>> print H1('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<h1 id="0" class="test">&lt;hello&gt;<b>world</b></h1>
\end{lstlisting}

{\bf {\ft HEAD}}

For tagging the HEAD of an HTML page.

\inxx{HEAD}
\begin{lstlisting}
>>> print HEAD(TITLE('<hello>', XML('<b>world</b>')))
<head><title>&lt;hello&gt;<b>world</b></title></head>
\end{lstlisting}

{\bf {\ft HTML}}

\inxx{HTML} \inxx{XHTML}

This helper is a little different. In addition to making the {\ft <html>} tags,
it prepends the tag with a doctype string~\cite{xhtml-w,xhtml-o,xhtml-school}.
\begin{lstlisting}
>>> print HTML(BODY('<hello>', XML('<b>world</b>')))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                      "http://www.w3.org/TR/html4/loose.dtd">
<html><body>&lt;hello&gt;<b>world</b></body></html>
\end{lstlisting}

The HTML helper also takes some additional optional arguments that have the following default:
\begin{lstlisting}
HTML(..., lang='en', doctype='transitional')
\end{lstlisting}
\noindent where doctype can be 'strict', 'transitional', 'frameset', 'html5', or a full doctype string.

{\bf {\ft XHTML}}

\inxx{XHTML}

XHTML is similar to HTML but it creates an XHTML doctype instead.
\begin{lstlisting}
XHTML(..., lang='en', doctype='transitional', xmlns='http://www.w3.org/1999/xhtml')
\end{lstlisting}
\noindent where doctype can be 'strict', 'transitional', 'frameset', or a full doctype string.

{\bf {\ft HR}}

\inxx{HR}

This helper creates a horizontal line in an HTML page
\begin{lstlisting}
>>> print HR()
<hr />
\end{lstlisting}

{\bf {\ft I}}

\inxx{I}

This helper makes its contents italic.
\begin{lstlisting}
>>> print I('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<i id="0" class="test">&lt;hello&gt;<b>world</b></i>
\end{lstlisting}

{\bf {\ft INPUT}}

\inxx{INPUT}

Creates an {\ft <input.../>} tag. An input tag may not contain other tags, and is closed by {\ft />} instead of {\ft >}. The input tag has an optional attribute {\ft \_type} that can be set to "text" (the default), "submit", "checkbox", or "radio".
\begin{lstlisting}
>>> print INPUT(_name='test', _value='a')
<input value="a" name="test" />
\end{lstlisting}

It also takes an optional special argument called "value", distinct from "\_value". The latter sets the default value for the input field; the former sets its current value. For an input of type "text", the former overrides the latter:
\begin{lstlisting}
>>> print INPUT(_name='test', _value='a', value='b')
<input value="b" name="test" />
\end{lstlisting}

For radio buttons, {\ft INPUT} selectively sets the "checked" attribute:

\inxx{radio}
\begin{lstlisting}
>>> for v in ['a', 'b', 'c']:
>>>     print INPUT(_type='radio', _name='test', _value=v, value='b'), v
<input value="a" type="radio" name="test" /> a
<input value="b" type="radio" checked="checked" name="test" /> b
<input value="c" type="radio" name="test" /> c
\end{lstlisting}
\noindent and similarly for checkboxes:

\inxx{checkbox}
\begin{lstlisting}
>>> print INPUT(_type='checkbox', _name='test', _value='a', value=True)
<input value="a" type="checkbox" checked="checked" name="test" />
>>> print INPUT(_type='checkbox', _name='test', _value='a', value=False)
<input value="a" type="checkbox" name="test" />
\end{lstlisting}

{\bf {\ft IFRAME}}

This helper includes another web page in the current page. The url of the other page is specified via the "\_src" attribute.

\inxx{IFRAME}
\begin{lstlisting}
>>> print IFRAME(_src='http://www.web2py.com')
<iframe src="http://www.web2py.com"></iframe>
\end{lstlisting}

{\bf {\ft IMG}}

\inxx{IMG}

It can be used to embed images into HTML:

\begin{lstlisting}
>>> IMG(_src='http://example.com/image.png',_alt='test')
<img src="http://example.com/image.ong" alt="rest" />
\end{lstlisting}

Here is a combination of A, IMG, and URL helpers for including a static image with a link:

\begin{lstlisting}
>>> A(IMG(_src=URL('static','logo.png'), _alt="My Logo"),
      _href=URL('default','index'))
<a href="/myapp/default/index">
  <img src="/myapp/static/logo.png" alt="My Logo" />
</a>
\end{lstlisting}

{\bf {\ft LABEL}}

It is used to create a LABEL tag for an INPUT field.

\inxx{LABEL}
\begin{lstlisting}
>>> print LABEL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<label id="0" class="test">&lt;hello&gt;<b>world</b></label>
\end{lstlisting}

{\bf {\ft LEGEND}}

It is used to create a legend tag for a field in a form.

\inxx{LEGEND}
\begin{lstlisting}
>>> print LEGEND('Name', _for='myfield')
<legend for="myfield">Name</legend>
\end{lstlisting}

{\bf {\ft LI}}

It makes a list item and should be contained in a {\ft UL} or {\ft OL} tag.

\inxx{LI}
\begin{lstlisting}
>>> print LI('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<li id="0" class="test">&lt;hello&gt;<b>world</b></li>
\end{lstlisting}

{\bf {\ft META}}

To be used for building {\ft META} tags in the {\ft HTML} head. For example:

\inxx{META}
\begin{lstlisting}
>>> print META(_name='security', _content='high')
<meta name="security" content="high" />
\end{lstlisting}

{\bf {\ft MARKMIN}}

Implements the markmin wiki syntax. It converts the input text into output html according to the markmin rules described in the example below:

\inxx{MARKMIN}
\begin{lstlisting}
>>> print MARKMIN("this is **bold** or ''italic'' and this [[a link http://web2py.com]]")
<p>this is <b>bold</b> or <i>italic</i> and
this <a href="http://web2py.com">a link</a></p>
\end{lstlisting}

The markmin syntax is described in this file that ships with web2py:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/examples/static/markmin.html
\end{lstlisting}

You can use markmin to generate HTML, LaTeX and PDF documents:

\begin{lstlisting}
m = "Hello **world** [[link http://web2py.com]]"
from gluon.contrib.markmin.markmin2html import markmin2html
print markmin2html(m)
from gluon.contrib.markmin.markmin2latex import markmin2latex
print markmin2latex(m)
from gluon.contrib.markmin.markmin2pdf import markmin2pdf
print markmin2pdf(m) # requires pdflatex
\end{lstlisting}

(the {\ft MARKMIN} helper is a shortcut for {\ft markmin2html})

Here is a basic syntax primer:

\goodbreak\begin{center}
{\begin{tabular}{ll}\hline
{\bf SOURCE}                 & {\bf OUTPUT}\\ \hline
{\ft \# title}                & {\bf title}\\
{\ft \#\# section}             & {\bf section}\\
{\ft \#\#\# subsection}         & {\bf subsection}\\
{\ft **bold**}               & {\bf bold}\\
{\ft ''italic''}             & {\it italic}\\
{\ft ``verbatim``}       & {\ft verbatim}\\
{\ft http://google.com}      & http://google.com\\
{\ft http://...} & {\ft <a href="http://...">http:...</a>}\\
{\ft http://...png} & {\ft <img src="http://...png" />}\\
{\ft http://...mp3} & {\ft <audio src="http://...mp3"></audio>}\\
{\ft http://...mp4} & {\ft <video src="http://...mp4"></video>}\\
{\ft qr:http://...} & {\ft <a href="http://..."><img src="qr code"/></a>}\\
{\ft embed:http://...} & {\ft <iframe src="http://..."></iframe>}\\
{\ft [[click me \#myanchor]]} & {\footnotesize\href{\#myanchor}{click me}}\\
{\ft \$}{\ft \${\textbackslash}int\_a\^b sin(x)dx\$}{\ft \$}  & $\int_a^b sin(x)dx$ \\ \hline
\end{tabular}}
\end{center}
Simply including a link to an image, a videos or an audio files without markup result in the corresponding image, video or audio file being included automatically (for audio and video it uses html <audio> and <video> tags).

Adding a link with the {\ft qr:} prefix such as

\begin{lstlisting}
qr:http://web2py.com
\end{lstlisting}
\noindent results in the corresponding QR code being embedded and linking the said URL.

Adding a link with the {\ft embed:} prefix such as

\begin{lstlisting}
embed:http://www.youtube.com/embed/x1w8hKTJ2Co
\end{lstlisting}
\noindent results in the page being embedded, in this case a youtube video is embedded.

Images can also be embedded with the following syntax:

\begin{lstlisting}
[[image-description http://.../image.png right 200px]]
\end{lstlisting}

Unordered lists with:
\begin{lstlisting}
- one
- two
- three
\end{lstlisting}

Ordered lists with:
\begin{lstlisting}
+ one
+ two
+ three
\end{lstlisting}
\noindent and tables with:
\begin{lstlisting}
----------
 X | 0 | 0
 0 | X | 0
 0 | 0 | 1
----------
\end{lstlisting}

The MARKMIN syntax also supports blockquotes, HTML5 audio and video tags, image alignment, custom css, and it can be extended:

\begin{lstlisting}
MARKMIN("``abab``:custom", extra=dict(custom=lambda text: text.replace('a','c'))
\end{lstlisting}
\noindent generates

{\ft 'cbcb'}

Custom blocks are delimited by {\ft ``...``:<key>} and they are rendered by the function passed as value for the corresponding key in the extra dictionary argument of MARKMIN. Mind that the function may need to escape the output to prevent XSS.

{\bf {\ft OBJECT}}

Used to embed objects (for example, a flash player) in the HTML.

\inxx{OBJECT}
\begin{lstlisting}
>>> print OBJECT('<hello>', XML('<b>world</b>'),
>>>              _src='http://www.web2py.com')
<object src="http://www.web2py.com">&lt;hello&gt;<b>world</b></object>
\end{lstlisting}

{\bf {\ft OL}}

It stands for Ordered List. The list should contain LI tags. {\ft OL} arguments that are not {\ft LI} objects are automatically enclosed in {\ft <li>...</li>} tags.

\inxx{OL}
\begin{lstlisting}
>>> print OL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<ol id="0" class="test"><li>&lt;hello&gt;</li><li><b>world</b></li></ol>
\end{lstlisting}

{\bf {\ft ON}}

This is here for backward compatibility and it is simply an alias for {\ft True}. It is used exclusively for checkboxes and deprecated since {\ft True} is more Pythonic.

\inxx{ON}
\begin{lstlisting}
>>> print INPUT(_type='checkbox', _name='test', _checked=ON)
<input checked="checked" type="checkbox" name="test" />
\end{lstlisting}

{\bf {\ft OPTGROUP}}

Allows you to group multiple options in a SELECT and it is useful to customize the fields using CSS.

\inxx{OPTGROUP}
\begin{lstlisting}
>>> print SELECT('a', OPTGROUP('b', 'c'))
<select>
  <option value="a">a</option>
  <optgroup>
    <option value="b">b</option>
    <option value="c">c</option>
  </optgroup>
</select>
\end{lstlisting}

{\bf {\ft OPTION}}

This should only be used as part of a SELECT/OPTION combination.

\inxx{OPTION}
\begin{lstlisting}
>>> print OPTION('<hello>', XML('<b>world</b>'), _value='a')
<option value="a">&lt;hello&gt;<b>world</b></option>
\end{lstlisting}

As in the case of {\ft INPUT}, web2py make a distinction between "\_value" (the value of the OPTION), and "value" (the current value of the enclosing select). If they are equal, the option is "selected".

\inxx{selected}
\begin{lstlisting}
>>> print SELECT('a', 'b', value='b'):
<select>
<option value="a">a</option>
<option value="b" selected="selected">b</option>
</select>
\end{lstlisting}

{\bf {\ft P}}

\inxx{P}

This is for tagging a paragraph.
\begin{lstlisting}
>>> print P('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<p id="0" class="test">&lt;hello&gt;<b>world</b></p>
\end{lstlisting}

{\bf {\ft PRE}}

\inxx{PRE}

Generates a {\ft <pre>...</pre>} tag for displaying pre-formatted text. The {\ft CODE} helper is generally preferable for code listings.
\begin{lstlisting}
>>> print PRE('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<pre id="0" class="test">&lt;hello&gt;<b>world</b></pre>
\end{lstlisting}

{\bf {\ft SCRIPT}}

\inxx{SCRIPT}

This is include or link a script, such as JavaScript. The content between the tags is rendered as an HTML comment, for the benefit of really old browsers.
\begin{lstlisting}
>>> print SCRIPT('alert("hello world");', _type='text/javascript')
<script type="text/javascript"><!--
alert("hello world");
//--></script>
\end{lstlisting}

{\bf {\ft SELECT}}

\inxx{SELECT}

Makes a {\ft <select>...</select>} tag. This is used with the {\ft OPTION} helper. Those {\ft SELECT} arguments that are not {\ft OPTION} objects are automatically converted to options.
\begin{lstlisting}
>>> print SELECT('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<select id="0" class="test">
   <option value="&lt;hello&gt;">&lt;hello&gt;</option>
   <option value="&lt;b&gt;world&lt;/b&gt;"><b>world</b></option>
</select>
\end{lstlisting}

{\bf {\ft SPAN}}

\inxx{SPAN}

Similar to {\ft DIV} but used to tag inline (rather than block) content.
\begin{lstlisting}
>>> print SPAN('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<span id="0" class="test">&lt;hello&gt;<b>world</b></span>
\end{lstlisting}

{\bf {\ft STYLE}}

\inxx{STYLE}

Similar to script, but used to either include or link CSS code.
Here the CSS is included:
\begin{lstlisting}
>>> print STYLE(XML('body {color: white}'))
<style><!--
body { color: white }
//--></style>
\end{lstlisting}
\noindent and here it is linked:
\begin{lstlisting}
>>> print STYLE(_src='style.css')
<style src="style.css"><!--
//--></style>
\end{lstlisting}

{\bf {\ft TABLE}, {\ft TR}, {\ft TD}}

\inxx{TABLE} \inxx{TR} \inxx{TD}

These tags (along with the optional {\ft THEAD}, {\ft TBODY} and {\ft TFOOTER} helpers) are used to build HTML tables.
\begin{lstlisting}
>>> print TABLE(TR(TD('a'), TD('b')), TR(TD('c'), TD('d')))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
\end{lstlisting}
{\ft TR} expects {\ft TD} content; arguments that are not {\ft TD} objects are converted automatically.
\begin{lstlisting}
>>> print TABLE(TR('a', 'b'), TR('c', 'd'))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
\end{lstlisting}

It is easy to convert a Python array into an HTML table using Python's {\ft *} function arguments notation, which maps list elements to positional function arguments.

Here, we will do it line by line:
\begin{lstlisting}
>>> table = [['a', 'b'], ['c', 'd']]
>>> print TABLE(TR(*table[0]), TR(*table[1]))
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
\end{lstlisting}

Here we do all lines at once:
\begin{lstlisting}
>>> table = [['a', 'b'], ['c', 'd']]
>>> print TABLE(*[TR(*rows) for rows in table])
<table><tr><td>a</td><td>b</td></tr><tr><td>c</td><td>d</td></tr></table>
\end{lstlisting}

{\bf {\ft TBODY}}

\inxx{TBODY}

This is used to tag rows contained in the table body, as opposed to header or footer rows. It is optional.
\begin{lstlisting}
>>> print TBODY(TR('<hello>'), _class='test', _id=0)
<tbody id="0" class="test"><tr><td>&lt;hello&gt;</td></tr></tbody>
\end{lstlisting}

{\bf {\ft TEXTAREA}}

\inxx{TEXTAREA}

This helper makes a {\ft <textarea>...</textarea>} tag.
\begin{lstlisting}
>>> print TEXTAREA('<hello>', XML('<b>world</b>'), _class='test')
<textarea class="test" cols="40" rows="10">&lt;hello&gt;<b>world</b></textarea>
\end{lstlisting}

The only caveat is that its optional "value" overrides its content (inner HTML)
\begin{lstlisting}
>>> print TEXTAREA(value="<hello world>", _class="test")
<textarea class="test" cols="40" rows="10">&lt;hello world&gt;</textarea>
\end{lstlisting}

{\bf {\ft TFOOT}}

\inxx{TFOOT}

This is used to tag table footer rows.
\begin{lstlisting}
>>> print TFOOT(TR(TD('<hello>')), _class='test', _id=0)
<tfoot id="0" class="test"><tr><td>&lt;hello&gt;</td></tr></tfoot>
\end{lstlisting}

{\bf {\ft TH}}

\inxx{TH}

This is used instead of {\ft TD} in table headers.
\begin{lstlisting}
>>> print TH('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<th id="0" class="test">&lt;hello&gt;<b>world</b></th>
\end{lstlisting}

{\bf {\ft THEAD}}

\inxx{THEAD}

This is used to tag table header rows.
\begin{lstlisting}
>>> print THEAD(TR(TH('<hello>')), _class='test', _id=0)
<thead id="0" class="test"><tr><th>&lt;hello&gt;</th></tr></thead>
\end{lstlisting}

{\bf {\ft TITLE}}

\inxx{TITLE}

This is used to tag the title of a page in an HTML header.
\begin{lstlisting}
>>> print TITLE('<hello>', XML('<b>world</b>'))
<title>&lt;hello&gt;<b>world</b></title>
\end{lstlisting}

{\bf {\ft TR}}

\inxx{TR}

Tags a table row. It should be rendered inside a table and contain {\ft <td>...</td>} tags. {\ft TR} arguments that are not {\ft TD} objects will be automatically converted.
\begin{lstlisting}
>>> print TR('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<tr id="0" class="test"><td>&lt;hello&gt;</td><td><b>world</b></td></tr>
\end{lstlisting}

{\bf {\ft TT}}

\inxx{TT}

Tags text as typewriter (monospaced) text.
\begin{lstlisting}
>>> print TT('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<tt id="0" class="test">&lt;hello&gt;<b>world</b></tt>
\end{lstlisting}

{\bf {\ft UL}}

Signifies an Unordered List and should contain LI items. If its content is not tagged as LI, UL does it automatically.

\inxx{UL}
\begin{lstlisting}
>>> print UL('<hello>', XML('<b>world</b>'), _class='test', _id=0)
<ul id="0" class="test"><li>&lt;hello&gt;</li><li><b>world</b></li></ul>
\end{lstlisting}

{\bf {\ft embed64}}

{\ft embed64(filename=None, file=None, data=None, extension='image/gif')} encodes the provided (binary) data into base64.
\noindent filename: if provided, opens and reads this file in 'rb' mode.
file: if provided, reads this file.
data: if provided, uses the provided data.

\inxx{embed64}

{\bf {\ft xmlescape}}

{\ft xmlescape(data, quote=True)} returns an escaped string of the provided data.

\inxx{xmlescape}
\begin{lstlisting}
>>> print xmlescape('<hello>')
&lt;hello&gt;
\end{lstlisting}

\goodbreak\subsection{Custom helpers}

{\bf {\ft TAG}}

\inxx{TAG}

Sometimes you need to generate custom XML tags. web2py provides {\ft TAG}, a universal tag generator.
\begin{lstlisting}[keywords={}]
{{=TAG.name('a', 'b', _c='d')}}
\end{lstlisting}
\noindent generates the following XML
\begin{lstlisting}[keywords={}]
<name c="d">ab</name>
\end{lstlisting}

Arguments "a", "b", and "d" are automatically escaped; use the {\ft XML} helper to suppress this behavior. Using {\ft TAG} you can generate HTML/XML tags not already provided by the API. TAGs can be nested, and are serialized with {\ft str().}
An equivalent syntax is:
\begin{lstlisting}[keywords={}]
{{=TAG['name']('a', 'b', c='d')}}
\end{lstlisting}

If the TAG object is created with an empty name, it can be used to concatenate multiple strings and HTML helpers together without inserting them into a surrounding tag, but this use is deprecated. Use the {\ft CAT} helper instead.

Notice that {\ft TAG} is an object, and {\ft TAG.name} or {\ft TAG['name']} is a function that returns a temporary helper class.

{\bf {\ft MENU}}

\inxx{MENU}

The MENU helper takes a list of lists or of tuples of the form of {\ft response.menu} (as described in Chapter 4) and generates a tree-like structure using unordered lists representing the menu. For example:
\begin{lstlisting}
>>> print MENU([['One', False, 'link1'], ['Two', False, 'link2']])
<ul class="web2py-menu web2py-menu-vertical">
  <li><a href="link1">One</a></li>
  <li><a href="link2">Two</a></li>
</ul>
\end{lstlisting}

\begin{quote}The third item in each list/tuple can be an HTML helper (which could include nested helpers), and the {\ft MENU} helper will simply render that helper rather than creating its own {\ft <a>} tag.\end{quote}
Each menu item can have a fourth argument that is a nested submenu (and so on recursively):
\begin{lstlisting}
>>> print MENU([['One', False, 'link1', [['Two', False, 'link2']]]])
<ul class="web2py-menu web2py-menu-vertical">
  <li class="web2py-menu-expand">
     <a href="link1">One</a>
     <ul class="web2py-menu-vertical">
        <li><a href="link2">Two</a></li>
     </ul>
  </li>
</ul>
\end{lstlisting}

A menu item can also have an optional 5th element, which is a boolean. When false, the menu item is ignored by the MENU helper.

The MENU helper takes the following optional arguments:
\begin{itemize}
\item {\ft \_class}: defaults to "web2py-menu web2py-menu-vertical" and sets the class of the outer UL elements.

\item {\ft ul\_class}: defaults to "web2py-menu-vertical" and sets the class of the inner UL elements.

\item {\ft li\_class}: defaults to "web2py-menu-expand" and sets the class of the inner LI elements.

\item {\ft li\_first}: allows to add a class to the first list element.

\item {\ft li\_last}: allows to add a class to the last list element.
\end{itemize}

\inxx{mobile}

{\ft MENU} takes an optional argument {\ft mobile}. When set to {\ft True} instead of building a recursive {\ft UL} menu structure it returns a {\ft SELECT} dropdown with all the menu options and a {\ft onchange} attribute that redirects to the page corresponding to the selected option. This is designed an an alternative menu representation that increases usability on small mobile devices such as phones.

Normally the menu is used in a layout with the following syntax:

\begin{lstlisting}[keywords={}]
{{=MENU(response.menu, mobile=request.user_agent().is_mobile)}}
\end{lstlisting}

In this way a mobile device is automatically detected and the menu is rendered accordingly.

\goodbreak\section{{\ft BEAUTIFY}}

{\ft BEAUTIFY} is used to build HTML representations of compound objects, including lists, tuples and dictionaries:
\begin{lstlisting}[keywords={}]
{{=BEAUTIFY({"a": ["hello", XML("world")], "b": (1, 2)})}}
\end{lstlisting}
{\ft BEAUTIFY} returns an XML-like object serializable to XML, with a nice looking representation of its constructor argument. In this case, the XML representation of:
\begin{lstlisting}
{"a": ["hello", XML("world")], "b": (1, 2)}
\end{lstlisting}
\noindent will render as:
\begin{lstlisting}[keywords={}]
<table>
<tr><td>a</td><td>:</td><td>hello<br />world</td></tr>
<tr><td>b</td><td>:</td><td>1<br />2</td></tr>
</table>
\end{lstlisting}

\goodbreak\section{Server-side {\it DOM} and parsing}

\inxx{element} \inxx{elements}

\goodbreak\subsection{{\ft elements}}

The DIV helper and all derived helpers provide the search methods {\ft element} and {\ft elements}.

{\ft element} returns the first child element matching a specified condition (or None if no match).

{\ft elements} returns a list of all matching children.

{\bf element} and {\bf elements} use the same syntax to specify the matching condition, which allows for three possibilities that can be mixed and matched: jQuery-like expressions, match by exact attribute value, match using regular expressions.

Here is a simple example:
\begin{lstlisting}
>>> a = DIV(DIV(DIV('a', _id='target',_class='abc')))
>>> d = a.elements('div#target')
>>> d[0][0] = 'changed'
>>> print a
<div><div><div id="target" class="abc">changed</div></div></div>
\end{lstlisting}

The un-named argument of {\ft elements} is a string, which may contain: the name of a tag, the id of a tag preceded by a pound symbol, the class preceded by a dot, the explicit value of an attribute in square brackets.

Here are 4 equivalent ways to search the previous tag by id:
\begin{lstlisting}
>>> d = a.elements('#target')
>>> d = a.elements('div#target')
>>> d = a.elements('div[id=target]')
>>> d = a.elements('div',_id='target')
\end{lstlisting}

Here are 4 equivalent ways to search the previous tag by class:
\begin{lstlisting}
>>> d = a.elements('.abc')
>>> d = a.elements('div.abc')
>>> d = a.elements('div[class=abc]')
>>> d = a.elements('div',_class='abc')
\end{lstlisting}

Any attribute can be used to locate an element (not just {\ft id} and {\ft class}), including multiple attributes (the function element can take multiple named arguments), but only the first matching element will be returned.

Using the jQuery syntax "div\#target" it is possible to specify multiple search criteria separated by a space:
\begin{lstlisting}
>>> a = DIV(SPAN('a', _id='t1'), DIV('b', _class='c2'))
>>> d = a.elements('span#t1, div.c2')
\end{lstlisting}
\noindent or equivalently
\begin{lstlisting}
>>> a = DIV(SPAN('a', _id='t1'), DIV('b', _class='c2'))
>>> d = a.elements('span#t1', 'div.c2')
\end{lstlisting}

If the value of an attribute is specified using a name argument, it can be a string or a regular expression:
\begin{lstlisting}
>>> a = DIV(SPAN('a', _id='test123'), DIV('b', _class='c2'))
>>> d = a.elements('span', _id=re.compile('test\d{3}')
\end{lstlisting}

A special named argument of the DIV (and derived) helpers is {\ft find}. It can be used to specify a search value or a search regular expression in the text content of the tag. For example:
\begin{lstlisting}
>>> a = DIV(SPAN('abcde'), DIV('fghij'))
>>> d = a.elements(find='bcd')
>>> print d[0]
<span>abcde</span>
\end{lstlisting}
\noindent or
\begin{lstlisting}
>>> a = DIV(SPAN('abcde'), DIV('fghij'))
>>> d = a.elements(find=re.compile('fg\w{3}'))
>>> print d[0]
<div>fghij</div>
\end{lstlisting}

\goodbreak\subsection{{\ft components} \inxx{components}}

Here's an example of listing all elements in an html string:
\begin{lstlisting}
html = TAG('<a>xxx</a><b>yyy</b>')
for item in html.components: print item
\end{lstlisting}

\inxx{parent} \inxx{sibling}

\goodbreak\subsection{{\ft parent} and {\ft siblings}}

{\ft parent} returns the parent of the current element.
\begin{lstlisting}
>>> a = DIV(SPAN('a'),DIV('b'))
>>> s = a.element('span')
>>> d = s.parent
>>> d['_class']='abc'
>>> print a
<div class="abc"><span>a</span><div>b</div></div>
>>> for e in s.siblings(): print e
<div>b</div>
\end{lstlisting}

\goodbreak\subsection{Replacing elements}

Elements that are matched can also be replaced or removed by specifying
the {\ft replace} argument. Notice that a
list of the original matching elements is still returned as usual.

\begin{lstlisting}
>>> a = DIV(SPAN('x'), DIV(SPAN('y'))
>>> b = a.elements('span', replace=P('z')
>>> print a
<div><p>z</p><div><p>z</p></div>
\end{lstlisting}

{\ft replace} can be a callable. In this case it will be passed
the original element and it is expected to return the replacement element:

\begin{lstlisting}
>>> a = DIV(SPAN('x'), DIV(SPAN('y'))
>>> b = a.elements('span', replace=lambda t: P(t[0])
>>> print a
<div><p>x</p><div><p>y</p></div>
\end{lstlisting}

If {\ft replace=None}, matching elements will be removed completely.

\begin{lstlisting}
>>> a = DIV(SPAN('x'), DIV(SPAN('y'))
>>> b = a.elements('span', replace=None)
>>> print a
<div></div>
\end{lstlisting}

\goodbreak\subsection{{\ft flatten} \inxx{flatten}}

The flatten method recursively serializes the content of the children of a given element into regular text (without tags):
\begin{lstlisting}
>>> a = DIV(SPAN('this', DIV('is', B('a'))), SPAN('test'))
>>> print a.flatten()
thisisatest
\end{lstlisting}

Flatten can be passed an optional argument, {\ft render}, i.e. a function that renders/flattens the content using a different protocol. Here is an example to serialize some tags into Markmin wiki syntax:
\begin{lstlisting}
>>> a = DIV(H1('title'), P('example of a ', A('link', _href='#test')))
>>> from gluon.html import markmin_serializer
>>> print a.flatten(render=markmin_serializer)
## titles

example of [[a link #test]]
\end{lstlisting}

At the time of writing we provide {\ft markmin\_serializer} and {\ft markdown\_serializer}.

\goodbreak\subsection{Parsing}

The TAG object is also an XML/HTML parser. It can read text and convert into a tree structure of helpers. This allows manipulation using the API above:
\begin{lstlisting}
>>> html = '<h1>Title</h1><p>this is a <span>test</span></p>'
>>> parsed_html = TAG(html)
>>> parsed_html.element('span')[0]='TEST'
>>> print parsed_html
<h1>Title</h1><p>this is a <span>TEST</span></p>
\end{lstlisting}

\goodbreak\section{Page layout}

\inxx{page layout} \inxx{layout.html} \inxx{extent} \inxx{include}

Views can extend and include other views in a tree-like structure.

For example, we can think of a view "index.html" that extends "layout.html" and includes "body.html".
At the same time,  "layout.html" may include "header.html" and "footer.html".

The root of the tree is what we call a layout view.  Just like any other HTML template file, you can edit it using the web2py administrative interface. The file name "layout.html" is just a convention.

Here is a minimalist page that extends the "layout.html" view and includes the "page.html" view:

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Hello World</h1>
{{include 'page.html'}}
\end{lstlisting}

The extended layout file must contain an {\ft \{\{include\}\}} directive, something like:
\begin{lstlisting}[keywords={}]
<html>
  <head>
    <title>Page Title</title>
  </head>
  <body>
    {{include}}
  </body>
</html>
\end{lstlisting}

When the view is called, the extended (layout) view is loaded, and the calling view replaces the {\ft \{\{include\}\}} directive inside the layout. Processing continues recursively until all {\ft extend} and {\ft include} directives have been processed. The resulting template is then translated into Python code. Note, when an application is bytecode compiled, it is this Python code that is compiled, not the original view files themselves. So, the bytecode compiled version of a given view is a single.pyc file that includes the Python code not just for the original view file, but for its entire tree of extended and included views.

\begin{quote}{\ft extend}, {\ft include}, {\ft block} and {\ft super} are special template directives,
not Python commands.\end{quote}
Any content or code that precedes the {\ft \{\{extend ...\}\}} directive will be inserted (and therefore executed) before the beginning of the extended view's content/code. Although this is not typically used to insert actual HTML content before the extended view's content, it can be useful as a means to define variables or functions that you want to make available to the extended view. For example, consider a view "index.html":
\begin{lstlisting}[keywords={}]
{{sidebar_enabled=True}}
{{extend 'layout.html'}}
<h1>Home Page</h1>
\end{lstlisting}
\noindent and an excerpt from "layout.html":
\begin{lstlisting}[keywords={}]
{{if sidebar_enabled:}}
    <div id="sidebar">
        Sidebar Content
    </div>
{{pass}}
\end{lstlisting}

Because the {\ft sidebar\_enabled} assignment in "index.html" comes before the {\ft extend}, that line gets inserted before the beginning of "layout.html", making {\ft sidebar\_enabled} available anywhere within the "layout.html" code (a somewhat more sophisticated version of this is used in the {\bf welcome} app).

It is also worth pointing out that the variables returned by the controller function are available not only in the function's main view, but in all of its extended and included views as well.

The argument of an {\ft extend} or {\ft include} (i.e., the extended or included view name) can be a python variable (though not a python expression). However, this imposes a limitation -- views that use variables in {\ft extend} or {\ft include} statements cannot be bytecode compiled. As noted above, bytecode-compiled views include the entire tree of extended and included views, so the specific extended and included views must be known at compile time, which is not possible if the view names are variables (whose values are not determined until run time). Because bytecode compiling views can provide a significant speed boost, using variables in {\ft extend} and {\ft include} should generally be avoided if possible.

In some cases, an alternative to using a variable in an {\ft include} is simply to place regular {\ft \{\{include ...\}\}} directives inside an {\ft if...else} block.

\begin{lstlisting}[keywords={}]
{{if some_condition:}}
{{include 'this_view.html'}}
{{else:}}
{{include 'that_view.html'}}
{{pass}}
\end{lstlisting}

The above code does not present any problem for bytecode compilation because no variables are involved. Note, however, that the bytecode compiled view will actually include the Python code for both "this\_view.html" and "that\_view.html", though only the code for one of those views will be executed, depending on the value of {\ft some\_condition}.

Keep in mind, this only works for {\ft include} -- you cannot place {\ft \{\{extend ...\}\}} directives inside {\ft if...else} blocks.

\inxx{response.menu} \inxx{menu} \inxx{response.meta} \inxx{meta}

Layouts are used to encapsulate page commonality (headers, footers, menus), and though they are not mandatory, they will make your application easier to write and maintain.  In particular, we suggest writing layouts that take advantage of the following variables that can be set in the controller. Using these well known variables will help make your layouts interchangeable:
\begin{lstlisting}
response.title
response.subtitle
response.meta.author
response.meta.keywords
response.meta.description
response.flash
response.menu
response.files
\end{lstlisting}

Except for {\ft menu} and {\ft files}, these are all strings and their meaning should be obvious.

{\ft response.menu} menu is a list of 3-tuples or 4-tuples. The three elements are: the link name, a boolean representing whether the link is active (is the current link), and the URL of the linked page. For example:
\begin{lstlisting}
response.menu = [('Google', False, 'http://www.google.com',[]),
                 ('Index',  True,  URL('index'), [])]
\end{lstlisting}

\inxx{sub-menu}
The fourth tuple element is an optional sub-menu.

{\ft response.files} is a list of CSS and JS files that are needed by your page.

We also recommend that you use:

\begin{lstlisting}[keywords={}]
{{include 'web2py_ajax.html'}}
\end{lstlisting}
\noindent in the HTML head, since this will include the jQuery libraries and define some backward-compatible JavaScript functions for special effects and Ajax. "web2py\_ajax.html" includes the {\ft response.meta} tags in the view, jQuery base, the calendar datepicker, and all required CSS and JS {\ft response.files}.

\goodbreak\subsection{Default page layout}

\inxx{Twitter Bootstrap}

The "views/layout.html" that ships with the web2py scaffolding application {\bf welcome} (stripped down of some optional parts) is quite complex but it has the following structure:

\begin{lstlisting}[keywords={}]
<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title>{{=response.title or request.application}}</title>
  ...
  <script src="{{=URL('static','js/modernizr.custom.js')}}"></script>

  {{
  response.files.append(URL('static','css/web2py.css'))
  response.files.append(URL('static','css/bootstrap.min.css'))
  response.files.append(URL('static','css/bootstrap-responsive.min.css'))
  response.files.append(URL('static','css/web2py_bootstrap.css'))
  }}

  {{include 'web2py_ajax.html'}}

  {{
  # using sidebars need to know what sidebar you want to use
  left_sidebar_enabled = globals().get('left_sidebar_enabled',False)
  right_sidebar_enabled = globals().get('right_sidebar_enabled',False)
  middle_columns = {0:'span12',1:'span9',2:'span6'}[
    (left_sidebar_enabled and 1 or 0)+(right_sidebar_enabled and 1 or 0)]
  }}

  {{block head}}{{end}}
</head>

<body>
  <!-- Navbar ================================================== -->
  <div class="navbar navbar-inverse navbar-fixed-top">
    <div class="flash">{{=response.flash or ''}}</div>
    <div class="navbar-inner">
      <div class="container">
        {{=response.logo or ''}}
        <ul id="navbar" class="nav pull-right">
          {{='auth' in globals() and auth.navbar(mode="dropdown") or ''}}
        </ul>
        <div class="nav-collapse">
          {{if response.menu:}}
          {{=MENU(response.menu)}}
          {{pass}}
        </div><!--/.nav-collapse -->
      </div>
    </div>
  </div><!--/top navbar -->

  <div class="container">
    <!-- Masthead ================================================== -->
    <header class="mastheader row" id="header">
        <div class="span12">
            <div class="page-header">
                <h1>
                    {{=response.title or request.application}}
                    <small>{{=response.subtitle or ''}}</small>
                </h1>
            </div>
        </div>
    </header>

    <section id="main" class="main row">
        {{if left_sidebar_enabled:}}
        <div class="span3 left-sidebar">
            {{block left_sidebar}}
            <h3>Left Sidebar</h3>
            <p></p>
            {{end}}
        </div>
        {{pass}}

        <div class="{{=middle_columns}}">
            {{block center}}
            {{include}}
            {{end}}
        </div>

        {{if right_sidebar_enabled:}}
        <div class="span3">
            {{block right_sidebar}}
            <h3>Right Sidebar</h3>
            <p></p>
            {{end}}
        </div>
        {{pass}}
    </section><!--/main-->

    <!-- Footer ================================================== -->
    <div class="row">
        <footer class="footer span12" id="footer">
            <div class="footer-content">
                {{block footer}} <!-- this is default footer -->
                ...
                {{end}}
            </div>
        </footer>
    </div>

  </div> <!-- /container -->

  <!-- The javascript =============================================
       (Placed at the end of the document so the pages load faster) -->
  <script src="{{=URL('static','js/bootstrap.min.js')}}"></script>
  <script src="{{=URL('static','js/web2py_bootstrap.js')}}"></script>
  {{if response.google_analytics_id:}}
    <script src="{{=URL('static','js/analytics.js')}}"></script>
    <script type="text/javascript">
    analytics.initialize({
      'Google Analytics':{trackingId:'{{=response.google_analytics_id}}'}
    });</script>
  {{pass}}
</body>
</html>
\end{lstlisting}

There are a few features of this default layout that make it very easy to use and customize:

\begin{itemize}
\item It is written in HTML5 and uses the "modernizr"~\cite{modernizr} library for backward compatibility. The actual layout include some extra conditional statements required by IE and they are omitted for brevity.

\item It displays both {\ft response.title} and {\ft response.subtitle} which can be set in a model. If they are not set, it adopts the application name as title

\item It includes the {\ft web2py\_ajax.html} file in the header which generated all the link and script import statements.

\item It uses a modified version of Twitter Bootstrap for flexible layouts which works on mobile devices and re-arranges columns to fit small screens.

\item It uses "analytics.js" to connect to Google Analytics.

\item The {\ft \{\{=auth.navbar(...)\}\}} displays a welcome to the current user and links to auth functions like login, logout, register, change password, etc. depending on context. It is a helper factory and its output can be manipulated as any other helper. It is placed in a {\ft \{\{try:\}\}...\{\{except:pass\}\}} in case auth is undefined.

\item The {\ft \{\{=MENU(response.menu)} displays the menu structure as {\ft <ul>...</ul>}.

\item {\ft \{\{include\}\}} is replaced by the content of the extending view when the page is rendered.

\item By default it uses a conditional three column (the left and right sidebars can be turned off by the extending views)

\item It uses the following classes: header, main, footer

\item It contains the following blocks: statusbar, left\_sidebar, center, right\_sidebar, footer.
\end{itemize}

In views can turn on and fill sidebars as follows:

\begin{lstlisting}[keywords={}]
{{left_sidebar_enable=True}}
{{extend 'layout.html'}}

This text goes in center

{{block left_sidebar}}
This text goes in sidebar
{{end}}
\end{lstlisting}

\goodbreak\subsection{Customizing the default layout}

\inxx{CSS}

Customizing the default layout without editing is easy because the welcome application is based on Twitter Bootstrap which is well documented and supports themes. In web2py four static files which are relevant to style:

\begin{itemize}
\item "css/web2py.css" contains web2py specific styles

\item "css/bootstrap.min.css" contains the Twitter Bootstrap CSS style~\cite{bootstrap} \inxx{Bootstrap}

\item "css/web2py\_bootstrap.css" contains with overrides some Bootstrap styles to conform to web2py needs.

\item "js/bootstrap.min.js" which includes the libraries for menu effects, modals, panels.
\end{itemize}

To change colors and background images,
try append the following code to layout.html header:

\begin{lstlisting}[keywords={}]
<style>
body { background: url('images/background.png') repeat-x #3A3A3A; }
a { color: #349C01; }
.header h1 { color: #349C01; }
.header h2 { color: white; font-style: italic; font-size: 14px;}
.statusbar { background: #333333; border-bottom: 5px #349C01 solid; }
.statusbar a { color: white; }
.footer { border-top: 5px #349C01 solid; }
</style>
\end{lstlisting}

Of course you can also completely replace the "layout.html" and "web2py.css" files with your own.

\goodbreak\subsection{Mobile development}

The default layout.html is designed to be friendly to mobile devices but that is not enough. One may need to use different views when a page is visited by a mobile device.

To make developing for desktop and mobile devices easier, web2py includes the {\ft @mobilize} decorator. This decorator is applied to actions that should have a normal view and a mobile view. This is demonstrated here:

\begin{lstlisting}
from gluon.contrib.user_agent_parser import mobilize
@mobilize
def index():
   return dict()
\end{lstlisting}

Notice that the decorator must be imported before using it in a controller.
When the "index" function is called from a regular browser (desktop computer), web2py will render the returned dictionary using the view "[controller]/index.html". However, when it is called by a mobile device, the dictionary will be rendered by "[controller]/index.mobile.html". Notice that mobile views have the "mobile.html" extension.

Alternatively you can apply the following logic to make all views mobile friendly:

\begin{lstlisting}
if request.user_agent().is_mobile:
    response.view.replace('.html','.mobile.html')
\end{lstlisting}

The task of creating the "*.mobile.html" views is left to the developer but we strongly suggest using the "jQuery Mobile" plugin which makes the task very easy.

\goodbreak\section{Functions in views}

Consider this "layout.html":

\begin{lstlisting}[keywords={}]
<html>
  <body>
    {{include}}
    <div class="sidebar">
      {{if 'mysidebar' in globals():}}{{mysidebar()}}{{else:}}
        my default sidebar
      {{pass}}
    </div>
  </body>
</html>
\end{lstlisting}
\noindent and this extending view

\begin{lstlisting}[keywords={}]
{{def mysidebar():}}
my new sidebar!!!
{{return}}
{{extend 'layout.html'}}
Hello World!!!
\end{lstlisting}

Notice the function is defined before the {\ft \{\{extend...\}\}} statement -- this results in the function being created before the "layout.html" code is executed, so the function can be called anywhere within "layout.html", even before the {\ft \{\{include\}\}}. Also notice the function is included in the extended view without the {\ft =} prefix.

The code generates the following output:

\begin{lstlisting}[keywords={}]
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my new sidebar!!!
    </div>
  </body>
</html>
\end{lstlisting}

Notice that the function is defined in HTML (although it could also contain Python code) so that {\ft response.write} is used to write its content (the function does not return the content). This is why the layout calls the view function using {\ft \{\{mysidebar()\}\}} rather than {\ft \{\{=mysidebar()\}\}}. Functions defined in this way can take arguments.

\goodbreak\section{Blocks in views}

\inxx{block}

Another way to make a view more modular is by using {\ft \{\{block...\}\}s} and this mechanism is an alternative to the mechanism discussed in the previous section.

Consider this "layout.html":

\begin{lstlisting}[keywords={}]
<html>
  <body>
    {{include}}
    <div class="sidebar">
      {{block mysidebar}}
        my default sidebar
      {{end}}
    </div>
  </body>
</html>
\end{lstlisting}
\noindent and this extending view

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
Hello World!!!
{{block mysidebar}}
my new sidebar!!!
{{end}}
\end{lstlisting}

It generates the following output:

\begin{lstlisting}[keywords={}]
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my new sidebar!!!
    </div>
  </body>
</html>
\end{lstlisting}

You can have many blocks, and if a block is present in the extended view but not in the extending view, the content of the extended view is used. Also, notice that unlike with functions, it is not necessary to define blocks before the {\ft \{\{extend ...\}\}} -- even if defined after the {\ft extend}, they can be used to make substitutions anywhere in the extended view.

\inxx{super}

Inside a block, you can use the expression {\ft \{\{super\}\}} to include the content of the parent. For example, if we replace the above extending view with:

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
Hello World!!!
{{block mysidebar}}
{{super}}
my new sidebar!!!
{{end}}
\end{lstlisting}
\noindent we get:

\begin{lstlisting}[keywords={}]
<html>
  <body>
    Hello World!!!
    <div class="sidebar">
        my default sidebar
        my new sidebar!!!
    </div>
  </body>
</html>
\end{lstlisting}

\goodbreak\chapter{The database abstraction layer}

\inxx{DAL}

\goodbreak\section{Dependencies}
\noindent web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. At the time of this writing, the supported databases are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, Ingres, MongoDB, and the Google App Engine (SQL and NoSQL). Experimentally we support more databases. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.

The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.
To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.
\inxx{database drivers}

Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:

\inxx{DAL} \inxx{SQLite} \inxx{MySQL} \inxx{PostgresSQL} \inxx{Oracle} \inxx{MSSQL} \inxx{FireBird} \inxx{DB2} \inxx{Informix} \inxx{Sybase} \inxx{Teradata} \inxx{MongoDB} \inxx{CouchDB} \inxx{SAPDB} \inxx{Cubrid}

\goodbreak\begin{center}
{\begin{tabular}{ll}\hline
database & drivers (source)\\ \hline
SQLite & sqlite3 or pysqlite2 or zxJDBC~\cite{zxjdbc}  (on Jython)\\
PostgreSQL & psycopg2~\cite{psycopg2}  or pg8000~\cite{pg8000} or zxJDBC~\cite{zxjdbc}  (on Jython)\\
MySQL & pymysql~\cite{pymysql} or MySQLdb~\cite{mysqldb}\\
Oracle & cx\_Oracle~\cite{cxoracle}\\
MSSQL & pyodbc~\cite{pyodbc}\\
FireBird & kinterbasdb~\cite{kinterbasdb} or fdb or pyodbc\\
DB2 & pyodbc~\cite{pyodbc}\\
Informix & informixdb~\cite{informixdb}\\
Ingres & ingresdbi~\cite{ingresdbi}\\
Cubrid & cubriddb~\cite{cubridb}~\cite{cubridb}\\
Sybase & Sybase~\cite{Sybase}\\
Teradata & pyodbc~\cite{Teradata}\\
SAPDB    & sapdb~\cite{SAPDB}\\
MongoDB & pymongo~\cite{pymongo}\\
IMAP & imaplib~\cite{IMAP} \\ \hline
\end{tabular}}
\end{center}
{\ft sqlite3}, {\ft pymysql}, {\ft pg8000}, and {\ft imaplib} ship with web2py. Support of MongoDB is experimental. The IMAP option allows to use DAL to access IMAP.
\noindent web2py defines the following classes that make up the DAL:

{\bf DAL} represents a database connection. For example:
\inxx{sqlite}
\begin{lstlisting}
db = DAL('sqlite://storage.db')
\end{lstlisting}

\inxx{define\_table}
{\bf Table} represents a database table.  You do not directly instantiate Table; instead, {\ft DAL.define\_table} instantiates it.
\begin{lstlisting}
db.define_table('mytable', Field('myfield'))
\end{lstlisting}

The most important methods of a Table are:
\inxx{insert}
\inxx{truncate}
\inxx{drop}
\inxx{import\_from\_csv\_file}
\inxx{count}
{\ft .insert}, {\ft .truncate}, {\ft .drop}, and {\ft .import\_from\_csv\_file}.

\inxx{Field}
{\bf Field} represents a database field. It can be instantiated and passed as an argument to {\ft DAL.define\_table}.

\inxx{Rows}
{\bf DAL Rows} \inxx{Row}  is the object returned by a database select. It can be thought of as a list of {\ft Row} rows:
\begin{lstlisting}
rows = db(db.mytable.myfield!=None).select()
\end{lstlisting}

\inxx{Row}
{\bf Row} contains field values.
\begin{lstlisting}
for row in rows:
    print row.myfield
\end{lstlisting}

\inxx{Query}
{\bf Query} is an object that represents a SQL "where" clause:
\begin{lstlisting}
myquery = (db.mytable.myfield != None) | (db.mytable.myfield > 'A')
\end{lstlisting}

\inxx{Set}
{\bf Set} is an object that represents a set of records. Its most important methods are {\ft count}, {\ft select}, {\ft update}, and {\ft delete}. For example:
\begin{lstlisting}
myset = db(myquery)
rows = myset.select()
myset.update(myfield='somevalue')
myset.delete()
\end{lstlisting}

\inxx{Expression}

{\bf Expression} is something like an {\ft orderby} or {\ft groupby} expression. The Field class is derived from the Expression. Here is an example.
\begin{lstlisting}
myorder = db.mytable.myfield.upper() | db.mytable.id
db().select(db.table.ALL, orderby=myorder)
\end{lstlisting}

\goodbreak\section{Connection strings}

\inxx{connection strings}

A connection with the database is established by creating an instance of the DAL object:
\begin{lstlisting}
>>> db = DAL('sqlite://storage.db', pool_size=0)
\end{lstlisting}
{\ft db} is not a keyword; it is a local variable that stores the connection object {\ft DAL}. You are free to give it a different name. The constructor of {\ft DAL} requires a single argument, the connection string. The connection string is the only web2py code that depends on a specific back-end database. Here are examples of connection strings for specific types of supported back-end databases (in all cases, we assume the database is running from localhost on its default port and is named "test"):

\goodbreak\begin{center}
{\begin{tabular}{ll}\hline
{\bf SQLite}     & {\ft sqlite://storage.db}\\ \hline
{\bf MySQL}      & {\ft mysql://username:password@localhost/test}\\
{\bf PostgreSQL} & {\ft postgres://username:password@localhost/test}\\
{\bf MSSQL}      & {\ft mssql://username:password@localhost/test}\\
{\bf FireBird}   & {\ft firebird://username:password@localhost/test}\\
{\bf Oracle}     & {\ft oracle://username/password@test}\\
{\bf DB2}        & {\ft db2://username:password@test}\\
{\bf Ingres}     & {\ft ingres://username:password@localhost/test}\\
{\bf Sybase}     & {\ft sybase://username:password@localhost/test}\\
{\bf Informix}   & {\ft informix://username:password@test}\\
{\bf Teradata}   & {\ft teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=name}\\
{\bf Cubrid}     & {\ft cubrid://username:password@localhost/test}\\
{\bf SAPDB}      & {\ft sapdb://username:password@localhost/test}\\
{\bf IMAP}       & {\ft imap://user:password@server:port}\\
{\bf MongoDB}    & {\ft mongodb://username:password@localhost/test}\\
{\bf Google/SQL} & {\ft google:sql}\\
{\bf Google/NoSQL} & {\ft google:datastore} \\ \hline
\end{tabular}}
\end{center}
Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database "test" must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.

It is also possible to set the connection string to {\ft None}. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.

Some times you may need to generate SQL as if you had a connection but without actually connecting to the database. This can be done with

\begin{lstlisting}
db = DAL('...', do_connect=False)
\end{lstlisting}

In this case you will be able to call {\ft \_select}, {\ft \_insert}, {\ft \_update}, and {\ft \_delete} to generate SQL but not call {\ft select}, {\ft insert}, {\ft update}, and {\ft delete}. In most of the cases you can use {\ft do\_connect=False} even without having the required database drivers.

Notice that by default web2py uses utf8 character encoding for databases. If you work with existing databases that behave differently, you have to change it with the optional parameter {\ft db\_codec} like

\begin{lstlisting}
db = DAL('...', db_codec='latin1')
\end{lstlisting}
\noindent otherwise you'll get UnicodeDecodeErrors tickets.

\goodbreak\subsection{Connection pooling}

\inxx{connection pooling}

The second argument of the DAL constructor is the {\ft pool\_size}; it defaults to zero.

As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.

The {\ft pool\_size} parameter is ignored by SQLite and Google App Engine.

Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.

When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of {\ft pool\_size} and the max number of concurrent requests. This means that if {\ft pool\_size=10} but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If {\ft pool\_size=0} then connection pooling is not used.

Connection pooling is ignored for SQLite, since it would not yield any benefit.

\goodbreak\subsection{Connection failures}

If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.

When using connection pooling a connection is used, put back in the pool and then recycled. It is possible that while the connection is idle in pool the connection is closed by the database server. This can be because of a malfunction or a timeout. When this happens web2py detects it and re-establish the connection.

\goodbreak\subsection{Replicated databases}

The first argument of {\ft DAL(...)} can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:

\begin{lstlisting}
db = DAL(['mysql://...1','mysql://...2','mysql://...3'])
\end{lstlisting}

In this case the DAL tries to connect to the first and, on failure, it
will try the second and the third. This can also be used to distribute load
in a database master-slave configuration. We will talk more about this
in Chapter 13 in the context of scalability.

\goodbreak\section{Reserved keywords}

\inxx{reserved Keywords}

There is also another argument that can be passed to the DAL constructor to check table names and column names against reserved SQL keywords in target back-end databases.

This argument is {\ft check\_reserved} and it defaults to None.

This is a list of strings that contain the database back-end adapter names.

The adapter name is the same as used in the DAL connection string. So if you want to check against PostgreSQL and MSSQL then your connection string would look as follows:
\begin{lstlisting}
db = DAL('sqlite://storage.db',
         check_reserved=['postgres', 'mssql'])
\end{lstlisting}

The DAL will scan the keywords in the same order as of the list.

There are two extra options "all" and "common". If you specify all, it will check against all known SQL keywords. If you specify common, it will only check against common SQL keywords such as {\ft SELECT}, {\ft INSERT}, {\ft UPDATE}, etc.

For supported back-ends you may also specify if you would like to check against the non-reserved SQL keywords as well. In this case you would append {\ft \_nonreserved} to the name. For example:
\begin{lstlisting}
check_reserved=['postgres', 'postgres_nonreserved']
\end{lstlisting}

The following database backends support reserved words checking.

\goodbreak\begin{center}
{\begin{tabular}{ll}\hline
{\bf PostgreSQL} & {\ft postgres(\_nonreserved)}\\ \hline
{\bf MySQL} & {\ft mysql}\\
{\bf FireBird} & {\ft firebird(\_nonreserved)}\\
{\bf MSSQL} & {\ft mssql}\\
{\bf Oracle} & {\ft oracle} \\ \hline
\end{tabular}}
\end{center}
\goodbreak\section{{\ft DAL}, {\ft Table}, {\ft Field}}

The best way to understand the DAL API is to try each function yourself. This can be done interactively via the web2py shell, although ultimately, DAL code goes in the models and controllers.

Start by creating a connection. For the sake of example, you can use SQLite. Nothing in this discussion changes when you change the back-end engine.

\begin{lstlisting}
>>> db = DAL('sqlite://storage.db')
\end{lstlisting}

The database is now connected and the connection is stored in the global variable {\ft db}.

At any time you can retrieve the connection string.
\inxx{\_uri}
\begin{lstlisting}
>>> print db._uri
sqlite://storage.db
\end{lstlisting}
\noindent and the database name
\inxx{\_dbname}
\begin{lstlisting}
>>> print db._dbname
sqlite
\end{lstlisting}

The connection string is called a {\ft \_uri} because it is an instance of a Uniform Resource Identifier.

The DAL allows multiple connections with the same database or with different databases, even databases of different types. For now, we will assume the presence of a single database since this is the most common situation.

\inxx{define\_table} \inxx{Field}
\inxx{type} \inxx{length} \inxx{default} \inxx{requires} \inxx{required} \inxx{unique}
\inxx{notnull} \inxx{ondelete} \inxx{uploadfield} \inxx{uploadseparate} \inxx{migrate} \inxx{sql.log}

The most important method of a DAL is {\ft define\_table}:
\begin{lstlisting}
>>> db.define_table('person', Field('name'))
\end{lstlisting}

It defines, stores and returns a {\ft Table} object called "person" containing a field (column) "name". This object can also be accessed via {\ft db.person}, so you do not need to catch the return value.

Do not declare a field called "id", because one is created by web2py anyway. Every table has a field called "id" by default. It is an auto-increment integer field (starting at 1) used for cross-reference and for making every record unique, so "id" is a primary key. (Note: the id's starting at 1 is back-end specific. For example, this does not apply to the Google App Engine NoSQL.)

\inxx{named id field}
Optionally you can define a field of {\ft type='id'} and web2py will use this field as auto-increment id field. This is not recommended except when accessing legacy database tables. With some limitation, you can also use different primary keys and this is discussed in the section on "Legacy databases and keyed tables".

Tables can be defined only once but you can force web2py to redefine an existing table:

\begin{lstlisting}
db.define_table('person', Field('name'))
db.define_table('person', Field('name'), redefine=True)
\end{lstlisting}

The redefinition may trigger a migration if field content is different.

\begin{quote}Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the {\ft DAL(...,lazy\_tables=True)} attributes. Tables will be actually created only when accessed.\end{quote}
\goodbreak\section{Record representation}

It is optional but recommended to specify a format representation for records:
\begin{lstlisting}
>>> db.define_table('person', Field('name'), format='%(name)s')
\end{lstlisting}
\noindent or
\begin{lstlisting}
>>> db.define_table('person', Field('name'), format='%(name)s %(id)s')
\end{lstlisting}
\noindent or even more complex ones using a function:
\begin{lstlisting}
>>> db.define_table('person', Field('name'),
       format=lambda r: r.name or 'anonymous')
\end{lstlisting}

The format attribute will be used for two purposes:
\begin{itemize}
\item To represent referenced records in select/option drop-downs.

\item To set the {\ft db.othertable.person.represent} attribute for all fields referencing this table. This means that SQLTABLE will not show references by id but will use the format preferred representation instead.
\end{itemize}

\inxx{Field constructor}
These are the default values of a Field constructor:
\begin{lstlisting}
Field(name, 'string', length=None, default=None,
      required=False, requires='<default>',
      ondelete='CASCADE', notnull=False, unique=False,
      uploadfield=True, widget=None, label=None, comment=None,
      writable=True, readable=True, update=None, authorize=None,
      autodelete=False, represent=None, compute=None,
      uploadfolder=os.path.join(request.folder,'uploads'),
      uploadseparate=None,uploadfs=None)
\end{lstlisting}

Not all of them are relevant for every field. "length" is relevant only for fields of type "string". "uploadfield" and "authorize" are relevant only for fields of type "upload". "ondelete" is relevant only for fields of type "reference" and "upload".
\begin{itemize}
\item {\ft length} sets the maximum length of a "string", "password" or "upload" field.  If {\ft length} is not specified a default value is used but the default value is not guaranteed to be backward compatible. {\it To avoid unwanted migrations on upgrades, we recommend that you always specify the length for string, password and upload fields.}

\item {\ft default} sets the default value for the field. The default value is used when performing an insert if a value is not explicitly specified. It is also used to pre-populate forms built from the table using SQLFORM. Note, rather than being a fixed value, the default can instead be a function (including a lambda function) that returns a value of the appropriate type for the field. In that case, the function is called once for each record inserted, even when multiple records are inserted in a single transaction.

\item {\ft required} tells the DAL that no insert should be allowed on this table if a value for this field is not explicitly specified.

\item {\ft requires} is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the following table:
\end{itemize}

\goodbreak\begin{center}
{\begin{tabular}{ll}\hline
{\bf field type} & {\bf default field validators}\\ \hline
{\ft string} & {\ft IS\_LENGTH(length)} default length is 512\\
{\ft text} & {\ft IS\_LENGTH(65536)}\\
{\ft blob} & {\ft None}\\
{\ft boolean} & {\ft None}\\
{\ft integer} & {\ft IS\_INT\_IN\_RANGE(-1e100, 1e100)}\\
{\ft double} & {\ft IS\_FLOAT\_IN\_RANGE(-1e100, 1e100)}\\
{\ft decimal(n,m)} & {\ft IS\_DECIMAL\_IN\_RANGE(-1e100, 1e100)}\\
{\ft date} & {\ft IS\_DATE()}\\
{\ft time} & {\ft IS\_TIME()}\\
{\ft datetime} & {\ft IS\_DATETIME()}\\
{\ft password} & {\ft None}\\
{\ft upload} & {\ft None}\\
{\ft reference <table>}  & {\ft IS\_IN\_DB(db,table.field,format)}\\
{\ft list:string} & {\ft None}\\
{\ft list:integer} & {\ft None}\\
{\ft list:reference <table>} & {\ft IS\_IN\_DB(db,table.field,format,multiple=True)}\\
{\ft json} & {\ft IS\_JSON()}\\
{\ft bigint} & {\ft None}\\
{\ft big-id} & {\ft None}\\
{\ft big-reference} & {\ft None} \\ \hline
\end{tabular}}
\end{center}
Decimal requires and returns values as {\ft Decimal} objects, as defined in the Python {\ft decimal} module. SQLite does not handle the {\ft decimal} type so internally we treat it as a {\ft double}. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.

The {\ft big-id} and, {\ft big-reference} are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a {\ft bigint\_id} argument that when set to {\ft True} makes the {\ft id} fields and {\ft reference} fields {\ft big-id} and {\ft big-reference} respectively.

The {\ft list:} fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types {\ft ListProperty} and {\ft StringListProperty}) and back-port them all the other supported relational databases. On relational databases lists are stored as a {\ft text} field. The items are separated by a {\ft |} and each {\ft |} in string item is escaped as a {\ft ||}. They are discussed in their own section.

The {\ft json} field type is pretty much explanatory. It can store any json serializable object. It is designed to work specifically for MongoDB and backported to the other database adapters for portability.

\begin{quote}Notice that {\ft requires=...} is enforced at the level of forms, {\ft required=True} is enforced at the level of the DAL (insert), while {\ft notnull}, {\ft unique} and {\ft ondelete} are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.\end{quote}
\inxx{ondelete}

\begin{itemize}
\item {\ft ondelete} translates into the "ON DELETE" SQL statement. By default it is set to "CASCADE". This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set {\ft ondelete} to "NO ACTION" or "SET NULL".

\item {\ft notnull=True} translates into the "NOT NULL" SQL statement. It prevents the database from inserting null values for the field.

\item {\ft unique=True} translates into the "UNIQUE" SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.

\item {\ft uploadfield} applies only to fields of type "upload". A field of type "upload" stores the name of a file saved somewhere else, by default on the filesystem under the application "uploads/" folder. If {\ft uploadfield} is set, then the file is stored in a blob field within the same table and the value of {\ft uploadfield} is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.

\item {\ft uploadfolder} defaults to the application's "uploads/" folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,'static/temp') will upload files to the web2py/applications/myapp/static/temp folder.

\item {\ft uploadseparate} if set to True will upload files under different subfolders of the {\it uploadfolder} folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of {\ft uploadseparate} from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.

\item {\ft uploadfs} allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. {\ft uploadfs} must point to {\ft PyFileSystem}. \inxx{PyFileSystem} {\ft uploadfs}

\item {\ft widget} must be one of the available widget objects, including custom widgets, for example: {\ft SQLFORM.widgets.string.widget}. A list of available widgets will be discussed later. Each field type has a default widget.

\item {\ft label} is a string (or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.

\item {\ft comment}  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.

\item {\ft writable} if a field is writable, it can be edited in autogenerated create and update forms.

\item {\ft readable} if a field is readable, it will be visible in read-only forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.

\item {\ft update} contains the default value for this field when the record is updated.

\item {\ft compute} is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a {\ft dict}, and the dict will not include the current value of that, or any other compute field.

\item {\ft authorize} can be used to require access control on the corresponding field, for "upload" fields only. It will be discussed more in detail in the context of Authentication and Authorization.

\item {\ft autodelete} determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For "upload" fields only.

\item {\ft represent} can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:
\end{itemize}
\begin{lstlisting}
db.mytable.name.represent = lambda name,row: name.capitalize()
db.mytable.other_id.represent = lambda id,row: row.myfield
db.mytable.some_uploadfield.represent = lambda value,row: \
    A('get it', _href=URL('download', args=value))
\end{lstlisting}

\inxx{blob}
"blob" fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25\% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.

Most attributes of fields and tables can be modified after they are defined:

\begin{lstlisting}
db.define_table('person',Field('name',default=''),format='%(name)s')
db.person._format = '%(name)s/%(id)s'
db.person.name.default = 'anonymous'
\end{lstlisting}
(notice that attributes of tables are usually prefixed by an underscore to avoid conflict with possible field names).

You can list the tables that have been defined for a given database connection:

\inxx{tables}
\begin{lstlisting}
>>> print db.tables
['person']
\end{lstlisting}

You can also list the fields that have been defined for a given table:

\inxx{fields}
\begin{lstlisting}
>>> print db.person.fields
['id', 'name']
\end{lstlisting}

You can query for the type of a table:

\inxx{Table}
\begin{lstlisting}
>>> print type(db.person)
<class 'gluon.sql.Table'>
\end{lstlisting}
\noindent and you can access a table from the DAL connection using:
\begin{lstlisting}
>>> print type(db['person'])
<class 'gluon.sql.Table'>
\end{lstlisting}

Similarly you can access fields from their name in multiple equivalent ways:
\begin{lstlisting}
>>> print type(db.person.name)
<class 'gluon.sql.Field'>
>>> print type(db.person['name'])
<class 'gluon.sql.Field'>
>>> print type(db['person']['name'])
<class 'gluon.sql.Field'>
\end{lstlisting}

Given a field, you can access the attributes set in its definition:
\begin{lstlisting}
>>> print db.person.name.type
string
>>> print db.person.name.unique
False
>>> print db.person.name.notnull
False
>>> print db.person.name.length
32
\end{lstlisting}
\noindent including its parent table, tablename, and parent connection:
\begin{lstlisting}
>>> db.person.name._table == db.person
True
>>> db.person.name._tablename == 'person'
True
>>> db.person.name._db == db
True
\end{lstlisting}

A field also has methods. Some of them are used to build queries and we will see them later.
A special method of the field object is {\ft validate} and it calls the validators for the field.

\begin{lstlisting}
print db.person.name.validate('John')
\end{lstlisting}
\noindent which returns a tuple {\ft (value, error)}. {\ft error} is {\ft None} if the input passes validation.

\goodbreak\section{Migrations}

\inxx{migrations}

{\ft define\_table} checks whether or not the corresponding table exists. If it does not, it generates the SQL to create it and executes the SQL. If the table does exist but differs from the one being defined, it generates the SQL to alter the table and executes it. If a field has changed type but not name, it will try to convert the data (If you do not want this, you need to redefine the table twice, the first time, letting web2py drop the field by removing it, and the second time adding the newly defined field so that web2py can create it.). If the table exists and matches the current definition, it will leave it alone. In all cases it will create the {\ft db.person} object that represents the table.

We refer to this behavior as a "migration". web2py logs all migrations and migration attempts in the file "databases/sql.log".

The first argument of {\ft define\_table} is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional last argument called "migrate" which must be referred to explicitly by name as in:
\begin{lstlisting}
>>> db.define_table('person', Field('name'), migrate='person.table')
\end{lstlisting}

The value of migrate is the filename (in the "databases" folder for the application) where web2py stores internal migration information for this table.
These files are very important and should never be removed while the corresponding tables exist.  In cases where a table has been dropped and the corresponding file still exist, it can be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in {\ft define\_table}.
The best practice is to give an explicit name to the migrate table.

There may not be two tables in the same application with the same migrate filename.

The DAL class also takes a "migrate" argument, which determines the default value of migrate for calls to {\ft define\_table}. For example,
\begin{lstlisting}
>>> db = DAL('sqlite://storage.db', migrate=False)
\end{lstlisting}
\noindent will set the default value of migrate to False whenever {\ft db.define\_table} is called without a migrate argument.

\begin{quote}Notice that web2py only migrates new columns, removed columns, and changes in column type (not in sqlite). web2py does not migrate changes in attributes such as changes in the values of {\ft default}, {\ft unique}, {\ft notnull}, and {\ft ondelete}.\end{quote}
Migrations can be disabled for all tables at the moment of connection:

\begin{lstlisting}
db = DAL(...,migrate_enabled=False)
\end{lstlisting}

This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.

\goodbreak\section{Fixing broken migrations}

\inxx{fake\_migrate}

There are two common problems with migrations and there are ways to recover from them.

One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.

If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.

The solution consists in updating all records of the table and updating the values in the column in question with None.

The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.

The solution consists of disabling migrations for all tables and enabling fake migrations:
\begin{lstlisting}
db.define_table(....,migrate=False,fake_migrate=True)
\end{lstlisting}

This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the {\ft fake\_migrate=True} attribute.

Before attempting to fix migration problems it is prudent to make a copy of "applications/yourapp/databases/*.table" files.

Migration problems can also be fixed for all tables at once:

\begin{lstlisting}
db = DAL(...,fake_migrate_all=True)
\end{lstlisting}

Although if this fails, it will not help in narrowing down the problem.

\goodbreak\section{{\ft insert}}

Given a table, you can insert records

\inxx{insert}
\begin{lstlisting}
>>> db.person.insert(name="Alex")
1
>>> db.person.insert(name="Bob")
2
\end{lstlisting}

Insert returns the unique "id" value of each record inserted.

You can truncate the table, i.e., delete all records and reset the counter of the id.

\inxx{truncate}
\begin{lstlisting}
>>> db.person.truncate()
\end{lstlisting}

Now, if you insert a record again, the counter starts again at 1 (this is back-end specific and does not apply to Google NoSQL):
\begin{lstlisting}
>>> db.person.insert(name="Alex")
1
\end{lstlisting}

Notice you can pass parameters to {\ft truncate}, for example you can tell SQLITE to restart the id counter.

\begin{lstlisting}
db.person.truncate('RESTART IDENTITY CASCADE')
\end{lstlisting}

The argument is in raw SQL and therefore engine specific.

\inxx{bulk\_insert}
web2py also provides a bulk\_insert method
\begin{lstlisting}
>>> db.person.bulk_insert([{'name':'Alex'}, {'name':'John'}, {'name':'Tim'}])
[3,4,5]
\end{lstlisting}

It takes a list of dictionaries of fields to be inserted and performs multiple inserts at once. It returns the IDs of the inserted records. On the supported relational databases there is no advantage in using this function as opposed to looping and performing individual inserts but on Google App Engine NoSQL, there is a major speed advantage.

\goodbreak\section{{\ft commit} and {\ft rollback}}

No create, drop, insert, truncate, delete, or update operation is actually committed until you issue the commit command

\inxx{commit}
\begin{lstlisting}
>>> db.commit()
\end{lstlisting}

To check it let's insert a new record:
\begin{lstlisting}
>>> db.person.insert(name="Bob")
2
\end{lstlisting}
\noindent and roll back, i.e., ignore all operations since the last commit:

\inxx{rollback}
\begin{lstlisting}
>>> db.rollback()
\end{lstlisting}

If you now insert again, the counter will again be set to 2, since the previous insert was rolled back.
\begin{lstlisting}
>>> db.person.insert(name="Bob")
2
\end{lstlisting}

Code in models, views and controllers is enclosed in web2py code that looks like this:
\begin{lstlisting}
try:
     execute models, controller function and view
except:
     rollback all connections
     log the traceback
     send a ticket to the visitor
else:
     commit all connections
     save cookies, sessions and return the page
\end{lstlisting}

There is no need to ever call {\ft commit}  or {\ft rollback} explicitly in web2py unless one needs more granular control.

\goodbreak\section{Raw SQL}

\goodbreak\subsection{Timing queries}

All queries are automatically timed by web2py. The variable {\ft db.\_timings} is a list of tuples. Each tuple contains the raw SQL query as passed to the database driver and the time it took to execute in seconds. This variable can be displayed in views using the toolbar:

\begin{lstlisting}[keywords={}]
{{=response.toolbar()}}
\end{lstlisting}

\goodbreak\subsection{{\ft executesql}}

The DAL allows you to explicitly issue SQL statements.

\inxx{executesql}
\begin{lstlisting}
>>> print db.executesql('SELECT * FROM person;')
[(1, u'Massimo'), (2, u'Massimo')]
\end{lstlisting}

In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.
{\ft executesql} takes four optional arguments: {\ft placeholders}, {\ft as\_dict}, {\ft fields} and {\ft colnames}.
{\ft placeholders} is an optional
sequence of values to be substituted in
or, if supported by the DB driver, a dictionary with keys
matching named placeholders in your SQL.

If {\ft as\_dict} is set to True,
and the results cursor returned by the DB driver will be
converted to a sequence of dictionaries keyed with the db
field names.  Results returned with {\ft as\_dict = True }are
the same as those returned when applying {\bf.as\_list()} to a normal select.
\begin{lstlisting}
[{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]
\end{lstlisting}

The {\ft fields} argument is a list of DAL Field objects that match the
fields returned from the DB. The Field objects should be part of one or
more Table objects defined on the DAL object. The {\ft fields} list can
include one or more DAL Table objects in addition to or instead of
including Field objects, or it can be just a single table (not in a
list). In that case, the Field objects will be extracted from the
table(s).

Instead of specifying the {\ft fields} argument, the {\ft colnames} argument
can be specified as a list of field names in tablename.fieldname format.
Again, these should represent tables and fields defined on the DAL
object.

It is also possible to specify both {\ft fields} and the associated
{\ft colnames}. In that case, {\ft fields} can also include DAL Expression
objects in addition to Field objects. For Field objects in "fields",
the associated {\ft colnames} must still be in tablename.fieldname format.
For Expression objects in {\ft fields}, the associated {\ft colnames} can
be any arbitrary labels.

Notice, the DAL Table objects referred to by {\ft fields} or {\ft colnames} can
be dummy tables and do not have to represent any real tables in the
database. Also, note that the {\ft fields} and {\ft colnames} must be in the
same order as the fields in the results cursor returned from the DB.

\goodbreak\subsection{{\ft \_lastsql}}

Whether SQL was executed manually using executesql or was SQL generated by the DAL, you can always find the SQL code in {\ft db.\_lastsql}. This is useful for debugging purposes:

\inxx{\_lastdb}
\begin{lstlisting}
>>> rows = db().select(db.person.ALL)
>>> print db._lastsql
SELECT person.id, person.name FROM person;
\end{lstlisting}

\begin{quote}web2py never generates queries using the "*" operator. web2py is always explicit when selecting fields.\end{quote}
\goodbreak\section{{\ft drop}}

Finally, you can drop tables and all data will be lost:

\inxx{drop}
\begin{lstlisting}
>>> db.person.drop()
\end{lstlisting}

\goodbreak\section{Indexes}

Currently the DAL API does not provide a command to create indexes on tables, but this can be done using the {\ft executesql} command. This is because the existence of indexes can make migrations complex, and it is better to deal with them explicitly. Indexes may be needed for those fields that are used in recurrent queries.

Here is an example of how to {\footnotesize\href{http://www.sqlite.org/lang\_createindex.html}{create an index using SQL in SQLite}}:
\begin{lstlisting}
>>> db = DAL('sqlite://storage.db')
>>> db.define_table('person', Field('name'))
>>> db.executesql('CREATE INDEX IF NOT EXISTS myidx ON person (name);')
\end{lstlisting}

Other database dialects have very similar syntaxes but may not support the optional "IF NOT EXISTS" directive.

\goodbreak\section{Legacy databases and keyed tables}
\noindent web2py can connect to legacy databases under some conditions.

The easiest way is when these conditions are met:
\begin{itemize}
\item Each table must have a unique auto-increment integer field called "id"

\item Records must be referenced exclusively using the "id" field.
\end{itemize}

\begin{quote}When accessing an existing table, i.e., a table not created by web2py in the current application, always set {\ft migrate=False}.\end{quote}
If the legacy table has an auto-increment integer field but it is not called "id", web2py can still access it but the table definition must contain explicitly as {\ft Field('....','id')} where... is the name of the auto-increment integer field.

\inxx{keyed table}

Finally if the legacy table uses a primary key that is not an auto-increment id field it is possible to use a "keyed table", for example:
\begin{lstlisting}
db.define_table('account',
    Field('accnum','integer'),
    Field('acctype'),
    Field('accdesc'),
    primarykey=['accnum','acctype'],
    migrate=False)
\end{lstlisting}

\begin{itemize}
\item {\ft primarykey} is a list of the field names that make up the primary key.

\item All primarykey fields have a {\ft NOT NULL} set even if not specified.

\item Keyed tables can only reference other keyed tables.

\item Referencing fields must use the {\ft reference tablename.fieldname} format.

\item The {\ft update\_record} function is not available for Rows of keyed tables.
\end{itemize}

\begin{quote}Note that currently this is only available for DB2, MS-SQL, Ingres and Informix, but others can be easily added.\end{quote}
At the time of writing, we cannot guarantee that the {\ft primarykey} attribute works with every existing legacy table and every supported database backend.
For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.

\goodbreak\section{Distributed transaction}

\inxx{distributed transactions}

\begin{quote}At the time of writing this feature is only supported
by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.\end{quote}
Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:
\begin{lstlisting}
db_a = DAL('postgres://...')
db_b = DAL('postgres://...')
\end{lstlisting}

In your models or controllers, you can commit them concurrently with:
\begin{lstlisting}
DAL.distributed_transaction_commit(db_a, db_b)
\end{lstlisting}

On failure, this function rolls back and raises an {\ft Exception}.

In controllers, when one action returns, if you have two distinct connections and you do not call the above function, web2py commits them separately. This means there is a possibility that one of the commits succeeds and one fails. The distributed transaction prevents this from happening.

\goodbreak\section{More on uploads}

Consider the following model:
\begin{lstlisting}
>>> db.define_table('myfile',
    Field('image', 'upload', default='path/'))
\end{lstlisting}

In the case of an 'upload' field, the default value can optionally be set to a path (an absolute path or a path relative to the current app folder) and the default image will be set to a copy of the file at the path. A new copy is made for each new record that does not specify an image.

Normally an insert is handled automatically via a SQLFORM or a crud form (which is a SQLFORM) but occasionally you already have the file on the filesystem and want to upload it programmatically. This can be done in this way:
\begin{lstlisting}
>>> stream = open(filename, 'rb')
>>> db.myfile.insert(image=db.myfile.image.store(stream, filename))
\end{lstlisting}

It is also possible to insert a file in a simpler way and have the insert method call store automatically:

\begin{lstlisting}
>>> stream = open(filename, 'rb')
>>> db.myfile.insert(image=stream)
\end{lstlisting}

In this case the filename is obtained from the stream object if available.

The {\ft store} method of the upload field object takes a file stream and a filename. It uses the filename to determine the extension (type) of the file, creates a new temp name for the file (according to web2py upload mechanism) and loads the file content in this new temp file (under the uploads folder unless specified otherwise). It returns the new temp name, which is then stored in the {\ft image} field of the {\ft db.myfile} table.

Note, if the file is to be stored in an associated blob field rather than the file system, the {\ft store()} method will not insert the file in the blob field (because {\ft store()} is called before the insert), so the file must be explicitly inserted into the blob field:
\begin{lstlisting}
>>> db.define_table('myfile',
        Field('image', 'upload', uploadfield='image_file'),
        Field('image_file', 'blob'))
>>> stream = open(filename, 'rb')
>>> db.myfile.insert(image=db.myfile.image.store(stream, filename),
        image_file=stream.read())
\end{lstlisting}

The opposite of {\ft .store} is {\ft .retrieve}:

\begin{lstlisting}
>>> row = db(db.myfile).select().first()
>>> (filename, stream) = db.myfile.image.retrieve(row.image)
>>> import shutil
>>> shutil.copyfileobj(stream,open(filename,'wb'))
\end{lstlisting}

\goodbreak\section{{\ft Query}, {\ft Set}, {\ft Rows}}

Let's consider again the table defined (and dropped) previously and insert three records:
\begin{lstlisting}
>>> db.define_table('person', Field('name'))
>>> db.person.insert(name="Alex")
1
>>> db.person.insert(name="Bob")
2
>>> db.person.insert(name="Carl")
3
\end{lstlisting}

You can store the table in a variable. For example, with variable {\ft person}, you could do:

\inxx{Table}
\begin{lstlisting}
>>> person = db.person
\end{lstlisting}

You can also store a field in a variable such as {\ft name}.  For example, you could also do:

\inxx{Field}
\begin{lstlisting}
>>> name = person.name
\end{lstlisting}

You can even build a query (using operators like ==, !=, <, >, <=, >=, like, belongs) and store the query in a variable {\ft q} such as in:

\inxx{Query}
\begin{lstlisting}
>>> q = name=='Alex'
\end{lstlisting}

When you call {\ft db} with a query, you define a set of records. You can store it in a variable {\ft s} and write:

\inxx{Set}
\begin{lstlisting}
>>> s = db(q)
\end{lstlisting}

Notice that no database query has been performed so far. DAL + Query simply define a set of records in this db that match the query.
web2py determines from the query which table (or tables) are involved and, in fact, there is no need to specify that.

\goodbreak\section{{\ft select}}

Given a Set, {\ft s}, you can fetch the records with the command {\ft select}:

\inxx{Rows} \inxx{select}
\begin{lstlisting}
>>> rows = s.select()
\end{lstlisting}

\inxx{Row}
It returns an iterable object of class {\ft gluon.sql.Rows} whose elements are Row objects. {\ft gluon.sql.Row} objects act like dictionaries, but their elements can also be accessed as attributes, like {\ft gluon.storage.Storage}.The former differ from the latter because its values are read-only.

The Rows object allows looping over the result of the select and printing the selected field values for each row:
\begin{lstlisting}
>>> for row in rows:
        print row.id, row.name
1 Alex
\end{lstlisting}

You can do all the steps in one statement:
\begin{lstlisting}
>>> for row in db(db.person.name=='Alex').select():
        print row.name
Alex
\end{lstlisting}

\inxx{ALL}

The select command can take arguments. All unnamed arguments are interpreted as the names of the fields that you want to fetch. For example, you can be explicit on fetching field "id" and field "name":
\begin{lstlisting}
>>> for row in db().select(db.person.id, db.person.name):
        print row.name
Alex
Bob
Carl
\end{lstlisting}

The table attribute ALL allows you to specify all fields:
\begin{lstlisting}
>>> for row in db().select(db.person.ALL):
        print row.name
Alex
Bob
Carl
\end{lstlisting}

Notice that there is no query string passed to db. web2py understands that if you want all fields of the table person without additional information then you want all records of the table person.

An equivalent alternative syntax is the following:
\begin{lstlisting}
>>> for row in db(db.person.id > 0).select():
        print row.name
Alex
Bob
Carl
\end{lstlisting}
\noindent and web2py understands that if you ask for all records of the table person (id > 0) without additional information, then you want all the fields of table person.

Given one row

\begin{lstlisting}
row = rows[0]
\end{lstlisting}
\noindent you can extract its values using multiple equivalent expressions:

\begin{lstlisting}
>>> row.name
Alex
>>> row['name']
Alex
>>> row('person.name')
Alex
\end{lstlisting}

The latter syntax is particularly handy when selecting en expression instead of a column. We will show this later.

You can also do
\begin{lstlisting}
rows.compact = False
\end{lstlisting}
to disable the notation
\begin{lstlisting}
row[i].name
\end{lstlisting}
and enable, instead, the less compact notation:
\begin{lstlisting}
row[i].person.name
\end{lstlisting}
Yes this is unusual and rarely needed.

\goodbreak\subsection{Shortcuts}

\inxx{DAL shortcuts}

The DAL supports various code-simplifying shortcuts.
In particular:
\begin{lstlisting}
myrecord = db.mytable[id]
\end{lstlisting}
\noindent returns the record with the given {\ft id} if it exists. If the {\ft id} does not exist, it returns {\ft None}. The above statement is equivalent to

\begin{lstlisting}
myrecord = db(db.mytable.id==id).select().first()
\end{lstlisting}

You can delete records by id:

\begin{lstlisting}
del db.mytable[id]
\end{lstlisting}
\noindent and this is equivalent to

\begin{lstlisting}
db(db.mytable.id==id).delete()
\end{lstlisting}
\noindent and deletes the record with the given {\ft id}, if it exists.

You can insert records:

\begin{lstlisting}
db.mytable[0] = dict(myfield='somevalue')
\end{lstlisting}

It is equivalent to

\begin{lstlisting}
db.mytable.insert(myfield='somevalue')
\end{lstlisting}
\noindent and it creates a new record with field values specified by the dictionary on the right hand side.

You can update records:

\begin{lstlisting}
db.mytable[id] = dict(myfield='somevalue')
\end{lstlisting}
\noindent which is equivalent to

\begin{lstlisting}
db(db.mytable.id==id).update(myfield='somevalue')
\end{lstlisting}
\noindent and it updates an existing record with field values specified by the dictionary on the right hand side.

\goodbreak\subsection{Fetching a {\ft Row}}

Yet another convenient syntax is the following:

\begin{lstlisting}
record = db.mytable(id)
record = db.mytable(db.mytable.id==id)
record = db.mytable(id,myfield='somevalue')
\end{lstlisting}

Apparently similar to {\ft db.mytable[id]} the above syntax is more flexible and safer. First of all it checks whether {\ft id} is an int (or {\ft str(id)} is an int) and returns {\ft None} if not (it never raises an exception). It also allows to specify multiple conditions that the record must meet. If they are not met, it also returns {\ft None}.

\goodbreak\subsection{Recursive {\ft select}s}

\inxx{recursive selects}

Consider the previous table person and a new table "thing" referencing a "person":
\begin{lstlisting}
>>> db.define_table('thing',
        Field('name'),
        Field('owner','reference person'))
\end{lstlisting}
\noindent and a simple select from this table:
\begin{lstlisting}
>>> things = db(db.thing).select()
\end{lstlisting}
\noindent which is equivalent to

\begin{lstlisting}
>>> things = db(db.thing._id>0).select()
\end{lstlisting}
\noindent where {\ft .\_id} is a reference to the primary key of the table. Normally {\ft db.thing.\_id} is the same as {\ft db.thing.id} and we will assume that in most of this book. \inxx{\_id}

For each Row of things it is possible to fetch not just fields from the selected table (thing) but also from linked tables (recursively):
\begin{lstlisting}
>>> for thing in things: print thing.name, thing.owner.name
\end{lstlisting}

Here {\ft thing.owner.name} requires one database select for each thing in things and it is therefore inefficient. We suggest using joins whenever possible instead of recursive selects, nevertheless this is convenient and practical when accessing individual records.

You can also do it backwards, by selecting the things referenced by a person:

\begin{lstlisting}
person =  db.person(id)
for thing in person.thing.select(orderby=db.thing.name):
    print person.name, 'owns', thing.name
\end{lstlisting}

In this last expressions {\ft person.thing} is a shortcut for

\begin{lstlisting}
db(db.thing.owner==person.id)
\end{lstlisting}
\noindent i.e. the Set of {\ft thing}s referenced by the current {\ft person}. This syntax breaks down if the referencing table has multiple references to the referenced table. In this case one needs to be more explicit and use a full Query.

\goodbreak\subsection{Serializing {\ft Rows} in views}

Given the following action containing a query
\inxx{SQLTABLE}

\begin{lstlisting}
def index()
    return dict(rows = db(query).select())
\end{lstlisting}

The result of a select can be displayed in a view with the following syntax:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Records</h1>
{{=rows}}
\end{lstlisting}

Which is equivalent to:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Records</h1>
{{=SQLTABLE(rows)}}
\end{lstlisting}

{\ft SQLTABLE} converts the rows into an HTML table with a header containing the column names and one row per record. The rows are marked as alternating class "even" and class "odd". Under the hood, Rows is first converted into a SQLTABLE object (not to be confused with Table) and then serialized. The values extracted from the database are also formatted by the validators associated to the field and then escaped.

Yet it is possible and sometimes convenient to call SQLTABLE explicitly.

The SQLTABLE constructor takes the following optional arguments:

\begin{itemize}
\item {\ft linkto} the URL or an action to be used to link reference fields (default to None)

\item {\ft upload} the URL or the download action to allow downloading of uploaded files (default to None)

\item {\ft headers} a dictionary mapping field names to their labels to be used as headers (default to {\ft \{\}}). It can also be an instruction. Currently we support {\ft headers='fieldname:capitalize'}.

\item {\ft truncate} the number of characters for truncating long values in the table (default is 16)

\item {\ft columns} the list of fieldnames to be shown as columns (in tablename.fieldname format).
\end{itemize}
Those not listed are not displayed (defaults to all).
\begin{itemize}
\item {\ft **attributes} generic helper attributes to be passed to the most external TABLE object.
\end{itemize}

Here is an example:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h1>Records</h1>
{{=SQLTABLE(rows,
     headers='fieldname:capitalize',
     truncate=100,
     upload=URL('download'))
}}
\end{lstlisting}

\inxx{SQLFORM.grid} \inxx{SQLFORM.smartgrid}

\begin{quote}{\ft SQLTABLE} is useful but there are times when one needs more. {\ft SQLFORM.grid} is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. {\ft SQLFORM.smartgrid} is a further generalization that allows all of the above but also creates buttons to access referencing records.\end{quote}
Here is an example of usage of {\ft SQLFORM.grid}:

\begin{lstlisting}
def index():
    return dict(grid=SQLFORM.grid(query))
\end{lstlisting}
\noindent and the corresponding view:

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=grid}}
\end{lstlisting}

{\ft SQLFORM.grid} and {\ft SQLFORM.smartgrid} should be preferred to {\ft SQLTABLE} because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter 8.

\goodbreak\subsection{{\ft orderby}, {\ft groupby}, {\ft limitby}, {\ft distinct}, {\ft having}}

The {\ft select} command takes five optional arguments: orderby, groupby, limitby, left and cache. Here we discuss the first three.

You can fetch the records sorted by name:

\inxx{orderby} \inxx{groupby} \inxx{having}
\begin{lstlisting}
>>> for row in db().select(
        db.person.ALL, orderby=db.person.name):
        print row.name
Alex
Bob
Carl
\end{lstlisting}

You can fetch the records sorted by name in reverse order (notice the tilde):
\begin{lstlisting}
>>> for row in db().select(
        db.person.ALL, orderby=~db.person.name):
        print row.name
Carl
Bob
Alex
\end{lstlisting}

You can have the fetched records appear in random order:
\begin{lstlisting}
>>> for row in db().select(
        db.person.ALL, orderby='<random>'):
        print row.name
Carl
Alex
Bob
\end{lstlisting}

\begin{quote}The use of {\ft orderby='<random>'} is not supported on Google NoSQL.  However, in this situation and likewise in many others where built-ins are insufficient, imports can be used:
\begin{lstlisting}
import random
rows=db(...).select().sort(lambda row: random.random())
\end{lstlisting}\end{quote}
And you can sort the records according to multiple fields by concatenating them with a "|":
\begin{lstlisting}
>>> for row in db().select(
        db.person.ALL, orderby=db.person.name|db.person.id):
        print row.name
Carl
Bob
Alex
\end{lstlisting}

Using {\ft groupby} together with {\ft orderby}, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):
\begin{lstlisting}
>>> for row in db().select(
        db.person.ALL,
        orderby=db.person.name, groupby=db.person.name):
        print row.name
Alex
Bob
Carl
\end{lstlisting}

You can use {\ft having} in conjunction with {\ft groupby} to group conditionally (only those {\ft having} the condition are grouped.

\begin{lstlisting}
>>> print db(query1).select(db.person.ALL, groupby=db.person.name, having=query2)
\end{lstlisting}

Notice that query1 filters records to be displayed, query2 filters records to be grouped.

\inxx{distinct}

With the argument {\ft distinct=True}, you can specify that you only want to select distinct records. This has the same effect as grouping using all specified fields except that it does not require sorting. When using distinct it is important not to select ALL fields, and in particular not to select the "id" field, else all records will always be distinct.

Here is an example:
\begin{lstlisting}
>>> for row in db().select(db.person.name, distinct=True):
        print row.name
Alex
Bob
Carl
\end{lstlisting}

Notice that {\ft distinct} can also be an expression for example:
\begin{lstlisting}
>>> for row in db().select(db.person.name,distinct=db.person.name):
        print row.name
Alex
Bob
Carl
\end{lstlisting}

With limitby=(min, max), you can select a subset of the records from offset=min to but not including offset=max (in this case, the first two starting at zero):

\inxx{limitby}
\begin{lstlisting}
>>> for row in db().select(db.person.ALL, limitby=(0, 2)):
        print row.name
Alex
Bob
\end{lstlisting}

\goodbreak\subsection{Logical operators}

Queries can be combined using the binary AND operator "{\ft \&}":

\inxx{and} \inxx{or} \inxx{not}
\begin{lstlisting}
>>> rows = db((db.person.name=='Alex') & (db.person.id>3)).select()
>>> for row in rows: print row.id, row.name
4 Alex
\end{lstlisting}
\noindent and the binary OR operator "{\ft |}":
\begin{lstlisting}
>>> rows = db((db.person.name=='Alex') | (db.person.id>3)).select()
>>> for row in rows: print row.id, row.name
1 Alex
\end{lstlisting}

You can negate a query (or sub-query) with the "{\ft !=}" binary operator:
\begin{lstlisting}
>>> rows = db((db.person.name!='Alex') | (db.person.id>3)).select()
>>> for row in rows: print row.id, row.name
2 Bob
3 Carl
\end{lstlisting}
\noindent or by explicit negation with the "{\ft ~}" unary operator:
\begin{lstlisting}
>>> rows = db(~(db.person.name=='Alex') | (db.person.id>3)).select()
>>> for row in rows: print row.id, row.name
2 Bob
3 Carl
\end{lstlisting}

\begin{quote}Due to Python restrictions in overloading "{\ft and}" and "{\ft or}" operators, these cannot be used in forming queries.  The binary operators "{\ft \&}" and "{\ft |}" must be used instead. Note that these operators (unlike "{\ft and}" and "{\ft or}") have higher precedence than comparison operators, so the "extra" parentheses in the above examples are mandatory. Similarly, the unary operator "{\ft ~}" has higher precedence than comparison operators, so {\ft ~}-negated comparisons must also be parenthesized.\end{quote}
It is also possible to build queries using in-place logical operators:

\begin{lstlisting}
>>> query = db.person.name!='Alex'
>>> query &= db.person.id>3
>>> query |= db.person.name=='John'
\end{lstlisting}

\goodbreak\subsection{{\ft count}, {\ft isempty}, {\ft delete}, {\ft update}}

You can count records in a set:

\inxx{count} \inxx{isempty}

\begin{lstlisting}
>>> print db(db.person.id > 0).count()
3
\end{lstlisting}

Notice that {\ft count} takes an optional {\ft distinct} argument which defaults to False, and it works very much like the same argument for {\ft select}. {\ft count} has also a {\ft cache} argument that works very much like the equivalent argument of the {\ft select} method.

Sometimes you may need to check if a table is empty. A more efficient way than counting is using the {\ft isempty} method:

\begin{lstlisting}
>>> print db(db.person.id > 0).isempty()
False
\end{lstlisting}
\noindent or equivalently:

\begin{lstlisting}
>>> print db(db.person).isempty()
False
\end{lstlisting}

You can delete records in a set:

\inxx{delete}
\begin{lstlisting}
>>> db(db.person.id > 3).delete()
\end{lstlisting}

And you can update all records in a set by passing named arguments corresponding to the fields that need to be updated:

\inxx{update}
\begin{lstlisting}
>>> db(db.person.id > 3).update(name='Ken')
\end{lstlisting}

\goodbreak\subsection{Expressions}

The value assigned an update statement can be an expression. For example consider this model
\begin{lstlisting}
>>> db.define_table('person',
        Field('name'),
        Field('visits', 'integer', default=0))
>>> db(db.person.name == 'Massimo').update(
        visits = db.person.visits + 1)
\end{lstlisting}

The values used in queries can also be expressions
\begin{lstlisting}
>>> db.define_table('person',
        Field('name'),
        Field('visits', 'integer', default=0),
        Field('clicks', 'integer', default=0))
>>> db(db.person.visits == db.person.clicks + 1).delete()
\end{lstlisting}

\goodbreak\subsection{{\ft case} \inxx{case}}

An expression can contain a case clause for example:

\begin{lstlisting}
>>> db.define_table('person',Field('name'))
>>> condition = db.person.name.startswith('M')
>>> yes_or_no = condition.case('Yes','No')
>>> for row in db().select(db.person.name, yes_or_no):
...     print row.person.name,  row(yes_or_no)
Max Yes
John No
\end{lstlisting}

\goodbreak\subsection{{\ft update\_record}}

\inxx{update\_record}
web2py also allows updating a single record that is already in memory using {\ft update\_record}

\begin{lstlisting}
>>> row = db(db.person.id==2).select().first()
>>> row.update_record(name='Curt')
\end{lstlisting}

{\ft update\_record} should not be confused with

\begin{lstlisting}
>>> row.update(name='Curt')
\end{lstlisting}
\noindent because for a single row, the method {\ft update} updates the row object but not the database record, as in the case of {\ft update\_record}.

It is also possible to change the attributes of a row (one at a time) and then call {\ft update\_record()} without arguments to save the changes:

\begin{lstlisting}
>>> row = db(db.person.id > 2).select().first()
>>> row.name = 'Curt'
>>> row.update_record() # saves above change
\end{lstlisting}

The {\ft update\_record} method is available only if the table's {\ft id} field is included in the select, and {\ft cacheable} is not set to {\ft True}.

\goodbreak\subsection{Inserting and updating from a dictionary}

A common issue consists of needing to insert or update records in a table where the name of the table, the field to be updated, and the value for the field are all stored in variables. For example: {\ft tablename}, {\ft fieldname}, and {\ft value}.

The insert can be done using the following syntax:

\begin{lstlisting}
db[tablename].insert(**{fieldname:value})
\end{lstlisting}:

The update of record with given id can be done with: \inxx{\_id}

\begin{lstlisting}
db(db[tablename]._id==id).update(**{fieldname:value})
\end{lstlisting}

Notice we used {\ft table.\_id} instead of {\ft table.id}. In this way the query works even for tables with a field of type "id" which has a name other than "id".

\goodbreak\subsection{{\ft first} and {\ft last}}

\inxx{first} \inxx{last}

Given a Rows object containing records:

\begin{lstlisting}
>>> rows = db(query).select()
>>> first_row = rows.first()
>>> last_row = rows.last()
\end{lstlisting}
\noindent are equivalent to
\begin{lstlisting}
>>> first_row = rows[0] if len(rows)>0 else None
>>> last_row = rows[-1] if len(rows)>0 else None
\end{lstlisting}

\goodbreak\subsection{{\ft as\_dict} and {\ft as\_list}}

\inxx{as\_list} \inxx{as\_dict}

A Row object can be serialized into a regular dictionary using the {\ft as\_dict()} method and a Rows object can be serialized into a list of dictionaries using the {\ft as\_list()} method. Here are some examples:
\begin{lstlisting}
>>> rows = db(query).select()
>>> rows_list = rows.as_list()
>>> first_row_dict = rows.first().as_dict()
\end{lstlisting}

These methods are convenient for passing Rows to generic views and or to store Rows in sessions (since Rows objects themselves cannot be serialized since contain a reference to an open DB connection):
\begin{lstlisting}
>>> rows = db(query).select()
>>> session.rows = rows # not allowed!
>>> session.rows = rows.as_list() # allowed!
\end{lstlisting}

\goodbreak\subsection{Combining rows}

Row objects can be combined at the Python level. Here we assume:

\begin{lstlisting}
>>> print rows1
person.name
Max
Tim
>>> print rows2
person.name
John
Tim
\end{lstlisting}

You can do a union of the records in two set of rows:

\begin{lstlisting}
>>> rows3 = rows1 & rows2
>>> print rows3
name
Max
Tim
John
Tim
\end{lstlisting}

You can do a union of the records removing duplicates:

\begin{lstlisting}
>>> rows3 = rows1 | rows2
>>> print rows3
name
Max
Tim
John
\end{lstlisting}

\goodbreak\subsection{{\ft find}, {\ft exclude}, {\ft sort}}

\inxx{find} \inxx{exclude} \inxx{sort}

There are times when one needs to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The {\ft find}, {\ft exclude} and {\ft sort} objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:
\begin{itemize}
\item {\ft find} returns a new set of Rows filtered by a condition and leaves the original unchanged.

\item {\ft exclude} returns a new set of Rows filtered by a condition and removes them from the original Rows.

\item {\ft sort} returns a new set of Rows sorted by a condition and leaves the original unchanged.
\end{itemize}

All these methods take a single argument, a function that acts on each individual row.

Here is an example of usage:
\begin{lstlisting}
>>> db.define_table('person',Field('name'))
>>> db.person.insert(name='John')
>>> db.person.insert(name='Max')
>>> db.person.insert(name='Alex')
>>> rows = db(db.person).select()
>>> for row in rows.find(lambda row: row.name[0]=='M'):
        print row.name
Max
>>> print len(rows)
3
>>> for row in rows.exclude(lambda row: row.name[0]=='M'):
        print row.name
Max
>>> print len(rows)
2
>>> for row in rows.sort(lambda row: row.name):
        print row.name
Alex
John
\end{lstlisting}

They can be combined:
\begin{lstlisting}
>>> rows = db(db.person).select()
>>> rows = rows.find(
        lambda row: 'x' in row.name).sort(
            lambda row: row.name)
>>> for row in rows:
        print row.name
Alex
Max
\end{lstlisting}

Sort takes an optional argument {\ft reverse=True} with the obvious meaning.

The {\ft find} method as an optional limitby argument with the same syntax and functionality as the Set select {\ft method}.

\goodbreak\section{Other methods}

\goodbreak\subsection{{\ft update\_or\_insert}}

\inxx{update\_or\_insert}

Some times you need to perform an insert only if there is no record with the same values as those being inserted.
This can be done with

\begin{lstlisting}
db.define_table('person',Field('name'),Field('birthplace'))
db.person.update_or_insert(name='John',birthplace='Chicago')
\end{lstlisting}

The record will be inserted only of there is no other user called John born in Chicago.

You can specify which values to use as a key to determine if the record exists. For example:
\begin{lstlisting}
db.person.update_or_insert(db.person.name=='John',
     name='John',birthplace='Chicago')
\end{lstlisting}
\noindent and if there is John his birthplace will be updated else a new record will be created.

\goodbreak\subsection{{\ft validate\_and\_insert}, {\ft validate\_and\_update}}

\inxx{validate\_and\_insert} \inxx{validate\_and\_update}

The function

\begin{lstlisting}
ret = db.mytable.validate_and_insert(field='value')
\end{lstlisting}
\noindent works very much like

\begin{lstlisting}
id = db.mytable.insert(field='value')
\end{lstlisting}
\noindent except that it calls the validators for the fields before performing the insert and bails out if the validation does not pass. If validation does not pass the errors can be found in {\ft ret.error}. If it passes, the id of the new record is in {\ft ret.id}. Mind that normally validation is done by the form processing logic so this function is rarely needed.

Similarly

\begin{lstlisting}
ret = db(query).validate_and_update(field='value')
\end{lstlisting}
\noindent works very much the same as

\begin{lstlisting}
num = db(query).update(field='value')
\end{lstlisting}
\noindent except that it calls the validators for        the fields before performing the update. Notice that it only works if query involves a single table. The number of updated records can be found in {\ft res.updated} and errors will be {\ft ret.errors}.

\goodbreak\subsection{{\ft smart\_query} (experimental)}

There are times when you need to parse a query using natural language such as

\begin{lstlisting}
name contain m and age greater than 18
\end{lstlisting}

The DAL provides a method to parse this type of queries:

\begin{lstlisting}
search = 'name contain m and age greater than 18'
rows = db.smart_query([db.person],search).select()
\end{lstlisting}

The first argument must be a list of tables or fields that should be allowed in the search. It raises a {\ft RuntimeError} if the search string is invalid. This functionality can be used to build RESTful interfaces (see chapter 10) and it is used internally by the {\ft SQLFORM.grid} and {\ft SQLFORM.smartgrid}.

In the smartquery search string, a field can be identified by fieldname only and or by tablename.fieldname. Strings may be delimited by double quotes if they contain spaces.

\goodbreak\section{Computed fields}

\inxx{compute}

DAL fields may have a {\ft compute} attribute. This must be a function (or lambda) that takes a Row object and returns a value for the field. When a new record is modified, including both insertions and updates, if a value for the field is not provided, web2py tries to compute from the other field values using the {\ft compute} function. Here is an example:
\begin{lstlisting}
>>> db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
        Field('total_price',
            compute=lambda r: r['unit_price']*r['quantity']))
>>> r = db.item.insert(unit_price=1.99, quantity=5)
>>> print r.total_price
9.95
\end{lstlisting}

Notice that the computed value is stored in the db and it is not computed on retrieval, as in the case of virtual fields, described later. Two typical applications of computed fields are:
\begin{itemize}
\item in wiki applications, to store the processed input wiki text as HTML, to avoid re-processing on every request

\item for searching, to compute normalized values for a field, to be used for searching.
\end{itemize}

\goodbreak\section{Virtual fields}

\inxx{virtual fields}

Virtual fields are also computed fields (as in the previous subsection) but they differ from those because they are {\it virtual} in the sense that they are not stored in the db and they are computed each time records are extracted from the database. They can be used to simplify the user's code without using additional storage but they cannot be used for searching.

\goodbreak\subsection{New style virtual fields}
\noindent web2py provides a new and easier way to define virtual fields and lazy virtual fields. This section is marked experimental because they APIs may still change a little from what is described here.

Here we will consider the same example as in the previous subsection. In particular we consider the following model:

\begin{lstlisting}
>>> db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
\end{lstlisting}

One can define a {\ft total\_price} virtual field as

\begin{lstlisting}
>>> db.item.total_price = Field.Virtual(
    lambda row: row.item.unit_price*row.item.quantity)
\end{lstlisting}
\noindent i.e. by simply defining a new field {\ft total\_price} to be a {\ft Field.Virtual}. The only argument of the constructor is a function that takes a row and returns the computed values.

A virtual field defined as the one above is automatically computed for all records when the records are selected:

\begin{lstlisting}
>>> for row in db(db.item).select(): print row.total_price
\end{lstlisting}

It is also possible to define method fields which are calculated on-demand, when called.
For example:

\begin{lstlisting}
>>> db.item.discounted_total = Field.Method(lambda row, discount=0.0: \
       row.item.unit_price*row.item.quantity*(1.0-discount/100))
\end{lstlisting}

In this case {\ft row.discounted\_total} is not a value but a function. The function takes the same arguments as the function passed to the {\ft Method} constructor except for {\ft row} which is implicit (think of it as {\ft self} for rows objects).

The lazy field in the example above allows one to compute the total price for each {\ft item}:

\begin{lstlisting}
>>> for row in db(db.item).select(): print row.discounted_total()
\end{lstlisting}

And it also allows to pass an optional {\ft discount} percentage (15\%):

\begin{lstlisting}
>>> for row in db(db.item).select(): print row.discounted_total(15)
\end{lstlisting}

Virtual and Method fields can also be defined in place when a table is defined:

\begin{lstlisting}
>>> db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
        Field.Virtual('total_price', lambda row: ...),
        Field.Method('discounted_total', lambda row, discount=0.0: ...))
\end{lstlisting}

\begin{quote}Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of {\ft db.table.fields} and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).\end{quote}
\goodbreak\subsection{Old style virtual fields}

In order to define one or more virtual fields, you can also define a container class, instantiate it and link it to a table or to a select. For example, consider the following table:

\begin{lstlisting}
>>> db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
\end{lstlisting}

One can define a {\ft total\_price} virtual field as
\begin{lstlisting}
>>> class MyVirtualFields(object):
        def total_price(self):
            return self.item.unit_price*self.item.quantity
>>> db.item.virtualfields.append(MyVirtualFields())
\end{lstlisting}

Notice that each method of the class that takes a single argument (self) is a new virtual field. {\ft self} refers to each one row of the select. Field values are referred by full path as in {\ft self.item.unit\_price}. The table is linked to the virtual fields by appending an instance of the class to the table's {\ft virtualfields} attribute.

Virtual fields can also access recursive fields as in
\begin{lstlisting}
>>> db.define_table('item',
        Field('unit_price','double'))
>>> db.define_table('order_item',
        Field('item','reference item'),
        Field('quantity','integer'))
>>> class MyVirtualFields(object):
        def total_price(self):
            return self.order_item.item.unit_price \
                * self.order_item.quantity
>>> db.order_item.virtualfields.append(MyVirtualFields())
\end{lstlisting}

Notice the recursive field access {\ft self.order\_item.item.unit\_price} where {\ft self} is the looping record.

They can also act on the result of a JOIN
\begin{lstlisting}
>>> db.define_table('item',
        Field('unit_price','double'))
>>> db.define_table('order_item',
        Field('item','reference item'),
        Field('quantity','integer'))
>>> rows = db(db.order_item.item==db.item.id).select()
>>> class MyVirtualFields(object):
        def total_price(self):
            return self.item.unit_price \
                * self.order_item.quantity
>>> rows.setvirtualfields(order_item=MyVirtualFields())
>>> for row in rows: print row.order_item.total_price
\end{lstlisting}

Notice how in this case the syntax is different. The virtual field accesses both {\ft self.item.unit\_price} and {\ft self.order\_item.quantity} which belong to the join select. The virtual field is attached to the rows of the table using the {\ft setvirtualfields} method of the rows object. This method takes an arbitrary number of named arguments and can be used to set multiple virtual fields, defined in multiple classes, and attach them to multiple tables:
\begin{lstlisting}
>>> class MyVirtualFields1(object):
        def discounted_unit_price(self):
            return self.item.unit_price*0.90
>>> class MyVirtualFields2(object):
        def total_price(self):
            return self.item.unit_price \
                * self.order_item.quantity
        def discounted_total_price(self):
            return self.item.discounted_unit_price \
                * self.order_item.quantity
>>> rows.setvirtualfields(
        item=MyVirtualFields1(),
        order_item=MyVirtualFields2())
>>> for row in rows:
        print row.order_item.discounted_total_price
\end{lstlisting}

Virtual fields can be {\it lazy}; all they need to do is return a function and access it by calling the function:
\begin{lstlisting}
>>> db.define_table('item',
        Field('unit_price','double'),
        Field('quantity','integer'),
>>> class MyVirtualFields(object):
        def lazy_total_price(self):
            def lazy(self=self):
                return self.item.unit_price \
                    * self.item.quantity
            return lazy
>>> db.item.virtualfields.append(MyVirtualFields())
>>> for item in db(db.item).select():
        print item.lazy_total_price()
\end{lstlisting}
\noindent or shorter using a lambda function:
\begin{lstlisting}
>>> class MyVirtualFields(object):
        def lazy_total_price(self):
            return lambda self=self: self.item.unit_price \
                * self.item.quantity
\end{lstlisting}

\goodbreak\section{One to many relation}

\inxx{one to many}

To illustrate how to implement one to many relations with the web2py DAL, define another table "thing" that refers to the table "person" which we redefine here:
\begin{lstlisting}
>>> db.define_table('person',
                    Field('name'),
                    format='%(name)s')
>>> db.define_table('thing',
                    Field('name'),
                    Field('owner', 'reference person'),
                    format='%(name)s')
\end{lstlisting}

Table "thing" has two fields, the name of the thing and the owner of the thing. The "owner" field id a reference field. A reference type can be specified in two equivalent ways:

\begin{lstlisting}
Field('owner', 'reference person')
Field('owner', db.person)
\end{lstlisting}

The latter is always converted to the former. They are equivalent except in the case of lazy tables, self references or other types of cyclic references where the former notation is the only allowed notation.

When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:
\begin{lstlisting}
>>> print db.thing.owner.type
reference person
\end{lstlisting}

Now, insert three things, two owned by Alex and one by Bob:
\begin{lstlisting}
>>> db.thing.insert(name='Boat', owner=1)
1
>>> db.thing.insert(name='Chair', owner=1)
2
>>> db.thing.insert(name='Shoes', owner=2)
3
\end{lstlisting}

You can select as you did for any other table:
\begin{lstlisting}
>>> for row in db(db.thing.owner==1).select():
        print row.name
Boat
Chair
\end{lstlisting}

Because a thing has a reference to a person, a person can have many things, so a record of table person now acquires a new attribute thing, which is a Set, that defines the things of that person. This allows looping over all persons and fetching their things easily:

\inxx{referencing}
\begin{lstlisting}
>>> for person in db().select(db.person.ALL):
        print person.name
        for thing in person.thing.select():
            print '    ', thing.name
Alex
     Boat
     Chair
Bob
     Shoes
Carl
\end{lstlisting}

\goodbreak\subsection{Inner joins}

Another way to achieve a similar result is by using a join, specifically an INNER JOIN. web2py performs joins automatically and transparently when the query links two or more tables as in the following example:

\inxx{Rows} \inxx{inner join} \inxx{join}
\begin{lstlisting}
>>> rows = db(db.person.id==db.thing.owner).select()
>>> for row in rows:
        print row.person.name, 'has', row.thing.name
Alex has Boat
Alex has Chair
Bob has Shoes
\end{lstlisting}

Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:
\begin{lstlisting}
row.name
\end{lstlisting}
\noindent and it was obvious whether this was the name of a person or a thing, in the result of a join you have to be more explicit and say:
\begin{lstlisting}
row.person.name
\end{lstlisting}
\noindent or:
\begin{lstlisting}
row.thing.name
\end{lstlisting}

There is an alternative syntax for INNER JOINS:
\begin{lstlisting}
>>> rows = db(db.person).select(join=db.thing.on(db.person.id==db.thing.owner))
>>> for row in rows:
    print row.person.name, 'has', row.thing.name
Alex has Boat
Alex has Chair
Bob has Shoes
\end{lstlisting}

While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:

\begin{lstlisting}
>>> db.define_table('thing',
        Field('name'),
        Field('owner1','reference person'),
        Field('owner2','reference person'))
>>> rows = db(db.person).select(
    join=[db.person.with_alias('owner1').on(db.person.id==db.thing.owner1).
          db.person.with_alias('owner2').on(db.person.id==db.thing.owner2)])
\end{lstlisting}

The value of {\ft join} can be list of {\ft db.table.on(...)} to join.

\goodbreak\subsection{Left outer join}

Notice that Carl did not appear in the list above because he has no things. If you intend to select on persons (whether they have things or not) and their things (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument "left" of the select command. Here is an example:

\inxx{Rows} \inxx{left outer join} \inxx{outer join}
\begin{lstlisting}
>>> rows=db().select(
        db.person.ALL, db.thing.ALL,
        left=db.thing.on(db.person.id==db.thing.owner))
>>> for row in rows:
        print row.person.name, 'has', row.thing.name
Alex has Boat
Alex has Chair
Bob has Shoes
Carl has None
\end{lstlisting}
\noindent where:
\begin{lstlisting}
left = db.thing.on(...)
\end{lstlisting}
\noindent does the left join query. Here the argument of {\ft db.thing.on} is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.

Multiple left joins can be combined by passing a list or tuple of {\ft db.mytable.on(...)} to the  {\ft left} attribute.

\goodbreak\subsection{Grouping and counting}

When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of things owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the thing table by owner. Third, you want to select all rows (person + thing), group them by person, and count them while grouping:

\inxx{grouping}
\begin{lstlisting}
>>> count = db.person.id.count()
>>> for row in db(db.person.id==db.thing.owner).select(
        db.person.name, count, groupby=db.person.name):
        print row.person.name, row[count]
Alex 2
Bob 1
\end{lstlisting}

Notice the count operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself. The count method of the Field object has an optional {\ft distinct} argument. When set to {\ft True} it specifies that only distinct values of the field in question are to be counted.

\goodbreak\section{Many to many}

\inxx{many-to-many}
In the previous examples, we allowed a thing to have one owner but one person could have many things. What if Boat was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a thing via an ownership relation.

Here is how to do it:
\begin{lstlisting}
>>> db.define_table('person',
                    Field('name'))
>>> db.define_table('thing',
                    Field('name'))
>>> db.define_table('ownership',
                    Field('person', 'reference person'),
                    Field('thing', 'reference thing'))
\end{lstlisting}
\noindent the existing ownership relationship can now be rewritten as:
\begin{lstlisting}
>>> db.ownership.insert(person=1, thing=1) # Alex owns Boat
>>> db.ownership.insert(person=1, thing=2) # Alex owns Chair
>>> db.ownership.insert(person=2, thing=3) # Bob owns Shoes

\end{lstlisting}

Now you can add the new relation that Curt co-owns Boat:
\begin{lstlisting}
>>> db.ownership.insert(person=3, thing=1) # Curt owns Boat too

\end{lstlisting}

Because you now have a three-way relation between tables, it may be convenient to define a new set on which to perform operations:
\begin{lstlisting}
>>> persons_and_things = db(
        (db.person.id==db.ownership.person) \
        & (db.thing.id==db.ownership.thing))
\end{lstlisting}

Now it is easy to select all persons and their things from the new Set:
\begin{lstlisting}
>>> for row in persons_and_things.select():
        print row.person.name, row.thing.name
Alex Boat
Alex Chair
Bob Shoes
Curt Boat
\end{lstlisting}

Similarly, you can search for all things owned by Alex:
\begin{lstlisting}
>>> for row in persons_and_things(db.person.name=='Alex').select():
        print row.thing.name
Boat
Chair
\end{lstlisting}
\noindent and all owners of Boat:
\begin{lstlisting}
>>> for row in persons_and_things(db.thing.name=='Boat').select():
        print row.person.name
Alex
Curt
\end{lstlisting}

A lighter alternative to Many 2 Many relations is tagging. Tagging is discussed in the context of the {\ft IS\_IN\_DB} validator. Tagging works even on database backends that do not support JOINs like the Google App Engine NoSQL.

\goodbreak\section{{\ft list:<type>}, and {\ft contains}}

\inxx{list:string}
\inxx{list:integer}
\inxx{list:reference}
\inxx{contains}
\inxx{multiple}
\inxx{tags}
\noindent web2py provides the following special field types:

\begin{lstlisting}
list:string
list:integer
list:reference <table>
\end{lstlisting}

They can contain lists of strings, of integers and of references respectively.

On Google App Engine NoSQL {\ft list:string} is mapped into {\ft StringListProperty}, the other two are mapped into {\ft ListProperty(int)}. On relational databases they all mapped into text fields which contain the list of items separated by {\ft |}. For example {\ft [1,2,3]} is mapped into {\ft |1|2|3|}.

For lists of string the items are escaped so that any {\ft |} in the item is replaced by a {\ft ||}. Anyway this is an internal representation and it is transparent to the user.

You can use {\ft list:string}, for example, in the following way:

\begin{lstlisting}
>>> db.define_table('product',
        Field('name'),
        Field('colors','list:string'))
>>> db.product.colors.requires=IS_IN_SET(('red','blue','green'))
>>> db.product.insert(name='Toy Car',colors=['red','green'])
>>> products = db(db.product.colors.contains('red')).select()
>>> for item in products:
        print item.name, item.colors
Toy Car ['red', 'green']
\end{lstlisting}

{\ft list:integer} works in the same way but the items must be integers.

As usual the requirements are enforced at the level of forms, not at the level of {\ft insert}.

\begin{quote}For {\ft list:<type>} fields the {\ft contains(value)} operator maps into a non trivial query that checks for lists containing the {\ft value}.  The {\ft contains} operator also works for regular {\ft string} and {\ft text} fields and it maps into a {\ft LIKE '\%value\%'}.\end{quote}
The {\ft list:reference} and the {\ft contains(value)} operator are particularly useful to de-normalize many-to-many relations. Here is an example:

\begin{lstlisting}
>>> db.define_table('tag',Field('name'),format='%(name)s')
>>> db.define_table('product',
        Field('name'),
        Field('tags','list:reference tag'))
>>> a = db.tag.insert(name='red')
>>> b = db.tag.insert(name='green')
>>> c = db.tag.insert(name='blue')
>>> db.product.insert(name='Toy Car',tags=[a, b, c])
>>> products = db(db.product.tags.contains(b)).select()
>>> for item in products:
        print item.name, item.tags
Toy Car [1, 2, 3]
>>> for item in products:
        print item.name, db.product.tags.represent(item.tags)
Toy Car red, green, blue
\end{lstlisting}

Notice that a {\ft list:reference tag} field get a default constraint

\begin{lstlisting}
requires = IS_IN_DB(db,'tag.id',db.tag._format,multiple=True)
\end{lstlisting}
\noindent that produces a {\ft SELECT/OPTION} multiple drop-box in forms.

Also notice that this field gets a default {\ft represent} attribute which represents the list of references as a comma-separated list of formatted references. This is used in read forms and {\ft SQLTABLE}s.

\begin{quote}While {\ft list:reference} has a default validator and a default representation, {\ft list:integer} and {\ft list:string} do not. So these two need an {\ft IS\_IN\_SET} or an {\ft IS\_IN\_DB} validator if you want to use them in forms.\end{quote}
\goodbreak\section{Other operators}
\noindent web2py has other operators that provide an API to access equivalent SQL operators.
Let's define another table "log" to store security events, their event\_time and severity, where the severity is an integer number.

\inxx{date} \inxx{datetime} \inxx{time}
\begin{lstlisting}
>>> db.define_table('log', Field('event'),
                           Field('event_time', 'datetime'),
                           Field('severity', 'integer'))
\end{lstlisting}

As before, insert a few events, a "port scan", an "xss injection" and an "unauthorized login".
For the sake of the example, you can log events with the same event\_time but with different severities (1, 2, and 3 respectively).
\begin{lstlisting}
>>> import datetime
>>> now = datetime.datetime.now()
>>> print db.log.insert(
        event='port scan', event_time=now, severity=1)
1
>>> print db.log.insert(
        event='xss injection', event_time=now, severity=2)
2
>>> print db.log.insert(
        event='unauthorized login', event_time=now, severity=3)
3
\end{lstlisting}

\goodbreak\subsection{{\ft like}, {\ft regexp}, {\ft startswith}, {\ft contains}, {\ft upper}, {\ft lower}}

\inxx{like} \inxx{startswith} \inxx{regexp}
\inxx{contains} \inxx{upper} \inxx{lower}

Fields have a like operator that you can use to match strings:

\begin{lstlisting}
>>> for row in db(db.log.event.like('port%')).select():
        print row.event
port scan
\end{lstlisting}

Here "port\%" indicates a string starting with "port". The percent sign character, "\%", is a wild-card character that means "any sequence of characters".

The like operator is case-insensitive but it can be made case-sensitive with

\begin{lstlisting}
db.mytable.myfield.like('value',case_sensitive=True)
\end{lstlisting}
\noindent web2py also provides some shortcuts:

\begin{lstlisting}
db.mytable.myfield.startswith('value')
db.mytable.myfield.contains('value')
\end{lstlisting}
\noindent which are equivalent respectively to

\begin{lstlisting}
db.mytable.myfield.like('value%')
db.mytable.myfield.like('%value%')
\end{lstlisting}

Notice that {\ft contains} has a special meaning for {\ft list:<type>} fields and it was discussed in a previous section.

The {\ft contains} method can also be passed a list of values and an optional boolean argument {\ft all} to search for records that contain all values:

\begin{lstlisting}
db.mytable.myfield.contains(['value1','value2'], all=True)
\end{lstlisting}
or any value from the list
\begin{lstlisting}
db.mytable.myfield.contains(['value1','value2'], all=false)
\end{lstlisting}

There is a also a {\ft regexp} method that works like the {\ft like} method but allows regular expression syntax for the look-up expression. It is only supported by PostgreSQL and SQLite.

The {\ft upper} and {\ft lower} methods allow you to convert the value of the field to upper or lower case, and you can also combine them with the like operator:

\inxx{upper} \inxx{lower}
\begin{lstlisting}
>>> for row in db(db.log.event.upper().like('PORT%')).select():
        print row.event
port scan
\end{lstlisting}

\goodbreak\subsection{{\ft year}, {\ft month}, {\ft day}, {\ft hour}, {\ft minutes}, {\ft seconds}}

\inxx{hour} \inxx{minutes} \inxx{seconds} \inxx{day} \inxx{month} \inxx{year}

The date and datetime fields have day, month and year methods. The datetime and time fields have hour, minutes and seconds methods. Here is an example:

\begin{lstlisting}
>>> for row in db(db.log.event_time.year()==2009).select():
        print row.event
port scan
xss injection
unauthorized login
\end{lstlisting}

\goodbreak\subsection{{\ft belongs}}

The SQL IN operator is realized via the belongs method which returns true when the field value belongs to the specified set (list of tuples):

\inxx{belongs}
\begin{lstlisting}
>>> for row in db(db.log.severity.belongs((1, 2))).select():
        print row.event
port scan
xss injection
\end{lstlisting}

The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a {\ft \_select}, not a {\ft select}, and only one field has to be selected explicitly, the one that defines the set.

\inxx{nested select}
\begin{lstlisting}
>>> bad_days = db(db.log.severity==3)._select(db.log.event_time)
>>> for row in db(db.log.event_time.belongs(bad_days)).select():
        print row.event
port scan
xss injection
unauthorized login
\end{lstlisting}

In those cases where a nested select is required and the look-up field is a reference we can also use a query as argument. For example:

\begin{lstlisting}
db.define_table('person',Field('name'))
db.define_table('thing',Field('owner'),Field('owner','reference thing'))
db(db.thing.owner.belongs(db.person.name=='Jonathan')).select()
\end{lstlisting}

In this case it is obvious that the next select only needs the field referenced by the {\ft db.thing.owner} field so we do not need the more verbose {\ft \_select} notation.

\inxx{nested\_select}

A nested select can also be used as insert/update value but in this case the syntax is different:

\begin{lstlisting}
lazy = db(db.person.name=='Jonathan').nested_select(db.person.id)
db(db.thing.id==1).update(owner = lazy)
\end{lstlisting}

In this case {\ft lazy} is a nested expression that computes the {\ft id} of person "Jonathan". The two lines result in one single SQL query.

\goodbreak\subsection{{\ft sum}, {\ft avg}, {\ft min}, {\ft max} and {\ft len}}

\inxx{sum} \inxx{avg} \inxx{min} \inxx{max}
Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:
\begin{lstlisting}
>>> sum = db.log.severity.sum()
>>> print db().select(sum).first()[sum]
6
\end{lstlisting}

You can also use {\ft avg}, {\ft min}, and {\ft max} to the average, minimum, and maximum value respectively for the selected records. For example:

\begin{lstlisting}
>>> max = db.log.severity.max()
>>> print db().select(max).first()[max]
3
\end{lstlisting}

{\ft .len()} computes the length of a string, text or boolean fields.

Expressions can be combined to form more complex expressions. For example here we are computing the sum of the length of all the severity strings in the logs, increased of one:

\begin{lstlisting}
>>> sum = (db.log.severity.len()+1).sum()
>>> print db().select(sum).first()[sum]
\end{lstlisting}

\goodbreak\subsection{Substrings}

One can build an expression to refer to a substring. For example, we can group things whose name starts with the same three characters and select only one from each group:

\begin{lstlisting}
db(db.thing).select(distinct = db.thing.name[:3])
\end{lstlisting}

\goodbreak\subsection{Default values with {\ft coalesce} and {\ft coalesce\_zero}}

There are times when you need to pull a value from database but also need a default values if the value for a record is set to NULL. In SQL there is a keyword, {\ft COALESCE}, for this. web2py has an equivalent {\ft coalesce} method:

\begin{lstlisting}
>>> db.define_table('sysuser',Field('username'),Field('fullname'))
>>> db.sysuser.insert(username='max',fullname='Max Power')
>>> db.sysuser.insert(username='tim',fullname=None)
print db(db.sysuser).select(db.sysuser.fullname.coalesce(db.sysuser.username))
"COALESCE(sysuser.fullname,sysuser.username)"
Max Power
tim
\end{lstlisting}

Other times you need to compute a mathematical expression but some fields have a value set to None while it should be zero.
{\ft coalesce\_zero} comes to the rescue by defaulting None to zero in the query:

\begin{lstlisting}
>>> db.define_table('sysuser',Field('username'),Field('points'))
>>> db.sysuser.insert(username='max',points=10)
>>> db.sysuser.insert(username='tim',points=None)
>>> print db(db.sysuser).select(db.sysuser.points.coalesce_zero().sum())
"SUM(COALESCE(sysuser.points,0))"
10
\end{lstlisting}

\goodbreak\section{Generating raw sql}

\inxx{raw SQL}

Sometimes you need to generate the SQL but not execute it. This is easy to do with web2py since every command that performs database IO has an equivalent command that does not, and simply returns the SQL that would have been executed. These commands have the same names and syntax as the functional ones, but they start with an underscore:

Here is {\ft \_insert} \inxx{\_insert}
\begin{lstlisting}
>>> print db.person._insert(name='Alex')
INSERT INTO person(name) VALUES ('Alex');
\end{lstlisting}

Here is {\ft \_count} \inxx{\_count}
\begin{lstlisting}
>>> print db(db.person.name=='Alex')._count()
SELECT count(*) FROM person WHERE person.name='Alex';
\end{lstlisting}

Here is {\ft \_select} \inxx{\_select}
\begin{lstlisting}
>>> print db(db.person.name=='Alex')._select()
SELECT person.id, person.name FROM person WHERE person.name='Alex';
\end{lstlisting}

Here is {\ft \_delete} \inxx{\_delete}
\begin{lstlisting}
>>> print db(db.person.name=='Alex')._delete()
DELETE FROM person WHERE person.name='Alex';
\end{lstlisting}

And finally, here is {\ft \_update} \inxx{\_update}
\begin{lstlisting}
>>> print db(db.person.name=='Alex')._update()
UPDATE person SET  WHERE person.name='Alex';
\end{lstlisting}

\begin{quote}Moreover you can always use {\ft db.\_lastsql} to return the most recent
SQL code, whether it was executed manually using executesql or was SQL
generated by the DAL.\end{quote}
\goodbreak\section{Exporting and importing data}

\inxx{export} \inxx{import}

\goodbreak\subsection{CSV (one Table at a time)}

When a DALRows object is converted to a string it is automatically
serialized in CSV:

\inxx{csv}
\begin{lstlisting}
>>> rows = db(db.person.id==db.thing.owner).select()
>>> print rows
person.id,person.name,thing.id,thing.name,thing.owner
1,Alex,1,Boat,1
1,Alex,2,Chair,1
2,Bob,3,Shoes,2
\end{lstlisting}

You can serialize a single table in CSV and store it in a file "test.csv":
\begin{lstlisting}
>>> open('test.csv', 'w').write(str(db(db.person.id).select()))
\end{lstlisting}

This is equivalent to

\begin{lstlisting}
>>> rows = db(db.person.id).select()
>>> rows.export_to_csv_file(open('test.csv', 'w'))
\end{lstlisting}

You can read the CSV file back with:
\begin{lstlisting}
>>> db.person.import_from_csv_file(open('test.csv', 'r'))
\end{lstlisting}

When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: "person.id" and "person.name". It ignores the "person." prefix, and it ignores the "id" fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.

\goodbreak\subsection{CSV (all tables at once)}

In web2py, you can backup/restore an entire database with two commands:

To export:
\begin{lstlisting}
>>> db.export_to_csv_file(open('somefile.csv', 'wb'))
\end{lstlisting}

To import:
\begin{lstlisting}
>>> db.import_from_csv_file(open('somefile.csv', 'rb'))
\end{lstlisting}

This mechanism can be used even if the importing database is of a different type than the exporting database. The data is stored in "somefile.csv" as a CSV file where each table starts with one line that indicates the tablename, and another line with the fieldnames:
\begin{lstlisting}
TABLE tablename
field1, field2, field3, ...
\end{lstlisting}

Two tables are separated {\ft {\textbackslash}r{\textbackslash}n{\textbackslash}r{\textbackslash}n}. The file ends with the line
\begin{lstlisting}
END
\end{lstlisting}

The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the "uploads" folder separately.

When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.

If a table contains a field called
"uuid", this field will be used to identify duplicates.  Also, if an
imported record has the same "uuid" as an existing record, the
previous record will be updated.

\goodbreak\subsection{CSV and remote database synchronization}

Consider the following model:
\begin{lstlisting}
db = DAL('sqlite:memory:')
db.define_table('person',
    Field('name'),
    format='%(name)s')
db.define_table('thing',
    Field('owner', 'reference person'),
    Field('name'),
    format='%(name)s')

if not db(db.person).count():
    id = db.person.insert(name="Massimo")
    db.thing.insert(owner=id, name="Chair")
\end{lstlisting}

Each record is identified by an ID and referenced by that ID. If you
have two copies of the database used by distinct web2py installations,
the ID is unique only within each database and not across the databases.
This is a problem when merging records from different databases.

In order to make a record uniquely identifiable across databases, they
must:
\begin{itemize}
\item have a unique id (UUID),

\item have an event\_time (to figure out which one is more recent if multiple copies),

\item reference the UUID instead of the id.
\end{itemize}

This can be achieved without modifying web2py. Here is what to do:

{\bf 1.} Change the above model into:

\begin{lstlisting}
db.define_table('person',
    Field('uuid', length=64, default=lambda:str(uuid.uuid4())),
    Field('modified_on', 'datetime', default=now),
    Field('name'),
    format='%(name)s')

db.define_table('thing',
    Field('uuid', length=64, default=lambda:str(uuid.uuid4())),
    Field('modified_on', 'datetime', default=now),
    Field('owner', length=64),
    Field('name'),
    format='%(name)s')

db.thing.owner.requires = IS_IN_DB(db,'person.uuid','%(name)s')

if not db(db.person.id).count():
    id = uuid.uuid4()
    db.person.insert(name="Massimo", uuid=id)
    db.thing.insert(owner=id, name="Chair")
\end{lstlisting}

\begin{quote}Note, in the above table definitions, the default value for the two 'uuid' fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.\end{quote}
{\bf 2.} Create a controller action to export the database:

\begin{lstlisting}
def export():
    s = StringIO.StringIO()
    db.export_to_csv_file(s)
    response.headers['Content-Type'] = 'text/csv'
    return s.getvalue()
\end{lstlisting}

{\bf 3.} Create a controller action to import a saved copy of the other database and sync records:

\begin{lstlisting}
def import_and_sync():
    form = FORM(INPUT(_type='file', _name='data'), INPUT(_type='submit'))
    if form.process(session=None).accepted:
        db.import_from_csv_file(form.vars.data.file,unique=False)
        # for every table
        for table in db.tables:
            # for every uuid, delete all but the latest
            items = db(db[table]).select(db[table].id,
                       db[table].uuid,
                       orderby=db[table].modified_on,
                       groupby=db[table].uuid)
            for item in items:
                db((db[table].uuid==item.uuid)&\
                   (db[table].id!=item.id)).delete()
    return dict(form=form)
\end{lstlisting}

Notice that {\ft session=None} disables the CSRF protection since this URL is intended to be accessed from outside.

{\bf 4.} Create an index manually to make the search by uuid faster.

Notice that steps 2 and 3 work for every database model; they are not
specific for this example.

\inxx{XML-RPC}
Alternatively, you can use XML-RPC to export/import the file.

If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.

\goodbreak\subsection{HTML and XML (one Table at a time)}

\inxx{DALRows objects}
DALRows objects also have an {\ft xml} method (like helpers) that serializes it to XML/HTML:

\inxx{HTML}

\begin{lstlisting}
>>> rows = db(db.person.id > 0).select()
>>> print rows.xml()
<table>
  <thead>
    <tr>
      <th>person.id</th>
      <th>person.name</th>
      <th>thing.id</th>
      <th>thing.name</th>
      <th>thing.owner</th>
    </tr>
  </thead>
  <tbody>
    <tr class="even">
      <td>1</td>
      <td>Alex</td>
      <td>1</td>
      <td>Boat</td>
      <td>1</td>
    </tr>
    ...
  </tbody>
</table>
\end{lstlisting}

\inxx{DALRows custom tags}
If you need to serialize the DALRows in any other XML format with custom tags, you can easily do that using the universal TAG helper and the * notation:
\inxx{XML}

\begin{lstlisting}
>>> rows = db(db.person.id > 0).select()
>>> print TAG.result(*[TAG.row(*[TAG.field(r[f], _name=f) \
          for f in db.person.fields]) for r in rows])
<result>
  <row>
    <field name="id">1</field>
    <field name="name">Alex</field>
  </row>
  ...
</result>
\end{lstlisting}

\goodbreak\subsection{Data representation}

\inxx{export\_to\_csv\_file}
The {\ft export\_to\_csv\_file} function accepts a keyword argument named {\ft represent}. When {\ft True} it will use the columns {\ft represent} function while exporting the data instead of the raw data.

\inxx{colnames}
The function also accepts a keyword argument named {\ft colnames} that should contain a list of column names one wish to export. It defaults to all columns.

Both {\ft export\_to\_csv\_file} and {\ft import\_from\_csv\_file} accept keyword arguments that tell the csv parser the format to save/load the files:
\begin{itemize}
\item {\ft delimiter}: delimiter to separate values (default ',')

\item {\ft quotechar}: character to use to quote string values (default to double quotes)

\item {\ft quoting}: quote system (default {\ft csv.QUOTE\_MINIMAL})
\end{itemize}

Here is some example usage:
\begin{lstlisting}
>>> import csv
>>> rows = db(query).select()
>>> rows.export_to_csv_file(open('/tmp/test.txt', 'w'),
        delimiter='|',
        quotechar='"',
        quoting=csv.QUOTE_NONNUMERIC)
\end{lstlisting}

Which would render something similar to
\begin{lstlisting}
"hello"|35|"this is the text description"|"2009-03-03"
\end{lstlisting}

For more information consult the official Python documentation~\cite{quoteall}

\goodbreak\section{Caching selects}

The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.

In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.

\inxx{cache select}
\begin{lstlisting}
def cache_db_select():
    logs = db().select(db.log.ALL, cache=(cache.ram, 60))
    return dict(logs=logs)
\end{lstlisting}

\inxx{cacheable}

The {\ft select} method has an optional {\ft cacheable} argument, normally set to {\ft False}. When {\ft cacheable=True} the resulting {\ft Rows} is serializable but The {\ft Row}s lack {\ft update\_record} and {\ft delete\_record} methods.

If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:

\begin{lstlisting}
rows = db(query).select(cacheable=True)
\end{lstlisting}

\begin{quote}The results of a {\ft select} are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the {\ft cache} attribute is set or {\ft cacheable=True}.\end{quote}
When the {\ft cache} argument is set but {\ft cacheable=False} (default) only the database results are cached, not the actual Rows object. When the {\ft cache} argument is used in conjunction with {\ft cacheable=True} the entire Rows object is cached and this results in much faster caching:

\begin{lstlisting}
rows = db(query).select(cache=(cache.ram,3600),cacheable=True)
\end{lstlisting}

\goodbreak\section{Self-Reference and aliases}

\inxx{self reference}
\inxx{alias}
It is possible to define tables with fields that refer to themselves, here is an example:
\inxx{reference table}
\begin{lstlisting}
db.define_table('person',
    Field('name'),
    Field('father_id', 'reference person'),
    Field('mother_id', 'reference person'))
\end{lstlisting}

Notice that the alternative notation of using a table object as field type will fail in this case, because it uses a variable {\ft db.person} before it is defined:
\begin{lstlisting}
db.define_table('person',
    Field('name'),
    Field('father_id', db.person), # wrong!
    Field('mother_id', db.person)) # wrong!
\end{lstlisting}

In general {\ft db.tablename} and {\ft "reference tablename"} are equivalent field types, but the latter is the only one allowed for self.references.

\inxx{with\_alias}
If the table refers to itself, then it is not possible to perform a JOIN to select a person and its parents without use of the SQL "AS" keyword. This is achieved in web2py using the {\ft with\_alias}. Here is an example:
\begin{lstlisting}
>>> Father = db.person.with_alias('father')
>>> Mother = db.person.with_alias('mother')
>>> db.person.insert(name='Massimo')
1
>>> db.person.insert(name='Claudia')
2
>>> db.person.insert(name='Marco', father_id=1, mother_id=2)
3
>>> rows = db().select(db.person.name, Father.name, Mother.name,
      left=(Father.on(Father.id==db.person.father_id),
            Mother.on(Mother.id==db.person.mother_id)))
>>> for row in rows:
        print row.person.name, row.father.name, row.mother.name
Massimo None None
Claudia None None
Marco Massimo Claudia
\end{lstlisting}

Notice that we have chosen to make a distinction between:
\begin{itemize}
\item "father\_id": the field name used in the table "person";

\item "father": the alias we want to use for the table referenced by the above field; this is communicated to the database;

\item "Father": the variable used by web2py to refer to that alias.
\end{itemize}

The difference is subtle, and there is nothing wrong in using the same name for the three of them:
\begin{lstlisting}
db.define_table('person',
    Field('name'),
    Field('father', 'reference person'),
    Field('mother', 'reference person'))
>>> father = db.person.with_alias('father')
>>> mother = db.person.with_alias('mother')
>>> db.person.insert(name='Massimo')
1
>>> db.person.insert(name='Claudia')
2
>>> db.person.insert(name='Marco', father=1, mother=2)
3
>>> rows = db().select(db.person.name, father.name, mother.name,
      left=(father.on(father.id==db.person.father),
            mother.on(mother.id==db.person.mother)))
>>> for row in rows:
        print row.person.name, row.father.name, row.mother.name
Massimo None None
Claudia None None
Marco Massimo Claudia
\end{lstlisting}

But it is important to have the distinction clear in order to build correct queries.

\goodbreak\section{Advanced features}

\goodbreak\subsection{Table inheritance}

\inxx{inheritance}

It is possible to create a table that contains all the fields from another table. It is sufficient to pass the other table in place of a field to {\ft define\_table}. For example
\begin{lstlisting}
db.define_table('person', Field('name'))
db.define_table('doctor', db.person, Field('specialization'))
\end{lstlisting}

\inxx{dummy table}
It is also possible to define a dummy table that is not stored in a database in order to reuse it in multiple other places. For example:

\begin{lstlisting}
signature = db.Table(db, 'signature',
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', db.auth_user, default=auth.user_id),
    Field('updated_on', 'datetime', update=request.now),
    Field('updated_by', db.auth_user, update=auth.user_id))

db.define_table('payment', Field('amount', 'double'), signature)
\end{lstlisting}

This example assumes that standard web2py authentication is enabled.

Notice that if you use {\ft Auth} web2py already creates one such table for you:

\begin{lstlisting}
auth = Auth(db)
db.define_table('payment', Field('amount', 'double'), auth.signature)
\end{lstlisting}

When using table inheritance, if you want the inheriting table to inherit validators, be sure to define the validators of the parent table before defining the inheriting table.

\goodbreak\subsection{{\ft filter\_in} and {\ft filter\_out}}

\inxx{filter\_in} \inxx{filter\_out}

It is possible to define a filter for each field to be called before a value is inserted into the database for that field and after a value is retrieved from the database.

Imagine for example that you want to store a serializable Python data structure in a field in the json format. Here is how it could be accomplished:

\begin{lstlisting}
>>> from simplejson import loads, dumps
>>> db.define_table('anyobj',Field('name'),Field('data','text'))
>>> db.anyobj.data.filter_in = lambda obj, dumps=dumps: dumps(obj)
>>> db.anyobj.data.filter_out = lambda txt, loads=loads: loads(txt)
>>> myobj = ['hello', 'world', 1, {2: 3}]
>>> id = db.anyobj.insert(name='myobjname', data=myobj)
>>> row = db.anyobj(id)
>>> row.data
['hello', 'world', 1, {2: 3}]
\end{lstlisting}

Another way to accomplish the same is by using a Field of type {\ft SQLCustomType}, as discussed later.

\goodbreak\subsection{before and after callbacks}

\inxx{\_before\_insert}
\inxx{\_after\_insert}
\inxx{\_before\_update}
\inxx{\_after\_update}
\inxx{\_before\_delete}
\inxx{\_after\_delete}

Web2py provides a mechanism to register callbacks to be called before and/or after insert, update and delete of records.

Each table stores six lists of callbacks:

\begin{lstlisting}
db.mytable._before_insert
db.mytable._after_insert
db.mytable._before_update
db.mytable._after_update
db.mytable._before_delete
db.mytable._after_delete
\end{lstlisting}

You can register callback function by appending it the corresponding function to one of those lists. The caveat is that depending on the functionality, the callback has different signature.

This is best explained via some examples.

\begin{lstlisting}
>>> db.define_table('person',Field('name'))
>>> def pprint(*args): print args
>>> db.person._before_insert.append(lambda f: pprint(f))
>>> db.person._after_insert.append(lambda f,id: pprint(f,id))
>>> db.person._before_update.append(lambda s,f: pprint(s,f))
>>> db.person._after_update.append(lambda s,f: pprint(s,f))
>>> db.person._before_delete.append(lambda s: pprint(s))
>>> db.person._after_delete.append(lambda s: pprint(s))
\end{lstlisting}

Here {\ft f} is a dict of fields passed to insert or update, {\ft id} is the id of the newly inserted record, {\ft s} is the Set object used for update or delete.

\begin{lstlisting}
>>> db.person.insert(name='John')
({'name': 'John'},)
({'name': 'John'}, 1)
>>> db(db.person.id==1).update(name='Tim')
(<Set (person.id = 1)>, {'name': 'Tim'})
(<Set (person.id = 1)>, {'name': 'Tim'})
>>> db(db.person.id==1).delete()
(<Set (person.id = 1)>,)
(<Set (person.id = 1)>,)
\end{lstlisting}

The return values of these callback should be {\ft None} or {\ft False}. If any of the {\ft \_before\_*} callback returns a {\ft True} value it will abort the actual insert/update/delete operation.

\inxx{update\_naive}.

Some times a callback may need to perform an update in the same of a different table and one wants to avoid callbacks calling themselves recursively.

For this purpose there the Set objects have an {\ft update\_naive} method that works like {\ft update} but ignores before and after callbacks.

\goodbreak\subsection{Record versioning}

\inxx{\_enable\_record\_versioning}

It is possible to ask web2py to save every copy of a record when the record is modified. There are different ways to do it and it can be done for all tables at once using the syntax:

\begin{lstlisting}
auth.enable_record_versioning(db)
\end{lstlisting}
\noindent this requires Auth and it is discussed in the chapter about authentication.
It can also be done for each individual table as discussed below.

Consider the following table:

\begin{lstlisting}
db.define_table('stored_item',
    Field('name'),
    Field('quantity','integer'),
    Field('is_active','boolean',
          writable=False,readable=False,default=True))
\end{lstlisting}

Notice the hidden boolean field called {\ft is\_active} and defaulting to
True.

We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.

This is done in the following way:
\begin{lstlisting}
db.stored_item._enable_record_versioning()
\end{lstlisting}
\noindent or in a more verbose syntax:

\begin{lstlisting}
db.stored_item._enable_record_versioning(
    archive_db = db,
    archive_name = 'stored_item_archive',
    current_record = 'current_record',
    is_active = 'is_active')
\end{lstlisting}

The {\ft archive\_db=db} tells web2py to store the archive table in the same database as the {\ft stored\_item} table. The {\ft archive\_name} sets the name for the archive table. The archive table has the same fields as the original table {\ft stored\_item} except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by {\ft current\_record} and which is a reference to the current record in the {\ft stored\_item} table.

When records are deleted, they are not really deleted. A deleted record is copied in the {\ft stored\_item\_archive} table (like when it is modified) and the {\ft is\_active} field is set to False. By enabling record versioning web2py sets a {\ft custom\_filter} on this table that hides all fields in table {\ft stored\_item} where the {\ft is\_active} field is set to False. The {\ft is\_active} parameter in the {\ft \_enable\_record\_versioning} method allows to specify the name of the field used by the {\ft custom\_filter} to determine if the field was deleted or not.

{\ft custom\_filter}s are ignored by the appadmin interface.

\goodbreak\subsection{Common fields and multi-tenancy}

\inxx{common fields}
\inxx{multi tenancy}

{\ft db.\_common\_fields} is a list of fields that should belong to all the tables. This list can also contain tables and it is understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the {\ft `auth} tables. In this case, after you {\ft db.define\_tables()} but before defining any other table, insert

\begin{lstlisting}
db._common_fields.append(auth.signature)
\end{lstlisting}

One field is special: "request\_tenant".
This field does not exist but you can create it and add it to any of your tables (or them all):

\begin{lstlisting}
db._common_fields.append(Field('request_tenant',
    default=request.env.http_host,writable=False))
\end{lstlisting}

For every table with a field called {\ft db.\_request\_tenant}, all records for all queries are always automatically filtered by:

\begin{lstlisting}
db.table.request_tenant == db.table.request_tenant.default
\end{lstlisting}
\noindent and for every record insert, this field is set to the default value.
In the example above we have chosen
\begin{lstlisting}
default = request.env.http_host
\end{lstlisting}
i.e. we have chose to ask our app to filter all tables in all queries with
\begin{lstlisting}
db.table.request_tenant == request.env.http_host
\end{lstlisting}

This simple trick allow us to turn any application into a multi-tenant application. i.e. even if we run one instance of the app and we use one single database, if the app is accessed under two or more domains (in the example the domain name is retrieved from {\ft request.env.http\_host}) the visitors will see different data depending on the domain. Think of running multiple web stores under different domains with one app and one database.

You can turn off multi tenancy filters using: \inxx{ignore\_common\_filters}
\begin{lstlisting}
rows = db(query, ignore_common_filters=True).select()
\end{lstlisting}

\goodbreak\subsection{Common filters}

A common filter is a generalization of the above multi-tenancy idea.
It provides an easy way to prevent repeating of the same query.
Consider for example the following table:

\begin{lstlisting}
db.define_table('blog_post',
    Field('subject'),
    Field('post_text', 'text'),
    Field('is_public', 'boolean'),
    common_filter = lambda query: db.blog_post.is_public==True
)
\end{lstlisting}

Any select, delete or update in this table, will include only public blog posts. The attribute can also be changed in controllers:

\begin{lstlisting}
db.blog_post._common_filter = lambda query: db.blog_post.is_public == True
\end{lstlisting}

It serves both as a way to avoid repeating the "db.blog\_post.is\_public==True" phrase in each blog post search, and also as a security enhancement, that prevents you from forgetting to disallow viewing of none public posts.

In case you actually do want items left out by the common filter (for example, allowing the admin to see none public posts), you can either remove the filter:
\begin{lstlisting}
db.blog_post._common_filter = None
\end{lstlisting}
or ignore it:
\begin{lstlisting}
db(query, ignore_common_filters=True).select(...)
\end{lstlisting}

\goodbreak\subsection{Custom {\ft Field} types (experimental)}

\inxx{SQLCustomType}

It is possible to define new/custom field types. For example we consider here the example if a field that contains binary data in compressed form:

\begin{lstlisting}
from gluon.dal import SQLCustomType
import zlib

compressed = SQLCustomType(
     type ='text',
     native='text',
     encoder =(lambda x: zlib.compress(x or '')),
     decoder = (lambda x: zlib.decompress(x))
)

db.define_table('example', Field('data',type=compressed))
\end{lstlisting}

{\ft SQLCustomType} is a field type factory. Its {\ft type} argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. {\ft native} is the name of the field as far as the database is concerned. Allowed names depend on the database engine. {\ft encoder} is an optional transformation function applied when the data is stored and {\ft decoder} is the optional reversed transformation function.

This feature is marked as experimental. In practice it has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.

\goodbreak\subsection{Using DAL without define tables}

The DAL can be used from any Python program simply by doing this:

\begin{lstlisting}
from gluon import DAL, Field
db = DAL('sqlite://storage.sqlite',folder='path/to/app/databases')
\end{lstlisting}
\noindent i.e. import the DAL, Field, connect and specify the folder which contains the.table files (the app/databases folder).

To access the data and its attributes we still have to define all the tables we are going to access with {\ft db.define\_tables(...)}.

If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the.table files:

\begin{lstlisting}
from gluon import DAL, Field
db = DAL('sqlite://storage.sqlite',folder='path/to/app/databases',
         auto_import=True))
\end{lstlisting}

This allows us to access any {\ft db.table} without need to re-define it.

\goodbreak\subsection{PostGIS, SpatiaLite, and MS Geo (experimental)}

\inxx{PostGIS} \inxx{StatiaLite} \inxx{Geo Extensions}
\inxx{geometry} \inxx{geoPoint} \inxx{geoLine} \inxx{geoPolygon}

The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was sponsored by the Sahana project and implemented by Denes Lengyel.

DAL provides geometry and geography fields types and the following functions:

\inxx{st\_asgeojson} \inxx{st\_astext} \inxx{st\_contained} \inxx{st\_contains}
\inxx{st\_distance} \inxx{st\_equals} \inxx{st\_intersects} \inxx{st\_overlaps}
\inxx{st\_simplify} \inxx{st\_touches} \inxx{st\_within}

\begin{lstlisting}
st_asgeojson (PostGIS only)
st_astext
st_contains
st_distance
st_equals
st_intersects
st_overlaps
st_simplify (PostGIS only)
st_touches
st_within
st_x
st_y
\end{lstlisting}

Here are some examples:

\begin{lstlisting}
from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon
db = DAL("mssql://user:pass@host:db")
sp = db.define_table('spatial', Field('loc','geometry()'))
\end{lstlisting}

Below we insert a point, a line, and a polygon:
\begin{lstlisting}
sp.insert(loc=geoPoint(1,1))
sp.insert(loc=geoLine((100,100),(20,180),(180,180)))
sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))
\end{lstlisting}

Notice that
\begin{lstlisting}
rows = db(sp.id>0).select()
\end{lstlisting}

Always returns the geometry data serialized as text.
You can also do the same more explicitly using {\ft st\_astext()}:

\begin{lstlisting}
print db(sp.id>0).select(sp.id, sp.loc.st_astext())
spatial.id,spatial.loc.STAsText()
1, "POINT (1 2)"
2, "LINESTRING (100 100, 20 180, 180 180)"
3, "POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))"
\end{lstlisting}

You can ask for the native representation by using {\ft st\_asgeojson()} (in PostGIS only):

\begin{lstlisting}
print db(sp.id>0).select(sp.id, sp.loc.st_asgeojson().with_alias('loc'))
spatial.id,loc
1, [1, 2]
2, [[100, 100], [20 180], [180, 180]]
3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]
\end{lstlisting}

(notice an array is a point, an array of arrays is a line, and an array of array of arrays is a polygon).

Here are example of how to use geographical functions:

\begin{lstlisting}
query = sp.loc.st_intersects(geoLine((20,120),(60,160)))
query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))
query = sp.loc.st_contains(geoPoint(1,1))
print db(query).select(sp.id,sp.loc)
spatial.id,spatial.loc
3,"POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))"
\end{lstlisting}

Computed distances can also be retrieved as floating point numbers:

\begin{lstlisting}
dist = sp.loc.st_distance(geoPoint(-1,2)).with_alias('dist')
print db(sp.id>0).select(sp.id, dist)
spatial.id, dist
1 2.0
2 140.714249456
3 1.0
\end{lstlisting}

\goodbreak\subsection{Copy data from one db into another}

Consider the situation in which you have been using the following database:

\begin{lstlisting}
db = DAL('sqlite://storage.sqlite')
\end{lstlisting}
\noindent and you wish to move to another database using a different connection string:

\begin{lstlisting}
db = DAL('postgres://username:password@localhost/mydb')
\end{lstlisting}

Before you switch, you want to move the data and rebuild all the metadata for the new database. We assume the new database to exist but we also assume it is empty.

Web2py provides a script that does this work for you:

\begin{lstlisting}
cd web2py
python scripts/cpdb.py \
   -f applications/app/databases \
   -y 'sqlite://storage.sqlite' \
   -Y 'postgres://username:password@localhost/mydb'
\end{lstlisting}

After running the script you can simply switch the connection string in the model and everything should work out of the box. The new data should be there.

This script provides various command line options that allows you to move data from one application to another, move all tables or only some tables, clear the data in the tables. for more info try:

\begin{lstlisting}
python scripts/cpdb.py -h
\end{lstlisting}

\goodbreak\subsection{Note on new DAL and adapters}

The source code of the Database Abstraction Layer was completely rewritten in 2010. While it stays backward compatible, the rewrite made it more modular and easier to extend. Here we explain the main logic.

The file "gluon/dal.py" defines, among other, the following classes.

\begin{lstlisting}
ConnectionPool
BaseAdapter extends ConnectionPool
Row
DAL
Reference
Table
Expression
Field
Query
Set
Rows
\end{lstlisting}

Their use has been explained in the previous sections, except for {\ft BaseAdapter}. When the methods of a {\ft Table} or {\ft Set} object need to communicate with the database they delegate to methods of the adapter the task to generate the SQL and or the function call.

For example:

\begin{lstlisting}
db.mytable.insert(myfield='myvalue')
\end{lstlisting}
\noindent calls

\begin{lstlisting}
Table.insert(myfield='myvalue')
\end{lstlisting}
\noindent which delegates the adapter by returning:

\begin{lstlisting}
db._adapter.insert(db.mytable,db.mytable._listify(dict(myfield='myvalue')))
\end{lstlisting}

Here {\ft db.mytable.\_listify} converts the dict of arguments into a list of {\ft (field,value)} and calls the {\ft insert} method of the {\ft adapter}. {\ft db.\_adapter} does more or less the following:

\begin{lstlisting}
query = db._adapter._insert(db.mytable,list_of_fields)
db._adapter.execute(query)
\end{lstlisting}
\noindent where the first line builds the query and the second executes it.

{\ft BaseAdapter} define the interface for all adapters.

"gluon/dal.py" at the moment of writing this book, contains the following adapters:

\begin{lstlisting}
SQLiteAdapter extends BaseAdapter
JDBCSQLiteAdapter extends SQLiteAdapter
MySQLAdapter extends BaseAdapter
PostgreSQLAdapter extends BaseAdapter
JDBCPostgreSQLAdapter extends PostgreSQLAdapter
OracleAdapter extends BaseAdapter
MSSQLAdapter extends BaseAdapter
MSSQL2Adapter extends MSSQLAdapter
FireBirdAdapter extends BaseAdapter
FireBirdEmbeddedAdapter extends FireBirdAdapter
InformixAdapter extends BaseAdapter
DB2Adapter extends BaseAdapter
IngresAdapter extends BaseAdapter
IngresUnicodeAdapter extends IngresAdapter
GoogleSQLAdapter extends MySQLAdapter
NoSQLAdapter extends BaseAdapter
GoogleDatastoreAdapter extends NoSQLAdapter
CubridAdapter extends MySQLAdapter (experimental)
TeradataAdapter extends DB2Adapter (experimental)
SAPDBAdapter extends BaseAdapter (experimental)
CouchDBAdapter extends NoSQLAdapter (experimental)
MongoDBAdapter extends NoSQLAdapter (experimental)
\end{lstlisting}
\noindent which override the behavior of the {\ft BaseAdapter}.

Each adapter has more or less this structure:

\begin{lstlisting}
class MySQLAdapter(BaseAdapter):

    # specify a diver to use
    driver = globals().get('pymysql',None)

    # map web2py types into database types
    types = {
        'boolean': 'CHAR(1)',
        'string': 'VARCHAR(%(length)s)',
        'text': 'LONGTEXT',
        ...
        }

    # connect to the database using driver
    def __init__(self,db,uri,pool_size=0,folder=None,db_codec ='UTF-8',
                credential_decoder=lambda x:x, driver_args={},
                adapter_args={}):
        # parse uri string and store parameters in driver_args
        ...
        # define a connection function
        def connect(driver_args=driver_args):
            return self.driver.connect(**driver_args)
        # place it in the pool
        self.pool_connection(connect)
        # set optional parameters (after connection)
        self.execute('SET FOREIGN_KEY_CHECKS=1;')
        self.execute("SET sql_mode='NO_BACKSLASH_ESCAPES';")

   # override BaseAdapter methods as needed
   def lastrowid(self,table):
        self.execute('select last_insert_id();')
        return int(self.cursor.fetchone()[0])

\end{lstlisting}

Looking at the various adapters as examples should be easy to write new ones.

When {\ft db} instance is created:

\begin{lstlisting}
db = DAL('mysql://...')
\end{lstlisting}
\noindent the prefix in the uri string defines the adapter. The mapping is defined in the following dictionary also in "gluon/dal.py":

\begin{lstlisting}
ADAPTERS = {
    'sqlite': SQLiteAdapter,
    'sqlite:memory': SQLiteAdapter,
    'mysql': MySQLAdapter,
    'postgres': PostgreSQLAdapter,
    'oracle': OracleAdapter,
    'mssql': MSSQLAdapter,
    'mssql2': MSSQL2Adapter,
    'db2': DB2Adapter,
    'teradata': TeradataAdapter,
    'informix': InformixAdapter,
    'firebird': FireBirdAdapter,
    'firebird_embedded': FireBirdAdapter,
    'ingres': IngresAdapter,
    'ingresu': IngresUnicodeAdapter,
    'sapdb': SAPDBAdapter,
    'cubrid': CubridAdapter,
    'jdbc:sqlite': JDBCSQLiteAdapter,
    'jdbc:sqlite:memory': JDBCSQLiteAdapter,
    'jdbc:postgres': JDBCPostgreSQLAdapter,
    'gae': GoogleDatastoreAdapter, # discouraged, for backward compatibility
    'google:datastore': GoogleDatastoreAdapter,
    'google:sql': GoogleSQLAdapter,
    'couchdb': CouchDBAdapter,
    'mongodb': MongoDBAdapter,
}
\end{lstlisting}
\noindent the uri string is then parsed in more detail by the adapter itself.

For any adapter you can replace the driver with a different one:

\begin{lstlisting}
from gluon.dal import MySQLAdapter
MySQLAdapter.driver = mysqldb
\end{lstlisting}
\noindent and you can specify optional driver arguments and adapter arguments:

\begin{lstlisting}
db =DAL(..., driver_args={}, adapter_args={})
\end{lstlisting}

\goodbreak\subsection{Gotchas}

{\bf SQLite} does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set {\ft fake\_migrate=True} so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, {\bf SQLite} is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type "string" with type "integer", SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.

{\bf MySQL} does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set {\ft fake\_migrate=True} and after the metadata has been rebuilt, set {\ft fake\_migrate=False} and migrate the table again).

{\bf Google SQL} has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read-only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (my migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (my accessing the database using the Google dashboard and deleting any corrupted entry from the table called {\ft web2py\_filesystem}.

\inxx{limitby}
{\bf MSSQL} does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a {\ft limitby=(a,b)} web2py will fetch the first {\ft b} rows and discard the first {\ft a}. This may result in a considerable overhead when compared with other database engines.

{\bf Oracle} also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a {\ft db(...).select(limitby=(a,b))} into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.

{\bf MSSQL} has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSSQL bug and you work around it by setting the ondelete attribute for all reference fields to "NO ACTION". You can also do it once and for all before you define tables:

\begin{lstlisting}
db = DAL('mssql://....')
for key in ['reference','reference FK']:
    db._adapter.types[key]=db._adapter.types[key].replace(
        '%(on_delete_action)s','NO ACTION')
\end{lstlisting}

{\bf MSSQL} also has problems with arguments passed to the DISTINCT keyword and therefore
while this works,

\begin{lstlisting}
db(query).select(distinct=True)
\end{lstlisting}
\noindent this does not

\begin{lstlisting}
db(query).select(distinct=db.mytable.myfield)
\end{lstlisting}

{\bf Google NoSQL (Datastore)} does not allow joins, left joins, aggregates, expression, OR involving more than one table, the ‘like’ operator searches in "text" fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API {\ft run\_in\_transaction} which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the "list:string" type is mapped into a "text" type, on the Google Datastore it is mapped into a {\ft ListStringProperty}. Similarly "list:integer" and "list:reference" are mapped into "ListProperty". This makes searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.

\goodbreak\chapter{Forms and validators}

There are four distinct ways to build forms in web2py:
\begin{itemize}
\item {\ft FORM} provides a low-level implementation in terms of HTML helpers. A {\ft FORM} object can be serialized into HTML and is aware of the fields it contains. A {\ft FORM} object knows how to validate submitted form values.

\item {\ft SQLFORM} provides a high-level API for building create, update and delete forms from an existing database table.

\item {\ft SQLFORM.factory} is an abstraction layer on top of {\ft SQLFORM} in order to take advantage of the form generation features even if there is no database present. It generates a form very similar to {\ft SQLFORM} from the description of a table but without the need to create the database table.

\item {\ft CRUD} methods. These are functionally equivalent to SQLFORM and are based on SQLFORM, but provide a more compact notation.
\end{itemize}

All these forms are self-aware and, if the input does not pass validation, they can modify themselves and add error messages. The forms can be queried for the validated variables and for error messages that have been generated by validation.

Arbitrary HTML code can be inserted into or extracted from the form using helpers.

{\ft FORM} and {\ft SQLFORM} are helpers and they can be manipulated in a similar way as the {\ft DIV}. For example you can set a form style:

\begin{lstlisting}
form = SQLFORM(..)
form['_style']='border:1px solid black'
\end{lstlisting}

\goodbreak\section{{\ft FORM}}

\inxx{form} \inxx{accepts} \inxx{formname}

Consider as an example a {\bf test} application with the following "default.py" controller:
\begin{lstlisting}
def display_form():
    return dict()
\end{lstlisting}
\noindent and the associated "default/display\_form.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h2>Input form</h2>
<form enctype="multipart/form-data"
      action="{{=URL()}}" method="post">
Your name:
<input name="name" />
<input type="submit" />
</form>
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
\end{lstlisting}

This is a regular HTML form that asks for the user's name. When you fill the form and click the submit button, the form self-submits, and the variable {\ft request.vars.name} along with its provided value is displayed at the bottom.

You can generate the same form using helpers. This can be done in the view or in the action. Since web2py processed the form in the action, it is better to define the form in the action itself.

Here is the new controller:
\begin{lstlisting}
def display_form():
   form=FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
   return dict(form=form)
\end{lstlisting}
\noindent and the associated "default/display\_form.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
\end{lstlisting}

The code so far is equivalent to the previous code, but the form is generated by the statement {\ft \{\{=form\}\}} which serializes the {\ft FORM} object.

Now we add one level of complexity by adding form validation and processing.

Change the controller as follows:
\begin{lstlisting}
def display_form():
    form=FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request,session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)
\end{lstlisting}
\noindent and the associated "default/display\_form.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h2>Input form</h2>
{{=form}}
<h2>Submitted variables</h2>
{{=BEAUTIFY(request.vars)}}
<h2>Accepted variables</h2>
{{=BEAUTIFY(form.vars)}}
<h2>Errors in form</h2>
{{=BEAUTIFY(form.errors)}}
\end{lstlisting}

Notice that:
\begin{itemize}
\item In the action, we added the {\ft requires=IS\_NOT\_EMPTY()} validator for the input field "name".

\item In the action, we added a call to {\ft form.accepts(..)}

\item In the view, we are printing {\ft form.vars} and {\ft form.errors} as well as the form and {\ft request.vars}.
\end{itemize}

All the work is done by the {\ft accepts} method of the {\ft form} object. It filters the {\ft request.vars} according to the declared requirements (expressed by validators). {\ft accepts} stores those variables that pass validation into {\ft form.vars}. If a field value does not meet a requirement, the failing validator returns an error and the error is stored in {\ft form.errors}. Both {\ft form.vars} and {\ft form.errors} are {\ft gluon.storage.Storage} objects similar to {\ft request.vars}. The former contains the values that passed validation, for example:
\begin{lstlisting}
form.vars.name = "Max"
\end{lstlisting}

The latter contains the errors, for example:
\begin{lstlisting}
form.errors.name = "Cannot be empty!"
\end{lstlisting}

The full signature of the {\ft accepts} method is the following:
\inxx{onvalidation}
\begin{lstlisting}
form.accepts(vars, session=None, formname='default',
             keepvalues=False, onvalidation=None,
             dbio=True, hideerror=False):
\end{lstlisting}

The meaning of the optional parameters is explained in the next sub-sections.

The first argument can be {\ft request.vars} or {\ft request.get\_vars} or {\ft request.post\_vars} or simply {\ft request}. The latter is equivalent to accepting as input the {\ft request.post\_vars}.

The {\ft accepts}  function returns {\ft True} if the form is accepted and {\ft False} otherwise. A form is not accepted if it has errors or when it has not been submitted (for example, the first time it is shown).

Here is how this page looks the first time it is displayed:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5800.png}\end{center}


Here is how it looks upon invalid submission:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en5900.png}\end{center}


Here is how it looks upon a valid submission:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6000.png}\end{center}


\goodbreak\subsection{The {\ft process} and {\ft validate} methods}

A shortcut for
\begin{lstlisting}
form.accepts(request.post_vars,session,...)
\end{lstlisting}
is
\begin{lstlisting}
form.process(...).accepted
\end{lstlisting}
the latter does not need the {\ft request} and {\ft session} arguments (although you can specify them optionally). it also differs from {\ft accepts} because it returns the form itself. Internally {\ft process} calls accepts and passes its arguments to it. The value returned by accepts is stored in {\ft form.accepted}.

The process function takes some extra argument that {\ft accepts} does not take:
\begin{itemize}
\item {\ft message\_onsuccess}

\item {\ft onsuccess}: if equal to 'flash' (default) and the form is accepted it will flash the above 'message\_onsuccess\begin{lstlisting}
- 
\end{lstlisting}message\_onfailure\begin{lstlisting}
- 
\end{lstlisting}onfailure{\ft : if equal to 'flash' (default) and the form fails validation, it will flash the above `message\_onfailure}

\item {\ft next} the user to redirect after the form is accepted.
\end{itemize}
{\ft onsuccess} and {\ft onfailure} can be functions like {\ft lambda form: do\_something(form)}.

\begin{lstlisting}
form.validate(...)
\end{lstlisting}
\noindent is a shortcut for

\begin{lstlisting}
form.process(...,dbio=False).accepted
\end{lstlisting}

\goodbreak\subsection{Hidden fields}

When the above form object is serialized by {\ft \{\{=form\}\}}, and because of the previous call to the {\ft accepts} method, it now looks like this:
\begin{lstlisting}[keywords={}]
<form enctype="multipart/form-data" action="" method="post">
your name:
<input name="name" />
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
\end{lstlisting}

Notice the presence of two hidden fields: "\_formkey" and "\_formname". Their presence is triggered by the call to {\ft accepts} and they play two different and important roles:
\begin{itemize}
\item The hidden field called "\_formkey" is a one-time token that web2py uses to prevent double submission of forms. The value of this key is generated when the form is serialized and stored in the {\ft session}. When the form is submitted this value must match, or else {\ft accepts} returns {\ft False} without errors as if the form was not submitted at all. This is because web2py cannot determine whether the form was submitted correctly.

\item The hidden field called "\_formname" is generated by web2py as a name for the form, but the name can be overridden. This field is necessary to allow pages that contain and process multiple forms. web2py distinguishes the different submitted forms by their names.

\item Optional hidden fields specified as {\ft FORM(..,hidden=dict(...))}.
\end{itemize}

The role of these hidden fields and their usage in custom forms and pages with multiple forms is discussed in more detail later in the chapter.

If the form above is submitted with an empty "name" field, the form does not pass validation. When the form is serialized again it appears as:
\begin{lstlisting}[keywords={}]
<form enctype="multipart/form-data" action="" method="post">
your name:
<input value="" name="name" />
<div class="error">cannot be empty!</div>
<input type="submit" />
<input value="783531473471" type="hidden" name="_formkey" />
<input value="default" type="hidden" name="_formname" />
</form>
\end{lstlisting}

Notice the presence of a DIV of class "error" in the serialized form. web2py inserts this error message in the form to notify the visitor about the field that did not pass validation. The {\ft accepts} method, upon submission, determines that the form is submitted, checks whether the field "name" is empty and whether it is required, and eventually inserts the error message from the validator into the form.

The base "layout.html" view is expected to handle DIVs of class "error". The default layout uses jQuery effects to make errors appear and slide down with a red background. See Chapter 11 for more details.

\goodbreak\subsection{{\ft keepvalues}}

\inxx{keepvalues}

The optional argument {\ft keepvalues} tells web2py what to do when a form is accepted and there is no redirection, so the same form is displayed again. By default the form is cleared. If {\ft keepvalues} is set to {\ft True}, the form is pre-populated with the previously inserted values. This is useful when you have a form that is supposed to be used repeatedly to insert multiple similar records. If the {\ft dbio} argument is set to {\ft False}, web2py will not perform any DB insert/update after accepting form. If {\ft hideerror} is set to {\ft True} and the form contains errors, these will not be displayed when the form is rendered (it will be up to you to display them from {\ft form.errors} somehow. The {\ft onvalidation} argument is explained below.

\goodbreak\subsection{{\ft onvalidation}}

The {\ft onvalidation} argument can be {\ft None} or can be a function that takes the form and returns nothing. Such a function would be called and passed the form, immediately after validation (if validation passes) and before anything else happens. The purpose of this function is multifold. It can be used, for example, to perform additional checks on the form and eventually add errors to the form. It can also be used to compute the values of some fields based on the values of other fields. It can be used to trigger some action (like sending an email) before a record is created/updated.

Here is an example:
\begin{lstlisting}
db.define_table('numbers',
    Field('a', 'integer'),
    Field('b', 'integer'),
    Field('c', 'integer', readable=False, writable=False))

def my_form_processing(form):
    c = form.vars.a * form.vars.b
    if c < 0:
       form.errors.b = 'a*b cannot be negative'
    else:
       form.vars.c = c

def insert_numbers():
   form = SQLFORM(db.numbers)
   if form.process(onvalidation=my_form_processing).accepted:
       session.flash = 'record inserted'
       redirect(URL())
   return dict(form=form)
\end{lstlisting}

\goodbreak\subsection{Detect record change}

When filling a form to edit a record there is a small probability that another user may concurrently be editing the same record. So when we save the record we want to check for possible conflicts. This can be done:

\begin{lstlisting}
db.define_table('dog',Field('name'))

def edit_dog():
    dog = db.dog(request.args(0)) or redirect(URL('error'))
    form=SQLFORM(db.dog,dog)
    form.process(detect_record_change=True)
    if form.record_changed:
        # do something
    elif form.accepted:
        # do something else
    else:
        # do nothing
    return dict(form=form)
\end{lstlisting}

\goodbreak\subsection{Forms and redirection}

The most common way to use forms is via self-submission, so that the submitted field variables are processed by the same action that generated the form. Once the form is accepted, it is unusual to display the current page again (something we are doing here only to keep things simple). It is more common to redirect the visitor to a "next" page.

Here is the new example controller:
\begin{lstlisting}
def display_form():
    form = FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.flash = 'form accepted'
        redirect(URL('next'))
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)

def next():
    return dict()
\end{lstlisting}

In order to set a flash on the next page instead of the current page you must use {\ft session.flash} instead of {\ft response.flash}. web2py moves the former into the latter after redirection. Note that using {\ft session.flash} requires that you do not {\ft session.forget()}.

\goodbreak\subsection{Multiple forms per page}

The content of this section applies to both {\ft FORM} and {\ft SQLFORM} objects.
It is possible to have multiple forms per page, but you must allow web2py to distinguish them. If these are derived by {\ft SQLFORM} from different tables, then web2py gives them different names automatically; otherwise you need to explicitly give them different form names. Here is an example:
\begin{lstlisting}
def two_forms():
    form1 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    form2 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    if form1.process(formname='form_one').accepted:
        response.flash = 'form one accepted'
    if form2.process(formname='form_two').accepted:
        response.flash = 'form two accepted'
    return dict(form1=form1, form2=form2)
\end{lstlisting}
\noindent and here is the output it produces:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6100.png}\end{center}


When the visitor submits an empty form1, only form1 displays an error; if the visitor submits an empty form2, only form2 displays an error message.

\goodbreak\subsection{Sharing forms}

The content of this section applies to both {\ft FORM} and {\ft SQLFORM} objects. What we discuss here is possible but not recommended, since it is always good practice to have forms that self-submit. Sometimes, though, you don't have a choice, because the action that sends the form and the action that receives it belong to different applications.

It is possible to generate a form that submits to a different action. This is done by specifying the URL of the processing action in the attributes of the {\ft FORM} or {\ft SQLFORM} object. For example:
\begin{lstlisting}
form = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
        INPUT(_type='submit'), _action=URL('page_two'))

def page_one():
    return dict(form=form)

def page_two():
    if form.process(session=None, formname=None).accepted:
         response.flash = 'form accepted'
    else:
         response.flash = 'there was an error in the form'
    return dict()
\end{lstlisting}

Notice that since both "page\_one" and "page\_two" use the same {\ft form}, we have defined it only once by placing it outside of all the actions, in order not to repeat ourselves. The common portion of code at the beginning of a controller gets executed every time before giving control to the called action.

Since "page\_one" does not call {\ft process} (nor {\ft accepts}), the form has no name and no key, so you must pass  {\ft session=None} and set {\ft formname=None} in {\ft process}, or the form will not validate when "page\_two" receives it.

\goodbreak\subsection{Adding buttons to FORMs}

Usually a form provides a single submit button. It is common to want to add a "back" button that instead of submitting the form, directs the visitor to a different page.

\inxx{add\_button}

This can be done with the {\ft add\_button} method:

\begin{lstlisting}
form.add_button('Back', URL('other_page'))
\end{lstlisting}

You can add more than one button to form. The arguments of {\ft add\_button} are the value of the button (its text) and the url where to redirect to.

\goodbreak\subsection{More about manipulation of FORMs}

As discussed in the Views chapter, a FORM is an HTML helper. Helpers can be manipulated as Python lists and as dictionaries, which enables run-time creation and modification.

\goodbreak\section{{\ft SQLFORM}}

We now move to the next level by providing the application with a model file:
\begin{lstlisting}
db = DAL('sqlite://storage.sqlite')
db.define_table('person', Field('name', requires=IS_NOT_EMPTY()))
\end{lstlisting}

Modify the controller as follows:
\begin{lstlisting}
def display_form():
   form = SQLFORM(db.person)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill out the form'
   return dict(form=form)
\end{lstlisting}

The view does not need to be changed.

In the new controller, you do not need to build a {\ft FORM}, since the {\ft SQLFORM} constructor built one from the table {\ft db.person} defined in the model. This new form, when serialized, appears as:
\begin{lstlisting}[keywords={}]
<form enctype="multipart/form-data" action="" method="post">
  <table>
    <tr id="person_name__row">
       <td><label id="person_name__label"
                  for="person_name">Your name: </label></td>
       <td><input type="text" class="string"
                  name="name" value="" id="person_name" /></td>
       <td></td>
    </tr>
    <tr id="submit_record__row">
       <td></td>
       <td><input value="Submit" type="submit" /></td>
       <td></td>
    </tr>
  </table>
  <input value="9038845529" type="hidden" name="_formkey" />
  <input value="person" type="hidden" name="_formname" />
</form>
\end{lstlisting}

The automatically generated form is more complex than the previous low-level form. First of all, it contains a table of rows, and each row has three columns. The first column contains the field labels (as determined from the {\ft db.person}), the second column contains the input fields (and eventually error messages), and the third column is optional and therefore empty (it can be populated with the fields in the {\ft SQLFORM} constructor).

All tags in the form have names derived from the table and field name. This allows easy customization of the form using CSS and JavaScript. This capability is discussed in more detail in Chapter 11.

More important is that now the {\ft accepts} method does a lot more work for you. As in the previous case, it performs validation of the input, but additionally, if the input passes validation, it also performs a database insert of the new record and stores in {\ft form.vars.id} the unique "id" of the new record.

A {\ft SQLFORM} object also deals automatically with "upload" fields by saving uploaded files in the "uploads" folder (after having them renamed safely to avoid conflicts and prevent directory traversal attacks) and stores their names (their new names) into the appropriate field in the database. After the form has been processed, the new filename is available in {\ft form.vars.fieldname} (i.e., it replaces the {\ft cgi.FieldStorage} object in {\ft request.vars.fieldname}), so you can easily reference the new name right after upload.

A {\ft SQLFORM} displays "boolean" values with checkboxes, "text" values with textareas, values required to be in a definite set or a database with drop-boxes, and "upload" fields with links that allow users to download the uploaded files. It hides "blob" fields, since they are supposed to be handled differently, as discussed later.

For example, consider the following model:
\begin{lstlisting}
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('married', 'boolean'),
    Field('gender', requires=IS_IN_SET(['Male', 'Female', 'Other'])),
    Field('profile', 'text'),
    Field('image', 'upload'))
\end{lstlisting}

In this case, {\ft SQLFORM(db.person)} generates the form shown below:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6200.png}\end{center}


The {\ft SQLFORM} constructor allows various customizations, such as displaying only a subset of the fields, changing the labels, adding values to the optional third column, or creating UPDATE and DELETE forms, as opposed to INSERT forms like the current one.
{\ft SQLFORM} is the single biggest time-saver object in web2py.

The class {\ft SQLFORM} is defined in "gluon/sqlhtml.py". It can be easily extended by overriding its {\ft xml} method, the method that serializes the objects, to change its output.

\inxx{fields} \inxx{labels}
The signature for the {\ft SQLFORM} constructor is the following:
\begin{lstlisting}
SQLFORM(table, record = None,
        deletable = False, linkto = None,
        upload = None, fields = None, labels = None,
        col3 = {}, submit_button = 'Submit',
        delete_label = 'Check to delete:',
        showid = True, readonly = False,
        comments = True, keepopts = [],
        ignore_rw = False, record_id = None,
        formstyle = 'table3cols',
        buttons = ['submit'], separator = ': ',
        **attributes)

\end{lstlisting}
\begin{itemize}
\item The optional second argument turns the INSERT form into an UPDATE form for the specified record (see next subsection). \inxx{showid} \inxx{delete\_label} \inxx{id\_label} \inxx{submit\_button}

\item If {\ft deletable} is set to {\ft True}, the UPDATE form displays a "Check to delete" checkbox. The value of the label if this field is set via the {\ft delete\_label} argument.

\item {\ft submit\_button} sets the value of the submit button.

\item {\ft id\_label} sets the label of the record "id"

\item The "id" of the record is not shown if {\ft showid} is set to {\ft False}.

\item {\ft fields} is an optional list of field names that you want to display. If a list is provided, only fields in the list are displayed. For example:
\end{itemize}
\begin{lstlisting}
fields = ['name']
\end{lstlisting}
\begin{itemize}
\item {\ft labels} is a dictionary of field labels. The dictionary key is a field name and the corresponding value is what gets displayed as its label. If a label is not provided, web2py derives the label from the field name (it capitalizes the field name and replaces underscores with spaces). For example:
\end{itemize}
\begin{lstlisting}
labels = {'name':'Your Full Name:'}
\end{lstlisting}
\begin{itemize}
\item {\ft col3} is a dictionary of values for the third column. For example:
\end{itemize}
\begin{lstlisting}
col3 = {'name':A('what is this?',
      _href='http://www.google.com/search?q=define:name')}
\end{lstlisting}
\begin{itemize}
\item {\ft linkto} and {\ft upload} are optional URLs to user-defined controllers that allow the form to deal with reference fields. This is discussed in more detail later in the section.

\item {\ft readonly}. If set to True, displays the form as readonly

\item {\ft comments}. If set to False, does not display the col3 comments

\item {\ft ignore\_rw}. Normally, for a create/update form, only fields marked as writable=True are shown, and for readonly forms, only fields marked as readable=True are shown. Setting {\ft ignore\_rw=True} causes those constraints to be ignored, and all fields are displayed. This is mostly used in the appadmin interface to display all fields for each table, overriding what the model indicates.

\item \inxx{formstyle} {\ft formstyle} determines the style to be used when serializing the form in html. It can be "table3cols" (default), "table2cols" (one row for label and comment, and one row for input), "ul" (makes an unordered list of input fields), "divs" (represents the form using css friendly divs, for arbitrary customization). {\ft formstyle} can also be a function that takes (record\_id, field\_label, field\_widget, field\_comment) as attributes and returns a TR() object.

\item \inxx{buttons} is a list of {\ft INPUT}s or {\ft TAG.BUTTON}s (though technically could be any combination of helpers) that will be added to a DIV where the submit button would go.

\item \inxx{separator} {\ft separator} sets the string that separates form labels from form input fields.

\item Optional {\ft attributes} are arguments starting with underscore that you want to pass to the {\ft FORM} tag that renders the {\ft SQLFORM} object. Examples are:
\end{itemize}
\begin{lstlisting}
_action = '.'
_method = 'POST'
\end{lstlisting}

There is a special {\ft hidden} attribute. When a dictionary is passed as {\ft hidden}, its items are translated into "hidden" INPUT fields (see the example for the {\ft FORM} helper in Chapter 5).

\begin{lstlisting}
form = SQLFORM(....,hidden=...)
\end{lstlisting}
causes the hidden fields to be passed  with the submission, no more, no less.
{\ft form.accepts(...)} is not
intended to read the received hidden fields and move them into
form.vars. The reason is security. hidden fields can be tampered with.
So you have to do explicitly move hidden fields from the request to the form:

\begin{lstlisting}
form.vars.a = request.vars.a
form = SQLFORM(..., hidden=dict(a='b'))
\end{lstlisting}

\goodbreak\subsection{{\ft SQLFORM} and {\ft insert}/{\ft update}/{\ft delete}}

{\ft SQLFORM} creates a new db record when the form is accepted. Assuming {\ft form=SQLFORM(db.test)}, then the id of the last-created record will be accessible in {\ft myform.vars.id}.

\inxx{delete record}
If you pass a record as the optional second argument to the {\ft SQLFORM} constructor, the form becomes an UPDATE form for that record. This means that when the form is submitted the existing record is updated and no new record is inserted. If you set the argument {\ft deletable=True}, the UPDATE form displays a "check to delete" checkbox. If checked, the record is deleted.

\begin{quote}If a form is submitted and the delete checkbox is checked the attribute
{\ft form.deleted} is set to {\ft True}.\end{quote}
You can modify the controller of the previous example so that when we pass an additional integer argument in the URL path, as in:
\begin{lstlisting}
/test/default/display_form/2
\end{lstlisting}
\noindent and if there is a record with the corresponding id, the {\ft SQLFORM} generates an UPDATE/DELETE form for the record:
\begin{lstlisting}
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
\end{lstlisting}

Line 2 finds the record and line 3 makes an UPDATE/DELETE form. Line 4 does all the corresponding form processing.

\begin{quote}An update form is very similar to a create form except that it is pre-populated with the current record and it previews images. By default {\ft deletable = True} which means the update form will display a "delete record" option.\end{quote}
Edit forms also contain a hidden INPUT field with {\ft name="id"} which is used to identify the record. This id is also stored server-side for additional security and, if the visitor tampers with the value of this field, the UPDATE is not performed and web2py raises a SyntaxError, "user is tampering with form".

When a Field is marked with {\ft writable=False}, the field is not shown in create forms, and it is shown readonly in update forms. If a field is marked as {\ft writable=False} and {\ft readable=False}, then the field is not shown at all, not even in update forms.

Forms created with
\begin{lstlisting}
form = SQLFORM(...,ignore_rw=True)
\end{lstlisting}
\noindent ignore the {\ft readable} and {\ft writable} attributes and always show all fields. Forms in {\ft appadmin} ignore them by default.

Forms created with
\begin{lstlisting}
form = SQLFORM(table,record_id,readonly=True)
\end{lstlisting}
\noindent always show all fields in readonly mode, and they cannot be accepted.

\goodbreak\subsection{{\ft SQLFORM} in HTML}

There are times when you want to use {\ft SQLFORM} to benefit from its form generation and processing, but you need a level of customization of the form in HTML that you cannot achieve with the parameters of the {\ft SQLFORM} object, so you have to design the form using HTML.

Now, edit the previous controller and add a new action:
\begin{lstlisting}
def display_manual_form():
   form = SQLFORM(db.person)
   if form.process(session=None, formname='test').accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill the form'
   # Note: no form instance is passed to the view
   return dict()
\end{lstlisting}
\noindent and insert the form in the associated "default/display\_manual\_form.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<form>
<ul>
  <li>Your name is <input name="name" /></li>
</ul>
  <input type="submit" />
  <input type="hidden" name="_formname" value="test" />
</form>
\end{lstlisting}

Notice that the action does not return the form because it does not need to pass it to the view. The view contains a form created manually in HTML. The form contains a hidden field "\_formname" that must be the same {\ft formname} specified as an argument of {\ft accepts} in the action. web2py uses the form name in case there are multiple forms on the same page, to determine which one was submitted. If the page contains a single form, you can set {\ft formname=None} and omit the hidden field in the view.

{\ft form.accepts} will look inside {\ft response.vars} for data that matches fields in the database table {\ft db.person}.  These fields are declared in the HTML in the format
{\ft <input name="field\_name\_goes\_here" />}

Note that in the example given, the form variables will be passed on the URL as arguments.  If this is not desired, the {\ft POST} protocol will have to be specified.  Note furthermore, that if upload fields are specified, the form will have to be set up to allow this.  Here, both options are shown:
\begin{lstlisting}[keywords={}]
<form enctype="multipart/form-data" method="post">
\end{lstlisting}

\goodbreak\subsection{{\ft SQLFORM} and uploads}

Fields of type "upload" are special. They are rendered as INPUT fields of {\ft type="file"}. Unless otherwise specified, the uploaded file is streamed in using a buffer, and stored under the "uploads" folder of the application using a new safe name, assigned automatically. The name of this file is then saved into the field of type uploads.

As an example, consider the following model:
\begin{lstlisting}
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image', 'upload'))
\end{lstlisting}

You can use the same controller action "display\_form" shown above.

When you insert a new record, the form allows you to browse for a file.
Choose, for example, a jpg image. The file is uploaded and stored as:
\begin{lstlisting}
applications/test/uploads/person.image.XXXXX.jpg
\end{lstlisting}

"XXXXXX" is a random identifier for the file assigned by web2py.

\inxx{content-disposition}

\begin{quote}Notice that, by default, the original filename of an uploaded file is b16encoded and used to build the new name for the file. This name is retrieved by the default "download" action and used to set the content disposition header to the original filename.\end{quote}
Only its extension is preserved. This is a security requirement since the filename may contain special characters that could allow a visitor to perform directory traversal attacks or other malicious operations.

The new filename is also stored in {\ft form.vars.image}.

When editing the record using an UPDATE form, it would be nice to display a link to the existing uploaded file, and web2py provides a way to do it.

If you pass a URL to the {\ft SQLFORM} constructor via the upload argument, web2py uses the action at that URL to download the file. Consider the following actions:
\begin{lstlisting}
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record, deletable=True,
                  upload=URL('download'))
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)

def download():
    return response.download(request, db)
\end{lstlisting}

Now, insert a new record at the URL:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/test/default/display_form
\end{lstlisting}

Upload an image, submit the form, and then edit the newly created record
by visiting:
\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/test/default/display_form/3
\end{lstlisting}

(here we assume the latest record has id=3). The form will display an image preview as shown below:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6300.png}\end{center}


This form, when serialized, generates the following HTML:
\begin{lstlisting}[keywords={}]
<td><label id="person_image__label" for="person_image">Image: </label></td>
<td><div><input type="file" id="person_image" class="upload" name="image"
/>[<a href="/test/default/download/person.image.0246683463831.jpg">file</a>|
<input type="checkbox" name="image__delete" />delete]</div></td><td></td></tr>
<tr id="delete_record__row"><td><label id="delete_record__label" for="delete_record"
>Check to delete:</label></td><td><input type="checkbox" id="delete_record"
class="delete" name="delete_this_record" /></td>
\end{lstlisting}
\noindent which contains a link to allow downloading of the uploaded file, and a checkbox to remove the file from the database record, thus storing NULL in the "image" field.

Why is this mechanism exposed? Why do you need to write the download function? Because you may want to enforce some authorization mechanism in the download function. See Chapter 9 for an example.

Normally uploaded files are stored into "app/uploads" but you can specify an alternate location:
\begin{lstlisting}
Field('image', 'upload', uploadfolder='...')
\end{lstlisting}
In most operating system, accessing the file system can become slow when there are many files in the same folder. If you plan to upload more than 1000 files you can ask web2py to organize the uploads in subfolders:
\begin{lstlisting}
Field('image', 'upload', uploadseparate=True)
\end{lstlisting}

\goodbreak\subsection{Storing the original filename}
\noindent web2py automatically stores the original filename inside the new UUID filename and retrieves it when the file is downloaded. Upon download, the original filename is stored in the content-disposition header of the HTTP response. This is all done transparently without the need for programming.

Occasionally you may want to store the original filename in a database field. In this case, you need to modify the model and add a field to store it in:
\begin{lstlisting}
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image_filename'),
    Field('image', 'upload'))
\end{lstlisting}
\noindent then you need to modify the controller to handle it:
\begin{lstlisting}
def display_form():
    record = db.person(request.args(0)) or redirect(URL('index'))
    url = URL('download')
    form = SQLFORM(db.person, record, deletable=True,
                   upload=url, fields=['name', 'image'])
    if request.vars.image!=None:
        form.vars.image_filename = request.vars.image.filename
    if form.process().accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
\end{lstlisting}

Notice that the {\ft SQLFORM} does not display the "image\_filename" field.
The "display\_form" action moves the filename of the {\ft request.vars.image}
into the {\ft form.vars.image\_filename}, so that it gets processed by {\ft accepts} and
stored in the database. The download function, before serving the file, checks in the database for the original filename and uses it in the content-disposition header.

\goodbreak\subsection{{\ft autodelete}}

\inxx{autodelete}

The {\ft SQLFORM}, upon deleting a record, does not delete the physical uploaded file(s) referenced by the record. The reason is that web2py does not know whether the same file is used/linked by other tables or used for other purpose. If you know it is safe to delete the actual file when the corresponding record is deleted, you can do the following:
\begin{lstlisting}
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('source','upload',autodelete=True))
\end{lstlisting}

The {\ft autodelete} attribute is {\ft False} by default. When set to {\ft True} is makes sure the file is deleted when the record is deleted.

\goodbreak\subsection{Links to referencing records}

Now consider the case of two tables linked by a reference field. For example:
\begin{lstlisting}
db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()))
db.define_table('dog',
    Field('owner', 'reference person'),
    Field('name', requires=IS_NOT_EMPTY()))
db.dog.owner.requires = IS_IN_DB(db,db.person.id,'%(name)s')
\end{lstlisting}

A person has dogs, and each dog belongs to an owner, which is a person. The dog owner is required to reference a valid {\ft db.person.id} by {\ft '\%(name)s'}.

Let's use the {\bf appadmin} interface for this application to add a
few persons and their dogs.

When editing an existing person, the {\bf appadmin} UPDATE form shows a link to a page that lists the dogs that belong to the person. This behavior can be replicated using the {\ft linkto} argument of the {\ft SQLFORM}. {\ft linkto} has to point to the URL of a new action that receives a query string from the {\ft SQLFORM} and lists the corresponding records.
Here is an example:
\begin{lstlisting}
def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   url = URL('download')
   link = URL('list_records', args='db')
   form = SQLFORM(db.person, record, deletable=True,
                  upload=url, linkto=link)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)
\end{lstlisting}

Here is the page:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6400.png}\end{center}


There is a link called "dog.owner". The name of this link can be changed via the {\ft labels} argument of the {\ft SQLFORM}, for example:
\begin{lstlisting}
labels = {'dog.owner':"This person's dogs"}
\end{lstlisting}

If you click on the link you get directed to:
\begin{lstlisting}
/test/default/list_records/dog?query=db.dog.owner%3D%3D5
\end{lstlisting}

"list\_records" is the specified action, with {\ft request.args(0)} set to the name of the referencing table and {\ft request.vars.query} set to the SQL query string.
The query string in the URL
contains the value "dog.owner=5" appropriately url-encoded
(web2py decodes this automatically when the URL is parsed).

You can easily implement a very general "list\_records" action as follows:
\begin{lstlisting}
def list_records():
    REGEX = re.compile('^(\w+)\.(\w+)\.(\w+)\=\=(\d+)$')
    match = REGEX.match(request.vars.query)
    if not match:
        redirect(URL('error'))
    table, field, id = match.group(2), match.group(3), match.group(4)
    records = db(db[table][field]==id).select()
    return dict(records=records)
\end{lstlisting}
\noindent with the associated "default/list\_records.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=records}}
\end{lstlisting}

When a set of records is returned by a select and serialized in a view, it is first converted into a SQLTABLE object (not the same as a Table) and then serialized into an HTML table, where each field corresponds to a table column.

\goodbreak\subsection{Pre-populating the form}

It is always possible to pre-populate a form using the syntax:
\begin{lstlisting}
form.vars.name = 'fieldvalue'
\end{lstlisting}

Statements like the one above must be inserted after the form declaration and before the form is accepted, whether or not the field ("name" in the example) is explicitly visualized in the form.

\goodbreak\subsection{Adding extra form elements to {\ft SQLFORM}}

Sometimes you may wish to add an extra element to your form after it has been created. For example, you may wish to add a checkbox which confirms the user agrees with the terms and conditions of your website:
\begin{lstlisting}
form = SQLFORM(db.yourtable)
my_extra_element = TR(LABEL('I agree to the terms and conditions'), \
                      INPUT(_name='agree',value=True,_type='checkbox'))
form[0].insert(-1,my_extra_element)
\end{lstlisting}

The variable {\ft my\_extra\_element} should be adapted to the formstyle. In this example, the default {\ft formstyle='table3cols'} has been assumed.

After submission, {\ft form.vars.agree} will contain the status of the checkbox, which could then be used in an {\ft onvalidation} function, for instance.

\goodbreak\subsection{{\ft SQLFORM} without database IO}

There are times when you want to generate a form from a database table using {\ft SQLFORM} and you want to validate a submitted form accordingly, but you do not want any automatic INSERT/UPDATE/DELETE in the database. This is the case, for example, when one of the fields needs to be computed from the value of other input fields. This is also the case when you need to perform additional validation on the inserted data that cannot be achieved via standard validators.

This can be done easily by breaking:
\begin{lstlisting}
form = SQLFORM(db.person)
if form.process().accepted:
    response.flash = 'record inserted'
\end{lstlisting}
\noindent into:
\begin{lstlisting}
form = SQLFORM(db.person)
if form.validate():
    ### deal with uploads explicitly
    form.vars.id = db.person.insert(**dict(form.vars))
    response.flash = 'record inserted'
\end{lstlisting}

The same can be done for UPDATE/DELETE forms by breaking:
\begin{lstlisting}
form = SQLFORM(db.person,record)
if form.process().accepted:
    response.flash = 'record updated'
\end{lstlisting}
\noindent into:
\begin{lstlisting}
form = SQLFORM(db.person,record)
if form.validate():
    if form.deleted:
        db(db.person.id==record.id).delete()
    else:
        record.update_record(**dict(form.vars))
    response.flash = 'record updated'
\end{lstlisting}

In the case of a table including an "upload"-type field ("fieldname"), both {\ft process(dbio=False)} and {\ft validate()} deal with the storage of the uploaded file as if {\ft process(dbio=True)}, the default behavior.

The name assigned by web2py to the uploaded file can be found in:
\begin{lstlisting}
form.vars.fieldname
\end{lstlisting}

\goodbreak\section{Other types of Forms}

\goodbreak\subsection{{\ft SQLFORM.factory}}

There are cases when you want to generate forms {\it as if} you had a database table but you do not want the database table. You simply want to take advantage of the {\ft SQLFORM} capability to generate a nice looking CSS-friendly form and perhaps perform file upload and renaming.

This can be done via a {\ft form\_factory}. Here is an example where you generate the form, perform validation, upload a file and store everything in the {\ft session} :
\begin{lstlisting}
def form_from_factory():
    form = SQLFORM.factory(
        Field('your_name', requires=IS_NOT_EMPTY()),
        Field('your_image', 'upload'))
    if form.process().accepted:
        response.flash = 'form accepted'
        session.your_name = form.vars.your_name
        session.your_image = form.vars.your_image
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)
\end{lstlisting}

Here is the "default/form\_from\_factory.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=form}}
\end{lstlisting}

You need to use an underscore instead of a space for field labels, or explicitly pass a dictionary of {\ft labels} to {\ft form\_factory}, as you would for a {\ft SQLFORM}. By default {\ft SQLFORM.factory} generates the form using html "id" attributes generated as if the form was generated from a table called "no\_table". To change this dummy table name, use the {\ft table\_name} attribute for the factory:
\begin{lstlisting}
form = SQLFORM.factory(...,table_name='other_dummy_name')
\end{lstlisting}

Changing the {\ft table\_name} is necessary if you need to place two factory generated forms in the same table and want to avoid CSS conflicts.

\goodbreak\subsection{One form for multiple tables}

It often happens that you have two tables (for example 'client' and
'address' which are linked together by a reference and you want to
create a single form that allows to insert info about one client and
its default address. Here is how:
\noindent model:
\begin{lstlisting}
db.define_table('client',
     Field('name'))
db.define_table('address',
    Field('client','reference client',
          writable=False,readable=False),
    Field('street'),Field('city'))
\end{lstlisting}
\noindent controller:
\begin{lstlisting}
def register():
    form=SQLFORM.factory(db.client,db.address)
    if form.process().accepted:
        id = db.client.insert(**db.client._filter_fields(form.vars))
        form.vars.client=id
        id = db.address.insert(**db.address._filter_fields(form.vars))
        response.flash='Thanks for filling the form'
    return dict(form=form)
\end{lstlisting}

Notice the SQLFORM.factory (it makes ONE form using public fields from
both tables and inherits their validators too).
On form accepts this does two inserts, some data in one table and some
data in the other.

\begin{quote}This only works when the tables don't have field names in common.\end{quote}
\goodbreak\subsection{Confirmation Forms}

\inxx{confirm}

Often you need a form with a confirmation choice. The form should be accepted if the choice is accepted and none otherwise. The form may have additional options that link other web pages. web2py provides a simple way to do this:

\begin{lstlisting}
form = FORM.confirm('Are you sure?')
if form.accepted: do_what_needs_to_be_done()
\end{lstlisting}

Notice that the confirm form does not need and must not call {\ft .accepts} or {\ft .process} because this is done internally. You can add buttons with links to the confirmation form in the form of a dictionary of {\ft \{'value':'link'\}}:

\begin{lstlisting}
form = FORM.confirm('Are you sure?',{'Back':URL('other_page')})
if form.accepted: do_what_needs_to_be_done()
\end{lstlisting}

\goodbreak\subsection{Form to edit a dictionary}

Imagine a system that stores configurations options in a dictionary,

\begin{lstlisting}
config = dict(color='black', language='English')
\end{lstlisting}
\noindent and you need a form to allow the visitor to modify this dictionary.
This can be done with:

\begin{lstlisting}
form = SQLFORM.dictform(config)
if form.process().accepted: config.update(form.vars)
\end{lstlisting}

The form will display one INPUT field for each item in the dictionary. It will use dictionary keys as INPUT names and labels and current values to infer types (string, int, double, date, datetime, boolean).

This works great but leave to you the logic of making the config dictionary persistent. For example you may want to store the {\ft config} in a session.

\begin{lstlisting}
session.config or dict(color='black', language='English')
form = SQLFORM.dictform(session.config)
if form.process().accepted:
    session.config.update(form.vars)
\end{lstlisting}

\goodbreak\section{CRUD}

\inxx{CRUD} \inxx{crud.create} \inxx{crud.update} \inxx{crud.select} \inxx{crud.search} \inxx{crud.tables} \inxx{crud.delete}

One of the recent additions to web2py is the Create/Read/Update/Delete (CRUD) API on top of SQLFORM.
CRUD creates an SQLFORM, but it simplifies the coding because it incorporates the creation of the form, the processing of the form, the notification, and the redirection, all in one single function.

The first thing to notice is that CRUD differs from the other web2py APIs we have used so far because it is not already exposed. It must be imported. It also must be linked to a specific database. For example:
\begin{lstlisting}
from gluon.tools import Crud
crud = Crud(db)
\end{lstlisting}

The {\ft crud} object defined above provides the following API:

\inxx{crud.tables} \inxx{crud.create} \inxx{crud.read} \inxx{crud.update} \inxx{crud.delete} \inxx{crud.select}.
\begin{itemize}
\item {\ft crud.tables()} returns a list of tables defined in the database.

\item {\ft crud.create(db.tablename)} returns a create form for table tablename.

\item {\ft crud.read(db.tablename, id)} returns a readonly form for tablename and record id.

\item {\ft crud.update(db.tablename, id)} returns an update form for tablename and record id.

\item {\ft crud.delete(db.tablename, id)} deletes the record.

\item {\ft crud.select(db.tablename, query)} returns a list of records selected from the table.

\item {\ft crud.search(db.tablename)} returns a tuple (form, records) where form is a search form and records is a list of records based on the submitted search form.

\item {\ft crud()} returns one of the above based on the {\ft request.args()}.
\end{itemize}

For example, the following action:
\begin{lstlisting}
def data(): return dict(form=crud())
\end{lstlisting}
\noindent would expose the following URLs:
\begin{lstlisting}[keywords={}]
http://.../[app]/[controller]/data/tables
http://.../[app]/[controller]/data/create/[tablename]
http://.../[app]/[controller]/data/read/[tablename]/[id]
http://.../[app]/[controller]/data/update/[tablename]/[id]
http://.../[app]/[controller]/data/delete/[tablename]/[id]
http://.../[app]/[controller]/data/select/[tablename]
http://.../[app]/[controller]/data/search/[tablename]
\end{lstlisting}

However, the following action:

\begin{lstlisting}
def create_tablename():
    return dict(form=crud.create(db.tablename))
\end{lstlisting}
\noindent would only expose the create method

\begin{lstlisting}[keywords={}]
http://.../[app]/[controller]/create_tablename
\end{lstlisting}

While the following action:

\begin{lstlisting}
def update_tablename():
    return dict(form=crud.update(db.tablename, request.args(0)))
\end{lstlisting}
\noindent would only expose the update method

\begin{lstlisting}[keywords={}]
http://.../[app]/[controller]/update_tablename/[id]
\end{lstlisting}
\noindent and so on.

The behavior of CRUD can be customized in two ways: by setting some attributes of the {\ft crud} object or by passing extra parameters to each of its methods.

\goodbreak\subsection{Settings}

Here is a complete list of current CRUD attributes, their default values, and meaning:

To enforce authentication on all crud forms:

\begin{lstlisting}
crud.settings.auth = auth
\end{lstlisting}
The use is explained in chapter 9.

To specify the controller that defines the {\ft data} function which returns the {\ft crud} object

\begin{lstlisting}
crud.settings.controller = 'default'
\end{lstlisting}

To specify the URL to redirect to after a successful "create" record:

\begin{lstlisting}
crud.settings.create_next = URL('index')
\end{lstlisting}

To specify the URL to redirect to after a successful "update" record:

\begin{lstlisting}
crud.settings.update_next = URL('index')
\end{lstlisting}

To specify the URL to redirect to after a successful "delete" record:

\begin{lstlisting}
crud.settings.delete_next = URL('index')
\end{lstlisting}

To specify the URL to be used for linking uploaded files:

\begin{lstlisting}
crud.settings.download_url = URL('download')
\end{lstlisting}

To specify extra functions to be executed after standard validation procedures for {\ft crud.create} forms:

\begin{lstlisting}
crud.settings.create_onvalidation = StorageList()
\end{lstlisting}

{\ft StorageList} is the same as a {\ft Storage} object, they are both defined in the file "gluon/storage.py", but it defaults to {\ft []} as opposed to {\ft None}. It allows the following syntax:

\begin{lstlisting}
crud.settings.create_onvalidation.mytablename.append(lambda form:....)
\end{lstlisting}

To specify extra functions to be executed after        standard validation procedures for {\ft crud.update} forms:

\begin{lstlisting}
crud.settings.update_onvalidation = StorageList()
\end{lstlisting}

To specify extra functions to be executed after completion of {\ft crud.create} forms:

\begin{lstlisting}
crud.settings.create_onaccept = StorageList()
\end{lstlisting}

To specify extra functions to be executed after completion of {\ft crud.update} forms:

\begin{lstlisting}
crud.settings.update_onaccept = StorageList()
\end{lstlisting}

To specify extra functions to be executed after completion of {\ft crud.update} if record is deleted:

\begin{lstlisting}
crud.settings.update_ondelete = StorageList()
\end{lstlisting}

To specify extra functions to be executed after completion of {\ft crud.delete}:

\begin{lstlisting}
crud.settings.delete_onaccept = StorageList()
\end{lstlisting}

To determine whether the "update" forms should have a "delete" button:

\begin{lstlisting}
crud.settings.update_deletable = True
\end{lstlisting}

To determine whether the "update" forms should show the id of the edited record:

\begin{lstlisting}
crud.settings.showid = False
\end{lstlisting}

To determine whether forms should keep the previously inserted values or reset to default after successful submission:

\begin{lstlisting}
crud.settings.keepvalues = False
\end{lstlisting}

Crud always detects whether a record being edited has been modified by a third party in the time between the time when the form is displayed and the time when it is submitted. This behavior is equivalent to
\begin{lstlisting}
form.process(detect_record_change=True)
\end{lstlisting}
\noindent and it is set in:

\begin{lstlisting}
crud.settings.detect_record_change = True
\end{lstlisting}
and it can be changed/disabled by setting the variable to {\ft False}.

You can change the form style by

\begin{lstlisting}
crud.settings.formstyle = 'table3cols' or 'table2cols' or 'divs' or 'ul'
\end{lstlisting}

You can set the separator in all crud forms:

\begin{lstlisting}
crud.settings.label_separator = ':'
\end{lstlisting}

You can add captcha to forms, using the same convention explained for auth, with:

\begin{lstlisting}
crud.settings.create_captcha = None
crud.settings.update_captcha = None
crud.settings.captcha = None
\end{lstlisting}

\goodbreak\subsection{Messages}

Here is a list of customizable messages:
\begin{lstlisting}
crud.messages.submit_button = 'Submit'
\end{lstlisting}
\noindent sets the text of the "submit" button for both create and update forms.
\begin{lstlisting}
crud.messages.delete_label = 'Check to delete:'
\end{lstlisting}
\noindent sets the label of the "delete" button in "update" forms.
\begin{lstlisting}
crud.messages.record_created = 'Record Created'
\end{lstlisting}
\noindent sets the flash message on successful record creation.
\begin{lstlisting}
crud.messages.record_updated = 'Record Updated'
\end{lstlisting}
\noindent sets the flash message on successful record update.
\begin{lstlisting}
crud.messages.record_deleted = 'Record Deleted'
\end{lstlisting}
\noindent sets the flash message on successful record deletion.
\begin{lstlisting}
crud.messages.update_log = 'Record %(id)s updated'
\end{lstlisting}
\noindent sets the log message on successful record update.
\begin{lstlisting}
crud.messages.create_log = 'Record %(id)s created'
\end{lstlisting}
\noindent sets the log message on successful record creation.
\begin{lstlisting}
crud.messages.read_log = 'Record %(id)s read'
\end{lstlisting}
\noindent sets the log message on successful record read access.
\begin{lstlisting}
crud.messages.delete_log = 'Record %(id)s deleted'
\end{lstlisting}
\noindent sets the log message on successful record deletion.

\begin{quote}Notice that {\ft crud.messages} belongs to the class {\ft gluon.storage.Message} which is similar to {\ft gluon.storage.Storage} but it automatically translates its values, without need for the {\ft T} operator.\end{quote}
Log messages are used if and only if CRUD is connected to Auth as discussed in Chapter 9. The events are logged in the Auth table "auth\_events".

\goodbreak\subsection{Methods}

The behavior of CRUD methods can also be customized on a per call basis. Here are their signatures:
\begin{lstlisting}
crud.tables()
crud.create(table, next, onvalidation, onaccept, log, message)
crud.read(table, record)
crud.update(table, record, next, onvalidation, onaccept, ondelete, log, message, deletable)
crud.delete(table, record_id, next, message)
crud.select(table, query, fields, orderby, limitby, headers, **attr)
crud.search(table, query, queries, query_labels, fields, field_labels, zero, showall, chkall)
\end{lstlisting}
\begin{itemize}
\item {\ft table} is a DAL table or a tablename the method should act on.

\item {\ft record} and {\ft record\_id} are the id of the record the method should act on.

\item {\ft next} is the URL to redirect to after success. If the URL contains the substring "[id]" this will be replaced by the id of the record currently created/updated.

\item {\ft onvalidation} has the same function as SQLFORM(..., onvalidation)

\item {\ft onaccept} is a function to be called after the form submission is accepted and acted upon, but before redirection.

\item {\ft log} is the log message. Log messages in CRUD see variables in the {\ft form.vars} dictionary such as "\%(id)s".

\item {\ft message} is the flash message upon form acceptance.

\item {\ft ondelete} is called in place of {\ft onaccept} when a record is deleted via an "update" form.

\item {\ft deletable} determines whether the "update" form should have a delete option.

\item {\ft query} is the query to be used to select records.

\item {\ft fields} is a list of fields to be selected.

\item {\ft orderby} determines the order in which records should be selected (see Chapter 6).

\item {\ft limitby} determines the range of selected records that should be displayed (see Chapter 6).

\item {\ft headers} is a dictionary with the table header names.

\item {\ft queries} a list like {\ft ['equals', 'not equal', 'contains']} containing the allowed methods in the search form.

\item {\ft query\_labels} a dictionary like {\ft query\_labels=dict(equals='Equals')} giving names to search methods.

\item {\ft fields} a list of fields to be listed in the search widget.

\item {\ft field\_labels} a dictionary mapping field names into labels.

\item {\ft zero} defaults to "choose one" is used as default option for the drop-down in the search widget.

\item {\ft showall} set it to True if you want rows returned as per the query in the first call (added after 1.98.2).

\item {\ft chkall} set it to True to turn on all the checkboxes in the search form (added after 1.98.2).
\end{itemize}

Here is an example of usage in a single controller function:
\begin{lstlisting}
## assuming db.define_table('person', Field('name'))
def people():
    form = crud.create(db.person, next=URL('index'),
           message=T("record created"))
    persons = crud.select(db.person, fields=['name'],
           headers={'person.name': 'Name'})
    return dict(form=form, persons=persons)
\end{lstlisting}

Here is another very generic controller function that lets you search, create and edit any records from any table where the tablename is passed request.args(0):
\begin{lstlisting}
def manage():
    table=db[request.args(0)]
    form = crud.update(table,request.args(1))
    table.id.represent = lambda id, row: \
       A('edit:',id,_href=URL(args=(request.args(0),id)))
    search, rows = crud.search(table)
    return dict(form=form,search=search,rows=rows)
\end{lstlisting}

Notice the line {\ft table.id.represent=...} that tells web2py to change the representation of the id field and display a link instead to the page itself and passes the id as request.args(1) which turns the create page into an update page.

\goodbreak\subsection{Record versioning}

Both SQLFORM and CRUD provides a utility to version database records:

If you have a table (db.mytable) that needs full revision history you can just do:
\begin{lstlisting}
form = SQLFORM(db.mytable, myrecord).process(onsuccess=auth.archive)
\end{lstlisting}

\begin{lstlisting}
form = crud.update(db.mytable, myrecord, onaccept=auth.archive)
\end{lstlisting}

{\ft auth.archive} defines a new table called {\bf db.mytable\_archive} (the name is derived from the name of the table to which it refers) and on updating, it stores a copy of the record (as it was before the update) in the created archive table, including a reference to the current record.

Because the record is actually updated (only its previous state is archived), references are never broken.

This is all done under the hood.  Should you wish to access the archive table you should define it in a model:
\begin{lstlisting}
db.define_table('mytable_archive',
   Field('current_record', 'reference mytable'),
   db.mytable)
\end{lstlisting}

Notice the table extends {\ft db.mytable} (including all its fields), and adds  a reference to the {\ft current\_record}.

{\ft auth.archive} does not timestamp the stored record unless your original table has timestamp fields, for example:

\begin{lstlisting}
db.define_table('mytable',
    Field('created_on', 'datetime',
          default=request.now, update=request.now, writable=False),
    Field('created_by', 'reference auth_user',
          default=auth.user_id, update=auth.user_id, writable=False),
\end{lstlisting}

There is nothing special about these fields and you may give them any name you like. They are filled before the record is archived and are archived with each copy of the record.  The archive table name and/or reference field name can be changed like this:

\begin{lstlisting}
db.define_table('myhistory',
    Field('parent_record', 'reference mytable'),
    db.mytable)
## ...
form = SQLFORM(db.mytable,myrecord)
form.process(onsuccess = lambda form:auth.archive(form,
             archive_table=db.myhistory,
             current_record='parent_record'))
\end{lstlisting}

\goodbreak\section{Custom forms}

If a form is created with SQLFORM, SQLFORM.factory or CRUD, there are multiple ways it can be embedded in a view allowing multiple degrees of customization. Consider for example the following model:
\begin{lstlisting}
db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('source', 'upload'))
\end{lstlisting}
\noindent and upload action
\begin{lstlisting}
def upload_image():
    return dict(form=SQLFORM(db.image).process())
\end{lstlisting}

The simplest way to embed the form in the view for {\ft upload\_image} is
\begin{lstlisting}[keywords={}]
{{=form}}
\end{lstlisting}

This results in a standard table layout. If you wish to use a different layout, you can break the form into components
\begin{lstlisting}[keywords={}]
{{=form.custom.begin}}
Image name: <div>{{=form.custom.widget.name}}</div>
Image file: <div>{{=form.custom.widget.source}}</div>
Click here to upload: {{=form.custom.submit}}
{{=form.custom.end}}
\end{lstlisting}
\noindent where {\ft form.custom.widget[fieldname]} gets serialized into the proper widget for the field. If the form is submitted and it contains errors, they are appended below the widgets, as usual.

The above sample form is show in the image below.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6500.png}\end{center}


A similar result could have been obtained without using a custom form:

\begin{lstlisting}
SQLFORM(...,formstyle='table2cols')
\end{lstlisting}
\noindent or in case of CRUD forms with the following parameter:

\begin{lstlisting}
crud.settings.formstyle='table2cols'
\end{lstlisting}

Other possible {\ft formstyle}s are "table3cols" (the default), "divs" and "ul".

If you do not wish to use the widgets serialized by web2py, you can replace them with HTML. There are some variables that will be useful for this:
\begin{itemize}
\item {\ft form.custom.label[fieldname]} contains the label for the field.

\item {\ft form.custom.comment[fieldname]} contains the comment for the field.

\item {\ft form.custom.dspval[fieldname]} form-type and field-type dependent display representation of the field.

\item {\ft form.custom.inpval[fieldname]} form-type and field-type dependent values to be used in field code.
\end{itemize}

If you form has {\ft deletable=True} you should also insert

\begin{lstlisting}[keywords={}]
{{=form.custom.delete}}
\end{lstlisting}
\noindent to display the delete checkbox.

It is important to follow the conventions described below.

\goodbreak\subsection{CSS conventions}

Tags in forms generated by SQLFORM, SQLFORM.factory and CRUD follow a strict CSS naming convention that can be used to further customize the forms.

Given a table "mytable", and a field "myfield" of type "string", it is rendered by default by a
\begin{lstlisting}
SQLFORM.widgets.string.widget
\end{lstlisting}
\noindent that looks like this:
\begin{lstlisting}[keywords={}]
<input type="text" name="myfield" id="mytable_myfield"
       class="string" />
\end{lstlisting}

Notice that:
\begin{itemize}
\item the class of the INPUT tag is the same as the type of the field. This is very important for the jQuery code in "web2py\_ajax.html" to work. It makes sure that you can only have numbers in "integer" and "double" fields, and that "time", "date" and "datetime" fields display the popup calendar/datepicker.

\item the id is the name of the class plus the name of the field, joined by one underscore. This allows you to uniquely refer to the field via, for example, {\ft jQuery('\#mytable\_myfield')} and manipulate the stylesheet of the field or bind actions associated to the field events (focus, blur, keyup, etc.).

\item the name is, as you would expect, the field name.
\end{itemize}

\goodbreak\subsection{Hide errors}

\inxx{hideerror}

Occasionally, you may want to disable the automatic error placement and display form error messages in some place other than the default. That can be done easily.

\begin{itemize}
\item In the case of FORM or SQLFORM, pass {\ft hideerror=True} to the {\ft accepts} method.

\item In the case of CRUD, set {\ft crud.settings.hideerror=True}
\end{itemize}

You may also want to modify the views to display the error (since they are no longer displayed automatically).

Here is an example where the errors are displayed above the form and not in the form.
\begin{lstlisting}[keywords={}]
{{if form.errors:}}
  Your submitted form contains the following errors:
  <ul>
  {{for fieldname in form.errors:}}
    <li>{{=fieldname}} error: {{=form.errors[fieldname]}}</li>
  {{pass}}
  </ul>
  {{form.errors.clear()}}
{{pass}}
{{=form}}
\end{lstlisting}

The errors will displayed as in the image shown below.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6600.png}\end{center}


This mechanism also works for custom forms.

\goodbreak\section{Validators}

\inxx{validators}

Validators are classes used to validate input fields (including forms generated from database tables).

Here is an example of using a validator with a {\ft FORM}:
\begin{lstlisting}
INPUT(_name='a', requires=IS_INT_IN_RANGE(0, 10))
\end{lstlisting}

Here is an example of how to require a validator for a table field:
\begin{lstlisting}
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_EMPTY()
\end{lstlisting}

Validators are always assigned using the {\ft requires} attribute of a field. A field can have a single validator or multiple validators. Multiple validators are made part of a list:
\begin{lstlisting}
db.person.name.requires = [IS_NOT_EMPTY(),
                           IS_NOT_IN_DB(db, 'person.name')]
\end{lstlisting}

Normally validators are called automatically by the function {\ft accepts} and {\ft process} of a {\ft FORM} or other HTML helper object that contains a form. They are called in the order in which they are listed.

One can also call validators explicitly for a field:

\begin{lstlisting}
db.person.name.validate(value)
\end{lstlisting}
\noindent which returns a tuple {\ft (value,error)} and {\ft error} is {\ft None} if no the value validates.

Built-in validators have constructors that take an optional argument:

\begin{lstlisting}
IS_NOT_EMPTY(error_message='cannot be empty')
\end{lstlisting}

{\ft error\_message} allows you to override the default error message for any validator.

Here is an example of a validator on a database table:
\begin{lstlisting}
db.person.name.requires = IS_NOT_EMPTY(error_message='fill this!')
\end{lstlisting}
\noindent where we have used the translation operator {\ft T} to allow for internationalization. Notice that default error messages are not translated.

Mind that the only validators that can be used with {\ft list:} type fields are:

\begin{itemize}
\item {\ft IS\_IN\_DB(...,multiple=True)}

\item {\ft IS\_IN\_SET(...,multiple=True)}

\item {\ft IS\_NOT\_EMPTY()}

\item {\ft IS\_LIST\_OF(...)}
\end{itemize}

The latter can be used to apply any validator to the individual items in the list.

\goodbreak\subsection{Validators}

{\bf {\ft IS\_ALPHANUMERIC}}

\inxx{IS\_ALPHANUMERIC}

This validator checks that a field value contains only characters in the ranges a-z, A-Z, or 0-9.
\begin{lstlisting}
requires = IS_ALPHANUMERIC(error_message='must be alphanumeric!')
\end{lstlisting}

{\bf {\ft IS\_DATE}}

\inxx{IS\_DATE}

This validator checks that a field value contains a valid date in the specified format. It is good practice to specify the format using the translation operator, in order to support different formats in different locales.
\begin{lstlisting}
requires = IS_DATE(format=T('%Y-%m-%d'),
                   error_message='must be YYYY-MM-DD!')
\end{lstlisting}

For the full description on \% directives look under the IS\_DATETIME validator.

{\bf {\ft IS\_DATE\_IN\_RANGE}}

\inxx{IS\_DATE\_IN\_RANGE}

Works very much like the previous validator but allows to specify a range:
\begin{lstlisting}
requires = IS_DATE_IN_RANGE(format=T('%Y-%m-%d'),
                   minimum=datetime.date(2008,1,1),
                   maximum=datetime.date(2009,12,31),
                   error_message='must be YYYY-MM-DD!')
\end{lstlisting}

For the full description on \% directives look under the IS\_DATETIME validator.

{\bf {\ft IS\_DATETIME}}

\inxx{IS\_DATETIME}

This validator checks that a field value contains a valid datetime in the specified format. It is good practice to specify the format using the translation operator, in order to support different formats in different locales.
\begin{lstlisting}
requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       error_message='must be YYYY-MM-DD HH:MM:SS!')
\end{lstlisting}

The following symbols can be used for the format string (this shows the symbol and an example string):
\begin{lstlisting}
%Y  '1963'
%y  '63'
%d  '28'
%m  '08'
%b  'Aug'
%b  'August'
%H  '14'
%I  '02'
%p  'PM'
%M  '30'
%S  '59'
\end{lstlisting}

{\bf {\ft IS\_DATETIME\_IN\_RANGE}}

\inxx{IS\_DATETIME\_IN\_RANGE}

Works very much like the previous validator but allows to specify a range:
\begin{lstlisting}
requires = IS_DATETIME_IN_RANGE(format=T('%Y-%m-%d %H:%M:%S'),
                       minimum=datetime.datetime(2008,1,1,10,30),
                       maximum=datetime.datetime(2009,12,31,11,45),
                       error_message='must be YYYY-MM-DD HH:MM::SS!')
\end{lstlisting}

For the full description on \% directives look under the IS\_DATETIME validator.

{\bf {\ft IS\_DECIMAL\_IN\_RANGE}}

\inxx{IS\_DECIMAL\_IN\_RANGE}

\begin{lstlisting}
INPUT(_type='text', _name='name', requires=IS_DECIMAL_IN_RANGE(0, 10, dot="."))
\end{lstlisting}

It converts the input into a Python Decimal or generates an error if
the decimal does not fall within the specified inclusive range.
The comparison is made with Python Decimal arithmetic.

The minimum and maximum limits can be None, meaning no lower or upper limit,
respectively.

The {\ft dot} argument is optional and allows you to internationalize the symbol used to separate the decimals.

{\bf {\ft IS\_EMAIL}}

\inxx{IS\_EMAIL}

It checks that the field value looks like an email address. It does not try to send email to confirm.
\begin{lstlisting}
requires = IS_EMAIL(error_message='invalid email!')
\end{lstlisting}

{\bf {\ft IS\_EQUAL\_TO}}

\inxx{IS\_EQUEL\_TO}

Checks whether the validated value is equal to a given value (which can be a variable):
\begin{lstlisting}
requires = IS_EQUAL_TO(request.vars.password,
                       error_message='passwords do not match')
\end{lstlisting}

{\bf {\ft IS\_EXPR}}

\inxx{IS\_EXPR}

Its first argument is a string containing a logical expression in terms of a variable value. It validates a field value if the expression evaluates to {\ft True}. For example:
\begin{lstlisting}
requires = IS_EXPR('int(value)%3==0',
                   error_message='not divisible by 3')
\end{lstlisting}

One should first check that the value is an integer so that an exception will not occur.
\begin{lstlisting}
requires = [IS_INT_IN_RANGE(0, 100), IS_EXPR('value%3==0')]
\end{lstlisting}

{\bf {\ft IS\_FLOAT\_IN\_RANGE}}

\inxx{IS\_FLOAT\_IN\_RANGE}

Checks that the field value is a floating point number within a definite range, {\ft 0 <= value <= 100} in the following example:
\begin{lstlisting}
requires = IS_FLOAT_IN_RANGE(0, 100, dot=".",
         error_message='too small or too large!')
\end{lstlisting}

The {\ft dot} argument is optional and allows you to internationalize the symbol used to separate the decimals.

{\bf {\ft IS\_INT\_IN\_RANGE}}

\inxx{IS\_INT\_IN\_RANGE}

Checks that the field value is an integer number within a definite range,
{\ft 0 <= value < 100} in the following example:

\begin{lstlisting}
requires = IS_INT_IN_RANGE(0, 100,
         error_message='too small or too large!')
\end{lstlisting}

{\bf {\ft IS\_IN\_SET}}

\inxx{IS\_IN\_SET}
\inxx{multiple}

Checks that the field values are in a set:
\begin{lstlisting}
requires = IS_IN_SET(['a', 'b', 'c'],zero=T('choose one'),
         error_message='must be a or b or c')
\end{lstlisting}

The zero argument is optional and it determines the text of the option selected by default, an option which is not accepted by the {\ft IS\_IN\_SET} validator itself. If you do not want a "choose one" option, set {\ft zero=None}.

The {\ft zero} option was introduced in revision (1.67.1). It did not break backward compatibility in the sense that it did not break applications but it did change their behavior since, before, there was no {\ft zero} option.

The elements of the set must always be strings unless this validator is preceded by {\ft IS\_INT\_IN\_RANGE} (which converts the value to int) or  {\ft IS\_FLOAT\_IN\_RANGE} (which converts the value to float). For example:
\begin{lstlisting}
requires = [IS_INT_IN_RANGE(0, 8), IS_IN_SET([2, 3, 5, 7],
          error_message='must be prime and less than 10')]
\end{lstlisting}

You may also use a dictionary or a list of tuples to make the drop down list more descriptive:
\begin{lstlisting}
#### Dictionary example:
requires = IS_IN_SET({'A':'Apple','B':'Banana','C':'Cherry'},zero=None)
#### List of tuples example:
requires = IS_IN_SET([('A','Apple'),('B','Banana'),('C','Cherry')])
\end{lstlisting}

{\bf {\ft IS\_IN\_SET} and Tagging}

The {\ft IS\_IN\_SET} validator has an optional attribute {\ft multiple=False}. If set to True, multiple values can be stored in one field. The field should be of type {\ft list:integer} or {\ft list:string}. {\ft multiple} references are handled automatically in create and update forms, but they are transparent to the DAL. We strongly suggest using the jQuery multiselect plugin to render multiple fields.

\begin{quote}Note that when {\ft multiple=True}, {\ft IS\_IN\_SET} will accept {\ft zero} or more values, i.e. it will accept the field when nothing has been selected. {\ft multiple} can also be a tuple of the form {\ft (a,b)} where {\ft a} and {\ft b} are the minimum and (exclusive) maximum number of items that can be selected respectively.\end{quote}
{\bf {\ft IS\_LENGTH}}

\inxx{IS\_LENGTH}

Checks if length of field's value fits between given boundaries. Works
for both text and file inputs.

Its arguments are:
\begin{itemize}
\item maxsize: the maximum allowed length / size (has default = 255)

\item minsize: the minimum allowed length / size
\end{itemize}

Examples:
Check if text string is shorter than 33 characters:
\begin{lstlisting}
INPUT(_type='text', _name='name', requires=IS_LENGTH(32))
\end{lstlisting}

Check if password string is longer than 5 characters:
\begin{lstlisting}
INPUT(_type='password', _name='name', requires=IS_LENGTH(minsize=6))
\end{lstlisting}

Check if uploaded file has size between 1KB and 1MB:
\begin{lstlisting}
INPUT(_type='file', _name='name', requires=IS_LENGTH(1048576, 1024))
\end{lstlisting}

For all field types except for files, it checks the length of the value. In the case of files, the value is a {\ft cookie.FieldStorage}, so it validates the length of the data in the file, which is the behavior one might intuitively expect.

{\bf {\ft IS\_LIST\_OF}}

\inxx{IS\_LIST\_OF}

This is not properly a validator. Its intended use is to allow validations of fields that return multiple values. It is used in those rare cases when a form contains multiple fields with the same name or a multiple selection box. Its only argument is another validator, and all it does is to apply the other validator to each element of the list. For example, the following expression checks that every item in a list is an integer in the range 0-10:
\begin{lstlisting}
requires = IS_LIST_OF(IS_INT_IN_RANGE(0, 10))
\end{lstlisting}

It never returns an error and does not contain an error message. The inner validator controls the error generation.

{\bf {\ft IS\_LOWER}}

\inxx{IS\_LOWER}

This validator never returns an error. It just converts the value to lower case.
\begin{lstlisting}
requires = IS_LOWER()
\end{lstlisting}

{\bf {\ft IS\_MATCH}}

\inxx{IS\_MATCH}

This validator matches the value against a regular expression and returns an error if it does not match.
Here is an example of usage to validate a US zip code:
\begin{lstlisting}
requires = IS_MATCH('^\d{5}(-\d{4})?$',
         error_message='not a zip code')
\end{lstlisting}

Here is an example of usage to validate an IPv4 address (note: the IS\_IPV4 validator is more appropriate for this purpose):
\begin{lstlisting}
requires = IS_MATCH('^\d{1,3}(\.\d{1,3}){3}$',
         error_message='not an IP address')
\end{lstlisting}

Here is an example of usage to validate a US phone number:
\begin{lstlisting}
requires = IS_MATCH('^1?((-)\d{3}-?|\(\d{3}\))\d{3}-?\d{4}$',
         error_message='not a phone number')
\end{lstlisting}

For more information on Python regular expressions, refer to the official Python documentation.

{\ft IS\_MATCH} takes an optional argument {\ft strict} which defaults to {\ft False}. When set to {\ft True} it only matches the beginning of the string:

\begin{lstlisting}
>>> IS_MATCH('a')('ba')
('ba', <lazyT 'invalid expression'>) # no pass
>>> IS_MATCH('a',strict=False)('ab')
('a', None)                          # pass!
\end{lstlisting}

{\ft IS\_MATCH} takes an other optional argument {\ft search} which defaults to {\ft False}. When set to {\ft True}, it uses regex method {\ft search} instead of method {\ft match} to validate the string.

{\ft IS\_MATCH('...', extract=True)} filters and extract only the first matching
substring rather than the original value.

{\bf {\ft IS\_NOT\_EMPTY}}

\inxx{IS\_NOT\_EMPTY}

This validator checks that the content of the field value is not an empty string.
\begin{lstlisting}
requires = IS_NOT_EMPTY(error_message='cannot be empty!')
\end{lstlisting}

{\bf {\ft IS\_TIME}}

\inxx{IS\_TIME}

This validator checks that a field value contains a valid time in the specified format.
\begin{lstlisting}
requires = IS_TIME(error_message='must be HH:MM:SS!')
\end{lstlisting}

{\bf {\ft IS\_URL}}

\inxx{IS\_URL}

Rejects a URL string if any of the following is true:
\begin{itemize}
\item The string is empty or None

\item The string uses characters that are not allowed in a URL

\item The string breaks any of the HTTP syntactic rules

\item The URL scheme specified (if one is specified) is not 'http' or 'https'

\item The top-level domain (if a host name is specified) does not exist
\end{itemize}

(These rules are based on RFC 2616~\cite{RFC2616} )

This function only checks the URL's syntax. It does not check that the URL points to a real document,
for example, or that it otherwise makes semantic sense. This function does automatically prepend
'http://' in front of a URL in the case of an abbreviated URL (e.g. 'google.ca').

If the parameter mode='generic' is used, then this function's behavior changes. It then rejects a URL string if any of the following is true:
\begin{itemize}
\item The string is empty or None

\item The string uses characters that are not allowed in a URL

\item The URL scheme specified (if one is specified) is not valid
\end{itemize}

(These rules are based on RFC 2396~\cite{RFC2396} )

The list of allowed schemes is customizable with the allowed\_schemes parameter. If you exclude None from
the list, then abbreviated URLs (lacking a scheme such as 'http') will be rejected.

The default prepended scheme is customizable with the prepend\_scheme parameter. If you set prepend\_scheme
to None, then prepending will be disabled. URLs that require prepending to parse will still be accepted,
but the return value will not be modified.

IS\_URL is compatible with the Internationalized Domain Name (IDN) standard specified in RFC 3490~\cite{RFC3490} ). As a result, URLs can be regular strings or unicode strings.
If the URL's domain component (e.g. google.ca) contains non-US-ASCII letters, then the domain will
be converted into Punycode (defined in RFC 3492~\cite{RFC3492} ). IS\_URL goes a
bit beyond the standards, and allows non-US-ASCII characters to be present in the path
and query components of the URL as well. These non-US-ASCII characters will be encoded.
For example, space will be encoded as'\%20'. The unicode character with hex code 0x4e86
will become '\%4e\%86'.

Examples:
\begin{lstlisting}
requires = IS_URL())
requires = IS_URL(mode='generic')
requires = IS_URL(allowed_schemes=['https'])
requires = IS_URL(prepend_scheme='https')
requires = IS_URL(mode='generic',
                  allowed_schemes=['ftps', 'https'],
                  prepend_scheme='https')
\end{lstlisting}

{\bf {\ft IS\_SLUG}}

\inxx{IS\_SLUG}
\begin{lstlisting}
requires = IS_SLUG(maxlen=80, check=False, error_message='must be slug')
\end{lstlisting}

If {\ft check} is set to {\ft True} it check whether the validated value is a slug (allowing only alphanumeric characters and non-repeated dashes).

If {\ft check} is set to {\ft False} (default) it converts the input value to a slug.

{\bf {\ft IS\_STRONG}}

\inxx{IS\_STRONG}

Enforces complexity requirements on a field (usually a password field)

Example:
\begin{lstlisting}
requires = IS_STRONG(min=10, special=2, upper=2)
\end{lstlisting}
\noindent where
\begin{itemize}
\item min is minimum length of the value

\item special is the minimum number of required special characters special characters are any of the following {\ft !@\#\$\%\^\&*()\{\}[]-+}

\item upper is the minimum number of upper case characters
\end{itemize}

{\bf {\ft IS\_IMAGE}}

\inxx{IS\_IMAGE}

This validator checks if a file uploaded through the file input was saved in one of the selected image formats and has dimensions (width and height) within given limits.

It does not check for maximum file size (use IS\_LENGTH for that). It returns
a validation failure if no data was uploaded. It supports the file formats BMP, GIF, JPEG, PNG, and it does not require the Python Imaging Library.

Code parts taken from ref.~\cite{source1}

It takes the following arguments:
\begin{itemize}
\item extensions: iterable containing allowed image file extensions in lowercase

\item maxsize: iterable containing maximum width and height of the image

\item minsize: iterable containing minimum width and height of the image
\end{itemize}

Use (-1, -1) as minsize to bypass the image-size check.

Here are some Examples:
\begin{itemize}
\item Check if uploaded file is in any of supported image formats:
\end{itemize}
\begin{lstlisting}
requires = IS_IMAGE()
\end{lstlisting}
\begin{itemize}
\item Check if uploaded file is either JPEG or PNG:
\end{itemize}
\begin{lstlisting}
requires = IS_IMAGE(extensions=('jpeg', 'png'))
\end{lstlisting}

\begin{itemize}
\item Check if uploaded file is PNG with maximum size of 200x200 pixels:
\end{itemize}
\begin{lstlisting}
requires = IS_IMAGE(extensions=('png'), maxsize=(200, 200))
\end{lstlisting}

\begin{itemize}
\item Note: on displaying an edit form for a table including {\ft requires = IS\_IMAGE()}, a {\ft delete} checkbox will NOT appear because to delete the file would cause the validation to fail. To display the {\ft delete} checkbox use this validation:
\end{itemize}
\begin{lstlisting}
requires = IS_EMPTY_OR(IS_IMAGE())
\end{lstlisting}

{\bf {\ft IS\_UPLOAD\_FILENAME}}

\inxx{IS\_UPLOAD\_FILENAME}

This validator checks if the name and extension of a file uploaded through the file input matches the given criteria.

It does not ensure the file type in any way. Returns validation failure
if no data was uploaded.

Its arguments are:
\begin{itemize}
\item filename: filename (before dot) regex.

\item extension: extension (after dot) regex.

\item lastdot: which dot should be used as a filename / extension separator: {\ft True} indicates last dot (e.g., "file.tar.gz" will be broken in "file.tar" + "gz") while {\ft False} means first dot (e.g., "file.tar.gz" will be broken into "file" + "tar.gz").

\item case: 0 means keep the case; 1 means transform the string into lowercase (default); 2 means transform the string into uppercase.
\end{itemize}

If there is no dot present, extension checks will be done against an empty
string and filename checks will be done against the whole value.

Examples:

Check if file has a pdf extension (case insensitive):
\begin{lstlisting}
requires = IS_UPLOAD_FILENAME(extension='pdf')
\end{lstlisting}

Check if file has a tar.gz extension and name starting with backup:
\begin{lstlisting}
requires = IS_UPLOAD_FILENAME(filename='backup.*', extension='tar.gz', lastdot=False)
\end{lstlisting}

Check if file has no extension and name matching README (case sensitive):
\begin{lstlisting}
requires = IS_UPLOAD_FILENAME(filename='^README$', extension='^$', case=0)
\end{lstlisting}

{\bf {\ft IS\_IPV4}}

\inxx{IS\_IPV4}

This validator checks if a field's value is an IP version 4 address in decimal form. Can
be set to force addresses from a certain range.

IPv4 regex taken from ref.~\cite{regexlib}
Its arguments are:
\begin{itemize}
\item {\ft minip} lowest allowed address; accepts: {\bf str}, e.g., 192.168.0.1; {\bf iterable of numbers}, e.g., [192, 168, 0, 1]; {\bf int}, e.g., 3232235521

\item {\ft maxip} highest allowed address; same as above
\end{itemize}

All three example values are equal, since addresses are converted to
integers for inclusion check with following function:
\begin{lstlisting}
number = 16777216 * IP[0] + 65536 * IP[1] + 256 * IP[2] + IP[3]
\end{lstlisting}

Examples:

Check for valid IPv4 address:
\begin{lstlisting}
requires = IS_IPV4()
\end{lstlisting}

Check for valid private network IPv4 address:
\begin{lstlisting}
requires = IS_IPV4(minip='192.168.0.1', maxip='192.168.255.255')
\end{lstlisting}

{\bf {\ft IS\_UPPER}}

\inxx{IS\_UPPER}

This validator never returns an error. It converts the value to upper case.
\begin{lstlisting}
requires = IS_UPPER()
\end{lstlisting}

{\bf {\ft IS\_NULL\_OR}}

\inxx{IS\_NULL\_OR}

Deprecated, an alias for {\ft IS\_EMPTY\_OR} described below.

{\bf {\ft IS\_EMPTY\_OR}}

\inxx{IS\_EMPTY\_OR}

Sometimes you need to allow empty values on a field along with other requirements. For example a field may be a date but it can also be empty.
The {\ft IS\_EMPTY\_OR} validator allows this:
\begin{lstlisting}
requires = IS_EMPTY_OR(IS_DATE())
\end{lstlisting}

{\bf {\ft CLEANUP}}

\inxx{CLEANUP}

This is a filter. It never fails. It just removes all characters whose decimal ASCII codes are not in the list [10, 13, 32-127].
\begin{lstlisting}
requires = CLEANUP()
\end{lstlisting}

{\bf {\ft CRYPT}}

\inxx{CRYPT}

This is also a filter. It performs a secure hash on the input and it is used to prevent passwords from being passed in the clear to the database.
\begin{lstlisting}
requires = CRYPT()
\end{lstlisting}

By default, CRYPT uses 1000 iterations of the pbkdf2 algorithm combined with SHA512 to produce a 20-byte-long hash. Older versions of web2py used "md5" or HMAC+SHA512 depending on whether a key was was specified or not.

If a key is specified, CRYPT uses the HMAC algorithm. The key may contain a prefix that determines the algorithm to use with HMAC, for example SHA512:

\begin{lstlisting}
requires = CRYPT(key='sha512:thisisthekey')
\end{lstlisting}

This is the recommended syntax. The key must be a unique string associated with the database used. The key can never be changed. If you lose the key, the previously hashed values become useless.

By default, CRYPT uses random salt, such that each result is different. To use a constant salt value, specify its value:

\begin{lstlisting}
requires = CRYPT(salt='mysaltvalue')
\end{lstlisting}

Or, to use no salt:

\begin{lstlisting}
requires = CRYPT(salt=False)
\end{lstlisting}

The CRYPT validator hashes its input, and this makes it somewhat special. If you need to validate a password field before it is hashed, you can use CRYPT in a list of validators, but must make sure it is the last of the list, so that it is called last. For example:

\begin{lstlisting}
requires = [IS_STRONG(),CRYPT(key='sha512:thisisthekey')]
\end{lstlisting}

{\ft CRYPT} also takes a {\ft min\_length} argument, which defaults to zero.

The resulting hash takes the form {\ft alg\$salt\$hash}, where {\ft alg} is the hash algorithm used, {\ft salt} is the salt string (which can be empty), and {\ft hash} is the algorithm's output. Consequently, the hash is self-identifying, allowing, for example, the algorithm to be changed without invalidating previous hashes. The key, however, must remain the same.

\goodbreak\subsection{Database validators}

{\bf {\ft IS\_NOT\_IN\_DB}}

\inxx{IS\_NOT\_IN\_DB}

Consider the following example:
\begin{lstlisting}
db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
\end{lstlisting}

It requires that when you insert a new person, his/her name is not already in the database, {\ft db}, in the field {\ft person.name}. As with all other validators this requirement is enforced at the form processing level, not at the database level. This means that there is a small probability that, if two visitors try to concurrently insert records with the same person.name, this results in a race condition and both records are accepted. It is therefore safer to also inform the database that this field should have a unique value:
\begin{lstlisting}
db.define_table('person', Field('name', unique=True))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')
\end{lstlisting}

Now if a race condition occurs, the database raises an OperationalError and one of the two inserts is rejected.

The first argument of {\ft IS\_NOT\_IN\_DB} can be a database connection or a Set. In the latter case, you would be checking only the set defined by the Set.

The following code, for example, does not allow registration of two persons with the same name within 10 days of each other:
\begin{lstlisting}
import datetime
now = datetime.datetime.today()
db.define_table('person',
    Field('name'),
    Field('registration_stamp', 'datetime', default=now))
recent = db(db.person.registration_stamp>now-datetime.timedelta(10))
db.person.name.requires = IS_NOT_IN_DB(recent, 'person.name')
\end{lstlisting}

{\bf {\ft IS\_IN\_DB}}

\inxx{IS\_IN\_DB}

Consider the following tables and requirement:

\begin{lstlisting}
db.define_table('person', Field('name', unique=True))
db.define_table('dog', Field('name'), Field('owner', db.person)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 zero=T('choose one'))
\end{lstlisting}

It is enforced at the level of dog INSERT/UPDATE/DELETE forms. It requires that a {\ft dog.owner} be a valid id in the field {\ft person.id} in the database {\ft db}. Because of this validator, the {\ft dog.owner} field is represented as a dropbox. The third argument of the validator is a string that describes the elements in the dropbox. In the example you want to see the person {\ft \%(name)s} instead of the person {\ft \%(id)s}. {\ft \%(...)s} is replaced by the value of the field in brackets for each record.

The {\ft zero} option works very much like for the {\ft IS\_IN\_SET} validator.

The first argument of the validator can be a database connection or a DAL Set, as in {\ft IS\_NOT\_IN\_DB}. This can be useful for example when wishing to limit the records in the drop-down box. In this example, we use {\ft IS\_IN\_DB} in a controller to limit the records dynamically each time the controller is called:

\begin{lstlisting}
def index():
    (...)
    query = (db.table.field == 'xyz') #in practice 'xyz' would be a variable
    db.table.field.requires=IS_IN_DB(db(query),....)
    form=SQLFORM(...)
    if form.process().accepted: ...
    (...)
\end{lstlisting}

If you want the field validated, but you do not want a dropbox, you must put the validator in a list.

\begin{lstlisting}
db.dog.owner.requires = [IS_IN_DB(db, 'person.id', '%(name)s')]
\end{lstlisting}

\inxx{\_and}
Occasionally you want the drop-box (so you do not want to use the list syntax above) yet you want to use additional validators. For this purpose the {\ft IS\_IN\_DB} validator takes an extra argument {\ft \_and} that can point to a list of other validators applied if the validated value passes the {\ft IS\_IN\_DB} validation. For example to validate all dog owners in db that are not in a subset:
\begin{lstlisting}
subset=db(db.person.id>100)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 _and=IS_NOT_IN_DB(subset,'person.id'))
\end{lstlisting}

{\ft IS\_IN\_DB} has a boolean {\ft distinct} argument which defaults to {\ft False}. When set to {\ft True} it prevents repeated values in the dropdown.

{\ft IS\_IN\_DB} also takes a {\ft cache} argument that works like the {\ft cache} argument of select.

{\bf {\ft IS\_IN\_DB} and Tagging}

\inxx{tags}
\inxx{multiple}

The {\ft IS\_IN\_DB} validator has an optional attribute {\ft multiple=False}. If set to {\ft True} multiple values can be stored in one field. This field should be of type {\ft list:reference} as discussed in Chapter 6. An explicit example of tagging is discussed there. {\ft multiple} references are handled automatically in create and update forms, but they are transparent to the DAL. We strongly suggest using the jQuery multiselect plugin to render multiple fields.

\goodbreak\subsection{Custom validators}

\inxx{custom validator}

All validators follow the prototype below:
\begin{lstlisting}
class sample_validator:
    def __init__(self, *a, error_message='error'):
        self.a = a
        self.e = error_message
    def __call__(self, value):
        if validate(value):
            return (parsed(value), None)
        return (value, self.e)
    def formatter(self, value):
        return format(value)
\end{lstlisting}
\noindent i.e., when called to validate a value, a validator returns a tuple {\ft (x, y)}. If {\ft y} is {\ft None}, then the value passed validation and {\ft x} contains a parsed value. For example, if the validator requires the value to be an integer, {\ft x} is converted to {\ft int(value)}. If the value did not pass validation, then {\ft x} contains the input value and {\ft y} contains an error message that explains the failed validation. This error message is used to report the error in forms that do not validate.

The validator may also contain a {\ft formatter} method. It must perform the opposite conversion to the one the {\ft \_\_call\_\_} does. For example, consider the source code for {\ft IS\_DATE}:
\begin{lstlisting}
class IS_DATE(object):
    def __init__(self, format='%Y-%m-%d', error_message='must be YYYY-MM-DD!'):
        self.format = format
        self.error_message = error_message
    def __call__(self, value):
        try:
            y, m, d, hh, mm, ss, t0, t1, t2 = time.strptime(value, str(self.format))
            value = datetime.date(y, m, d)
            return (value, None)
        except:
            return (value, self.error_message)
    def formatter(self, value):
        return value.strftime(str(self.format))
\end{lstlisting}

On success, the {\ft \_\_call\_\_} method reads a date string from the form and converts it into a datetime.date object using the format string specified in the constructor. The {\ft formatter} object takes a datetime.date object and converts it to a string representation using the same format. The {\ft formatter} is called automatically in forms, but you can also call it explicitly to convert objects into their proper representation. For example:
\begin{lstlisting}
>>> db = DAL()
>>> db.define_table('atable',
       Field('birth', 'date', requires=IS_DATE('%m/%d/%Y')))
>>> id = db.atable.insert(birth=datetime.date(2008, 1, 1))
>>> row = db.atable[id]
>>> print db.atable.formatter(row.birth)
01/01/2008
\end{lstlisting}

When multiple validators are required (and stored in a list), they are executed in order and the output of one is passed as input to the next. The chain breaks when one of the validators fails.

Conversely, when we call the {\ft formatter} method of a field, the formatters of the associated validators are also chained, but in reverse order.

\begin{quote}Notice that as alternative to custom validators, you can also use the {\ft onvalidate} argument of {\ft form.accepts(...)}, {\ft form.process(...)} and {\ft form.validate(...)}.\end{quote}
\goodbreak\subsection{Validators with dependencies}

Usually validators are set once for all in models.

Occasionally, you need to validate a field and the validator depends on the value of another field. This can be done in various ways. It can be done in the model or in the controller.

For example, here is a page that generates a registration form that asks for username and password twice. None of the fields can be empty, and both passwords must match:
\begin{lstlisting}
def index():
    form = SQLFORM.factory(
        Field('username', requires=IS_NOT_EMPTY()),
        Field('password', requires=IS_NOT_EMPTY()),
        Field('password_again',
              requires=IS_EQUAL_TO(request.vars.password)))
    if form.process().accepted:
        pass # or take some action
    return dict(form=form)
\end{lstlisting}

The same mechanism can be applied to FORM and SQLFORM objects.

\goodbreak\section{Widgets}

Here is a list of available web2py widgets:
\begin{lstlisting}
SQLFORM.widgets.string.widget
SQLFORM.widgets.text.widget
SQLFORM.widgets.password.widget
SQLFORM.widgets.integer.widget
SQLFORM.widgets.double.widget
SQLFORM.widgets.time.widget
SQLFORM.widgets.date.widget
SQLFORM.widgets.datetime.widget
SQLFORM.widgets.upload.widget
SQLFORM.widgets.boolean.widget
SQLFORM.widgets.options.widget
SQLFORM.widgets.multiple.widget
SQLFORM.widgets.radio.widget
SQLFORM.widgets.checkboxes.widget
SQLFORM.widgets.autocomplete
\end{lstlisting}

The first ten of them are the defaults for the corresponding field types. The "options" widget is used when a field's requires is {\ft IS\_IN\_SET} or {\ft IS\_IN\_DB} with {\ft multiple=False} (default behavior). The "multiple" widget is used when a field's requires is {\ft IS\_IN\_SET} or {\ft IS\_IN\_DB} with {\ft multiple=True}. The "radio" and "checkboxes" widgets are never used by default, but can be set manually. The autocomplete widget is special and discussed in its own section.

For example, to have a "string" field represented by a textarea:
\begin{lstlisting}
Field('comment', 'string', widget=SQLFORM.widgets.text.widget)
\end{lstlisting}

Widgets can also be assigned to fields {\it a posteriori}:

\begin{lstlisting}
db.mytable.myfield.widget = SQLFORM.widgets.string.widget
\end{lstlisting}

Sometimes widgets take additional arguments and one needs to specify their values. In this case one can use {\ft lambda}

\begin{lstlisting}
db.mytable.myfield.widget = lambda field,value: \
    SQLFORM.widgets.string.widget(field,value,_style='color:blue')
\end{lstlisting}

Widgets are helper factories and their first two arguments are always {\ft field} and {\ft value}. The other arguments can include normal helper attributes such as {\ft \_style}, {\ft \_class}, etc. Some widgets also take special arguments. In particular {\ft SQLFORM.widgets.radio} and {\ft SQLFORM.widgets.checkboxes} take a {\ft style} argument (not to be confused with {\ft \_style}) which can be set to "table", "ul", or "divs" in order to match the {\ft formstyle} of the containing form.

You can create new widgets or extend existing widgets.

{\ft SQLFORM.widgets[type]} is a class and {\ft SQLFORM.widgets[type].widget} is a static member function of the corresponding class. Each widget function takes two arguments: the field object, and the current value of that field. It returns a representation of the widget. As an example, the string widget could be re-coded as follows:
\begin{lstlisting}
def my_string_widget(field, value):
    return INPUT(_name=field.name,
                 _id="%s_%s" % (field._tablename, field.name),
                 _class=field.type,
                 _value=value,
                 requires=field.requires)

Field('comment', 'string', widget=my_string_widget)
\end{lstlisting}

The id and class values must follow the convention described later in this chapter. A widget may contain its own validators, but it is good practice to associate the validators to the "requires" attribute of the field and have the widget get them from there.

\goodbreak\subsection{Autocomplete widget}

\inxx{autocomplete}

There are two possible uses for the autocomplete widget: to autocomplete a field that takes a value from a list or to autocomplete a reference field (where the string to be autocompleted is a representation of the reference which is implemented as an id).

The first case is easy:
\begin{lstlisting}
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, limitby=(0,10), min_length=2)
\end{lstlisting}

Where {\ft limitby} instructs the widget to display no more than 10 suggestions at the time, and {\ft min\_length} instructs the widget to perform an Ajax callback to fetch suggestions only after the user has typed at least 2 characters in the search box.

The second case is more complex:
\begin{lstlisting}
db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id)
\end{lstlisting}

In this case the value of {\ft id\_field} tells the widget that even if the value to be autocompleted is a {\ft db.category.name}, the value to be stored is the corresponding {\ft db.category.id}. An optional parameter is {\ft orderby} that instructs the widget on how to sort the suggestions (alphabetical by default).

This widget works via Ajax. Where is the Ajax callback? Some magic is going on in this widget. The callback is a method of the widget object itself. How is it exposed? In web2py any piece of code can generate a response by raising an HTTP exception. This widget exploits this possibility in the following way: the widget sends the Ajax call to the same URL that generated the widget in the first place and puts a special token in the request.vars. Should the widget get instantiated again, it finds the token and raises an HTTP exception that responds to the request. All of this is done under the hood and hidden to the developer.

\goodbreak\section{{\ft SQLFORM.grid} and {\ft SQLFORM.smartgrid}}

\begin{quote}Attention: grid and smartgrid were experimental prior web2py version 2.0 and were vulnerable to information leakage. The grid and smartgrid are no longer experimental, but we are still not promising backward compatibility of the presentation layer of the grid, only of its APIs.\end{quote}
These are two high level gadgets that create complex CRUD controls. They provide pagination, the ability to browser, search, sort, create, update and delete records from a single gadgets.

The simplest of the two is {\ft SQLFORM.grid}. Here is an example of usage:

\begin{lstlisting}
@auth.requires_login()
def manage_users():
    grid = SQLFORM.grid(db.auth_user)
    return locals()
\end{lstlisting}
\noindent which produces the following page:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6700.png}\end{center}


The first argument of {\ft SQLFORM.grid} can be a table or a query. The grid gadget will provide access to records matching the query.

Before we dive into the long list of arguments of the grid gadget we need to understand how it works. The gadget looks at {\ft request.args} in order to decide what to do (browse, search, create, update, delete, etc.). Each button created by the gadget links the same function ({\ft manage\_users} in the above case) but passes different {\ft request.args}. By default all the URL generated by the grid are digitally signed and verified. This means one cannot perform certain actions (create, update, delete) without being logged-in. These restrictions can be relaxed:

\begin{lstlisting}
def manage_users():
    grid = SQLFORM.grid(db.auth_user,user_signature=False)
    return locals()
\end{lstlisting}
\noindent but we do not recommend it.

\begin{quote}Because of the way grid works one can only have one grid per controller function, unless they are embedded as components via {\ft LOAD}.
To make the default search grid work in more than one LOADed grid, please use a different {\ft formname} for each one.\end{quote}
Because the function that contains the grid may itself manipulate the command line arguments, the grid needs to know which args should be handled by the grid and which not. For example here is an example of code that allows one to manage any table:

\begin{lstlisting}
@auth.requires_login()
def manage():
    table = request.args(0)
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.grid(db[table],args=request.args[:1])
    return locals()
\end{lstlisting}
\noindent the {\ft args} argument of the {\ft grid} specifies which {\ft request.args} should be passed along and ignored by the gadget. In our case {\ft request.args[:1]} is the name of the table we want to manage and it is handled by the {\ft manage} function itself, not by the gadget.

The complete signature for the grid is the following:

\begin{lstlisting}
SQLFORM.grid(
    query,
    fields=None,
    field_id=None,
    left=None,
    headers={},
    orderby=None,
    groupby=None,
    searchable=True,
    sortable=True,
    paginate=20,
    deletable=True,
    editable=True,
    details=True,
    selectable=None,
    create=True,
    csv=True,
    links=None,
    links_in_grid=True,
    upload='<default>',
    args=[],
    user_signature=True,
    maxtextlengths={},
    maxtextlength=20,
    onvalidation=None,
    oncreate=None,
    onupdate=None,
    ondelete=None,
    sorter_icons=(XML('&#x2191;'), XML('&#x2193;')),
    ui = 'web2py',
    showbuttontext=True,
    _class="web2py_grid",
    formname='web2py_grid',
    search_widget='default',
    ignore_rw = False,
    formstyle = 'table3cols',
    exportclasses = None,
    formargs={},
    createargs={},
    editargs={},
    viewargs={},
    buttons_placement = 'right',
    links_placement = 'right'
    )
\end{lstlisting}

\begin{itemize}
\item {\ft fields} is a list of fields to be fetched from the database. It is also used to determine which fields to be shown in the grid view.

\item {\ft field\_id} must be the field of the table to be used as ID, for example {\ft db.mytable.id}.

\item {\ft left} is an optional left join expressions used to build {\ft ...select(left=...)}.

\item {\ft headers} is a dictionary that maps 'tablename.fieldname' into the corresponding header label, e.g. {\ft \{'auth\_user.email' : 'Email Address'\}}

\item {\ft orderby} is used as default ordering for the rows.

\item {\ft groupby} is used to group the set. Use the same syntax as you were passing in a simple {\ft select(groupby=...)}.

\item {\ft searchable}, {\ft sortable}, {\ft deletable}, {\ft editable}, {\ft details}, {\ft create} determine whether one can search, sort, delete, edit, view details, and create new records respectively.

\item {\ft selectable} can be used to call a custom function on multiple records (a checkbox will be inserted for every row) e.g.
\end{itemize}
\begin{lstlisting}
   selectable = lambda ids : redirect(URL('default', 'mapping_multiple', vars=dict(id=ids)))
\end{lstlisting}
\begin{itemize}
\item {\ft paginate} sets the max number of rows per page.

\item {\ft csv} if set to true allows to download the grid in various format (more on that later).

\item {\ft links} is used to display new columns which can be links to other pages. The {\ft links} argument must be a list of  {\ft dict(header='name',body=lambda row: A(...))} where {\ft header} is the header of the new column and {\ft body} is a function that takes a row and returns a value. In the example, the value is a {\ft A(...)} helper.

\item {\ft links\_in\_grid} if set to False, links will only be displayed in the "details" and "edit" page (so, not on the main grid)

\item {\ft upload} same as SQLFORM's one. web2py uses the action at that URL to download the file

\item {\ft maxtextlength} sets the maximum length of text to be displayed for each field value, in the grid view. This value can be overwritten for each field using {\ft maxtextlengths}, a dictionary of 'tablename.fieldname':length e.g. {\ft \{'auth\_user.email' : 50\}}

\item {\ft onvalidation}, {\ft oncreate}, {\ft onupdate} and {\ft ondelete} are callback functions. All but {\ft ondelete} take a form object as input.

\item {\ft sorter\_icons} is a list of two strings (or helpers) that will be used to represent the up and down sorting options for each field.

\item {\ft ui} can be set equal to 'web2py' and will generate web2py friendly class names, can be set equal to {\ft jquery-ui} and will generate jquery UI friendly class names, but it can also be its own set of class names for the various grid components:
\end{itemize}
\begin{lstlisting}
ui = dict(
    widget='',
    header='',
    content='',
    default='',
    cornerall='',
    cornertop='',
    cornerbottom='',
    button='button',
    buttontext='buttontext button',
    buttonadd='icon plus',
    buttonback='icon leftarrow',
    buttonexport='icon downarrow',
    buttondelete='icon trash',
    buttonedit='icon pen',
    buttontable='icon rightarrow',
    buttonview='icon magnifier')
\end{lstlisting}

\begin{itemize}
\item {\ft search\_widget} allows to override the default search widget and we refer the reader the source code in "gluon/sqlhtml.py" for details.

\item {\ft showbuttontext} allows to have buttons without text (there will effectively be only icons)

\item {\ft \_class} is the class for the grid container.

\item {\ft showbutton} allows to turn off all buttons.

\item {\ft exportclasses} takes a dictionary of tuples: by default it's defined as
\end{itemize}

\begin{lstlisting}
csv_with_hidden_cols=(ExporterCSV, 'CSV (hidden cols)'),
csv=(ExporterCSV, 'CSV'),
xml=(ExporterXML, 'XML'),
html=(ExporterHTML, 'HTML'),
tsv_with_hidden_cols=(ExporterTSV, 'TSV (Excel compatible, hidden cols)'),
tsv=(ExporterTSV, 'TSV (Excel compatible)'))
\end{lstlisting}

ExporterCSV, ExporterXML, ExporterHTML and ExporterTSV are all defined in gluon/sqlhtml.py. Take a look at those for creating your own exporter. If you pass a dict like {\ft dict(xml=False, html=False)} you will disable the xml and html export formats.

\begin{itemize}
\item {\ft formargs} is passed to all SQLFORM objects used by the grid, while {\ft createargs},{\ft editargs} and {\ft viewargs} are passed only to the specific create, edit and details SQLFORMs

\item {\ft formname}, {\ft ignore\_rw} and {\ft formstyle} are passed to the SQLFORM objects used by the grid for create/update forms.

\item {\ft buttons\_placement} and {\ft links\_placement} both take a parameter ('right', 'left', 'both') that will affect where on the row the buttons (or the links) will be placed
\end{itemize}
\begin{quote}{\ft deletable}, {\ft editable} and {\ft details} are usually boolean values but they can be functions which take the row object and decide whether to display the corresponding button or not.\end{quote}
A {\ft SQLFORM.smartgrid} looks a lot like a {\ft grid}, in fact it contains a grid but it is designed to take as input not a query but only one table and to browse said table and selected referencing tables.

For example consider the following table structure:

\begin{lstlisting}
db.define_table('parent',Field('name'))
db.define_table('child',Field('name'),Field('parent','reference parent'))
\end{lstlisting}

With SQLFORM.grid you can list all parents:

\begin{lstlisting}
SQLFORM.grid(db.parent)
\end{lstlisting}
all children:
\begin{lstlisting}
SQLFORM.grid(db.child)
\end{lstlisting}
and all parents and children in one table:
\begin{lstlisting}
SQLFORM.grid(db.parent,left=db.child.on(db.child.parent==db.parent.id))
\end{lstlisting}

With SQLFORM.smartgrid you can put all the data in one gadget that spawns both tables:

\begin{lstlisting}
@auth.requires_login()
def manage():
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
\end{lstlisting}
\noindent which looks like this:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6800.png}\end{center}


Notice the extra "children" links. One could create the extra {\ft links} using a regular {\ft grid} but they would point to a different action. With a {\ft smartgrid} they are created automatically and handled by the same gadget.

Also notice that when clicking on the "children" link for a given parent one only gets the list of children for that parent (and that is obvious) but also notice that if one now tried to add a new child, the parent value for the new child is automatically set to the selected parent (displayed in the breadcrumbs associated to the gadget). The value of this field can be overwritten. We can prevent this by making it readonly:

\begin{lstlisting}
@auth.requires_login():
def manage():
    db.child.parent.writable = False
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()
\end{lstlisting}

If the {\ft linked\_tables} argument is not specified all referencing tables are automatically linked. Anyway, to avoid accidentally exposing data we recommend explicitly listing tables that should be linked.

The following code creates a very powerful management interface for all tables in the system:

\begin{lstlisting}
@auth.requires_membership('managers'):
def manage():
    table = request.args(0) or 'auth_user'
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.smartgrid(db[table],args=request.args[:1])
    return locals()
\end{lstlisting}

The {\ft smartgrid} takes the same arguments as a {\ft grid} and some more with some caveats:

\begin{itemize}
\item The first argument is a table, not a query

\item There is a extra argument {\ft constraints} which is a dictionary of 'tablename':query which can be used to further restrict access to the records displayed in the 'tablename' grid.

\item There is a extra argument {\ft linked\_tables} which is a list of tablenames of tables that should be accessible via the smartgrid.

\item {\ft divider} allows to specify a character to use in the breadcrumb navigator, {\ft breadcrumbs\_class} will apply the class to the breadcrumb element

\item All the arguments but the table, {\ft args}, {\ft linked\_tables} and {\ft user\_signatures} can be dictionaries as explained below.
\end{itemize}

Consider the previous grid:
\begin{lstlisting}
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
\end{lstlisting}
It allows one to access both a {\ft db.parent} and a {\ft db.child}. Apart for navigation controls, for each one table, a smarttable is nothing but a grid. This means that, in this case, one smartgrid can create a grid for parent and one grid for child. We may want to pass different sets of parameters to these grids. For example different sets of {\ft searchable} parameters.

While for a grid we would pass a boolean:
\begin{lstlisting}
grid = SQLFORM.grid(db.parent,searchable=True)
\end{lstlisting}
\noindent for a smartgrid we would pass a dictionary of booleans:
\begin{lstlisting}
grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'],
     searchable= dict(parent=True, child=False))
\end{lstlisting}

In this way we made parents searchable but children for each parent not searchable (there should not be that many to need the search widget).

\begin{quote}The grid and smartgrid gadgets are here to stay but they are marked experimental because the actual html layout of what they return and the exact set of parameters one can pass to them  may be subject to change as new functionalities are added.\end{quote}
{\ft grid} and {\ft smartgrid} do not automatically enforce access control like crud does but you can integrate it with {\ft auth} using explicit permission checking:

\begin{lstlisting}
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_membership('managers'),
     deletable = auth.has_membership('managers'))
\end{lstlisting}
\noindent or

\begin{lstlisting}
grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_permission('edit','auth_user'),
     deletable = auth.has_permission('delete','auth_user'))
\end{lstlisting}

The {\ft smartgrid} is the only gadget in web2py that displays the table name and it need both the singular and the plural. For example one parent can have one "Child" or many "Children". Therefore a table object needs to know its own singular and plural names. web2py normally guesses them but you can set the explicitly:

\begin{lstlisting}
db.define_table('child', ..., singular="Child", plural="Children")
\end{lstlisting}
\noindent or with: \inxx{singular} \inxx{plural}

\begin{lstlisting}
db.define_table('child', ...)
db.child._singular = "Child"
db.child._plural = "Children"
\end{lstlisting}

They should also be internationalized using the {\ft T} operator.

The plural and singular values are then used by {\ft smartgrid}
to provide correct names for headers and links.

\goodbreak\chapter{Emails and SMS}

\inxx{Mail}

\goodbreak\section{Setting up email}

Web2py provides the {\ft gluon.tools.Mail} class to make it easy to send emails using web2py. One can define a mailer with
\begin{lstlisting}
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
\end{lstlisting}

Note, if your application uses {\ft Auth} (discussed in the next chapter), the {\ft auth} object will include its own mailer in {\ft auth.settings.mailer}, so you can use that instead as follows:
\begin{lstlisting}
mail = auth.settings.mailer
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
\end{lstlisting}

You need to replace the mail.settings with the proper parameters for your SMTP server. Set {\ft mail.settings.login = None} if the SMTP server does not require authentication.
If you don't want to use TLS, set {\ft mail.settings.tls = False}

\inxx{email logging}

\begin{quote}For debugging purposes you can set
\begin{lstlisting}
mail.settings.server = 'logging'
\end{lstlisting}
and emails will not be sent but logged to the console instead.\end{quote}
\goodbreak\subsection{Configuring email for Google App Engine}

\inxx{email from GAE}
For sending emails from Google App Engine account:

\begin{lstlisting}
mail.settings.server = 'gae'
\end{lstlisting}

At the time of writing web2py does not support attachments and encrypted emails on Google App Engine. Notice cron and scheduler do not work on GAE.

\goodbreak\subsection{x509 and PGP Encryption}

\inxx{PGP} \inxx{x509}

It is possible to send x509 (SMIME) encrypted emails using the following settings:
\begin{lstlisting}
mail.settings.cipher_type = 'x509'
mail.settings.sign = True
mail.settings.sign_passphrase = 'your passphrase'
mail.settings.encrypt = True
mail.settings.x509_sign_keyfile = 'filename.key'
mail.settings.x509_sign_certfile = 'filename.cert'
mail.settings.x509_crypt_certfiles = 'filename.cert'
\end{lstlisting}

It is possible to send PGP encrypted emails. First of all you need to install the python-pyme package. Then you can use GnuPG (GPG) to create the key-files for the sender (take the email-address from mail.settings.sender) and put the files pubring.gpg and  secring.gpg in a directory (e.g. "/home/www-data/.gnupg").

Use the following settings:

\begin{lstlisting}
mail.settings.gpg_home = '/home/www-data/.gnupg/'
mail.settings.cipher_type = 'gpg'
mail.settings.sign = True
mail.settings.sign_passphrase = 'your passphrase'
mail.settings.encrypt = True
\end{lstlisting}

\goodbreak\section{Sending emails}

\inxx{mail.send} \inxx{email html} \inxx{email attachments}

Once {\ft mail} is defined, it can be used to send email via:
\begin{lstlisting}
mail.send(to=['somebody@example.com'],
          subject='hello',
          # If reply_to is omitted, then mail.settings.sender is used
          reply_to='us@example.com',
          message='hi there')
\end{lstlisting}

Mail returns {\ft True} if it succeeds in sending the email and {\ft False} otherwise.  A complete argument list for {\ft mail.send()} is as follows:

\begin{lstlisting}
send(self, to, subject='None', message='None', attachments=1,
     cc=1, bcc=1, reply_to=1, encoding='utf-8',headers={},
     sender=None)
\end{lstlisting}

Note, {\ft to}, {\ft cc}, and {\ft bcc} each take a list of email addresses.

{\ft headers} is dictionary of headers to refine the headers just before sending the email. For example:

\begin{lstlisting}
headers = {'Return-Path' : 'bounces@example.org'}
\end{lstlisting}

{\ft sender} defaults to {\ft None} and in this case the sender will be set to {\ft mail.settings.sender}.

Following are some additional examples demonstrating the use of {\ft mail.send()}.

\goodbreak\subsection{Simple text email}

\begin{lstlisting}
mail.send('you@example.com',
  'Message subject',
  'Plain text body of the message')
\end{lstlisting}

\goodbreak\subsection{HTML emails}

\begin{lstlisting}
mail.send('you@example.com',
  'Message subject',
  '<html>html body</html>')
\end{lstlisting}

If the email body starts with {\ft <html>} and ends with {\ft </html>}, it will be sent as a HTML email.

\goodbreak\subsection{Combining text and HTML emails}

The email message can be a tuple (text, html):

\begin{lstlisting}
mail.send('you@example.com',
  'Message subject',
  ('Plain text body', '<html>html body</html>'))
\end{lstlisting}

\goodbreak\subsection{{\ft cc} and {\ft bcc} emails}

\begin{lstlisting}
mail.send('you@example.com',
  'Message subject',
  'Plain text body',
  cc=['other1@example.com', 'other2@example.com'],
  bcc=['other3@example.com', 'other4@example.com'])
\end{lstlisting}

\goodbreak\subsection{Attachments}

\begin{lstlisting}
mail.send('you@example.com',
  'Message subject',
  '<html><img src="cid:photo" /></html>',
  attachments = mail.Attachment('/path/to/photo.jpg', content_id='photo'))
\end{lstlisting}

\goodbreak\subsection{Multiple attachments}

\begin{lstlisting}
mail.send('you@example.com',
  'Message subject',
  'Message body',
  attachments = [mail.Attachment('/path/to/fist.file'),
                 mail.Attachment('/path/to/second.file')])
\end{lstlisting}

\goodbreak\section{Sending SMS messages}

\inxx{SMS}
Sending SMS messages from a web2py application requires a third party service that can relay the messages to the receiver. Usually this is not a free service, but it differs from country to country. We have tried a few of these services with little success. Phone companies block emails originating from these services since they are eventually used as a source of spam.

A better way is to use the phone companies themselves to relay the SMS. Each phone company has an email address uniquely associated with every cell-phone number, so SMS messages can be sent as emails to the phone number.
\noindent web2py comes with a module to help in this process:
\begin{lstlisting}
from gluon.contrib.sms_utils import SMSCODES, sms_email
email = sms_email('1 (111) 111-1111','T-Mobile USA (tmail)')
mail.sent(to=email, subject='test', message='test')
\end{lstlisting}

SMSCODES is a dictionary that maps names of major phone companies to the email address postfix. The {\ft sms\_email} function takes a phone number (as a string) and the name of a phone company and returns the email address of the phone.

\goodbreak\section{Using the template system to generate messages}

\inxx{emails}

It is possible to use the template system to generate emails. For example, consider the database table
\begin{lstlisting}
db.define_table('person', Field('name'))
\end{lstlisting}
\noindent where you want to send to every person in the database the following message,
stored in a view file "message.html":
\begin{lstlisting}
Dear {{=person.name}},
You have won the second prize, a set of steak knives.
\end{lstlisting}

You can achieve this in the following way
\begin{lstlisting}
for person in db(db.person).select():
    context = dict(person=person)
    message = response.render('message.html', context)
    mail.send(to=['who@example.com'],
              subject='None',
              message=message)
\end{lstlisting}

Most of the work is done in the statement
\begin{lstlisting}
response.render('message.html', context)
\end{lstlisting}

It renders the view "message.html" with the variables defined in the dictionary "context", and it returns a string with the rendered email text. The context is a dictionary that contains variables that will be visible to the template file.

If the message starts with {\ft <html>} and ends with {\ft </html>}, the email will be an HTML email.

Note, if you want to include a link back to your website in an HTML email, you can use the {\ft URL} function. However, by default, the {\ft URL} function generates a relative URL, which will not work from an email. To generate an absolute URL, you need to specify the {\ft scheme} and {\ft host} arguments to the URL function. For example:
\begin{lstlisting}[keywords={}]
<a href="{{=URL(..., scheme=True, host=True)}}">Click here</a>
\end{lstlisting}
\noindent or

\begin{lstlisting}[keywords={}]
<a href="{{=URL(..., scheme='http', host='www.site.com')}}">Click here</a>
\end{lstlisting}

The same mechanism that is used to generate email text can also be used to generate SMS messages or any other type of message based on a template.

\goodbreak\section{Sending messages using a background task}

The operation of sending an email message can take up to several seconds because of the need to log into and communicate with a potentially remote SMTP server. To keep the user from having to wait for the send operation to complete, it is sometimes desirable to queue the email to be sent at a later time via a background task. As described in Chapter 4, this can be done by setting up a homemade task queue or using the web2py scheduler. Here we provide an example using a homemade task queue.

First, in a model file within our application, we set up a database model to store our email queue:
\begin{lstlisting}
db.define_table('queue',
    Field('status'),
    Field('email'),
    Field('subject'),
    Field('message'))
\end{lstlisting}

From a controller, we can then enqueue messages to be sent by:
\begin{lstlisting}
db.queue.insert(status='pending',
                email='you@example.com',
                subject='test',
                message='test')
\end{lstlisting}

Next, we need a background processing script that reads the queue and sends the emails:
\begin{lstlisting}
## in file /app/private/mail_queue.py
import time
while True:
    rows = db(db.queue.status=='pending').select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status='sent')
        else:
            row.update_record(status='failed')
        db.commit()
    time.sleep(60) # check every minute
\end{lstlisting}

Finally, as described in Chapter 4, we need to run the mail\_queue.py script as if it were inside a controller in our app:
\begin{lstlisting}
python web2py.py -S app -M -N -R applications/app/private/mail_queue.py
\end{lstlisting}
\noindent where {\ft -S app} tells web2py to run "mail\_queue.py" as "app", {\ft -M} tells web2py to execute models, and {\ft -N} tells web2py not to run cron.

Here we assume that the {\ft mail} object referenced in "mail\_queue.py" is defined in a model file in our app and is therefore available in the "mail\_queue.py" script because of the {\ft -M} option. Also notice that it is important to commit any change as soon as possible in order not to lock the database to other concurrent processes.

As noted in Chapter 4, this type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time.

Note, one drawback to sending email via a background process is that it makes it difficult to provide feedback to the user in case the email fails. If email is sent directly from the controller action, you can catch any errors and immediately return an error message to the user. With a background process, however, the email is sent asynchronously, after the controller action has already returned its response, so it becomes more complex to notify the user of a failure.

\goodbreak\section{Reading and managing email boxes (Experimental)}

The {\ft IMAP} adapter is intended as an interface with email IMAP servers to perform simple queries in the web2py {\ft DAL} query syntax, so email read, search and other related IMAP mail services (as those implemented by brands like Google(r), and Yahoo(r) can be managed from web2py applications.

It creates its table and field names "statically", meaning that the developer should leave the table and field definitions to the DAL instance by calling the adapter {\ft .define\_tables()} method. The tables are defined with the IMAP server mailbox list information.

\goodbreak\subsection{Connection}

For a single mail account, this is the code recommended to start IMAP support at the app's model

\begin{lstlisting}
# Replace user, password, server and port in the connection string
# Set port as 993 for SSL support
imapdb = DAL("imap://user:password@server:port", pool_size=1)
imapdb.define_tables()
\end{lstlisting}

Note that {\ft <imapdb>.define\_tables()} returns a dictionary of strings mapping DAL tablenames to the server mailbox names with the structure {\ft \{<tablename>: <server mailbox name>, ...\}}, so you can get the actual mailbox name in the IMAP server.

To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

\goodbreak\begin{center}
{\begin{tabular}{lll}\hline
{\bf Attribute} & {\bf Type} & {\bf Format}\\ \hline
imapdb.mailboxes & dict & {\ft \{<tablename>: <server native name>, ...\}}\\
imapdb.<table>.mailbox & string & {\ft "server native name"} \\ \hline
\end{tabular}}
\end{center}
The first can be useful to retrieve IMAP query sets by the native email service mailbox
\begin{lstlisting}
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
\end{lstlisting}

\goodbreak\subsection{Fetching mail and updating flags}

Here's a list of IMAP commands you could use in the controller. For the examples, it's assumed that your IMAP service has a mailbox named {\ft INBOX}, which is the case for Gmail(r) accounts.

To count today's unseen messages smaller than 6000 octets from the inbox mailbox do
\begin{lstlisting}
q = imapdb.INBOX.seen == False
q &= imapdb.INBOX.created == datetime.date.today()
q &= imapdb.INBOX.size < 6000
unread = imapdb(q).count()
\end{lstlisting}

You can fetch the previous query messages with
\begin{lstlisting}
rows = imapdb(q).select()
\end{lstlisting}

Usual query operators are implemented, including belongs

\begin{lstlisting}
messages = imapdb(imapdb.INBOX.uid.belongs(<uid sequence>)).select()
\end{lstlisting}

{\bf Note}: It's strongly advised that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.

It is possible to filter query select results with limitby and sequences of mailbox fields
\begin{lstlisting}
# Replace the arguments with actual values
myset.select(<fields sequence>, limitby=(<int>, <int>))
\end{lstlisting}

Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by {\ft uid} field to avoid using old sequence references).

\begin{lstlisting}
mymessage = imapdb(imapdb.INBOX.uid == <uid>).select().first()
\end{lstlisting}

Otherwise, you can use the message's {\ft id}.

\begin{lstlisting}
mymessage = imapdb.INBOX[<id>]
\end{lstlisting}

Note that using the message's id as reference is not recommended, because sequence numbers can change with mailbox maintenance operations as message deletions. If you still want to record references to messages (i.e. in another database's record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

\begin{lstlisting}[keywords={}]
{{=P(T("Message from"), " ", mymessage.sender)}}
{{=P(T("Received on"), " ", mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
\end{lstlisting}

As expected, we can take advantage of the {\ft SQLTABLE} helper to build message lists in views

\begin{lstlisting}[keywords={}]
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
\end{lstlisting}

And of course, it's possible to feed a form helper with the appropriate sequence id value

\begin{lstlisting}[keywords={}]
{{=SQLFORM(imapdb.INBOX, <message id>, fields=[...])}}
\end{lstlisting}

The current adapter supported fields available are the following:

\goodbreak\begin{center}
{\begin{tabular}{lll}\hline
{\bf Field} & {\bf Type} & {\bf Description}\\ \hline
uid & string & {\ft }\\
answered & boolean & Flag\\
created & date & {\ft }\\
content & list:string & A list of text or html parts\\
to & string & {\ft }\\
cc & string & {\ft }\\
bcc & string & {\ft }\\
size & integer & the amount of octets of the message*\\
deleted & boolean & Flag\\
draft & boolean & Flag\\
flagged & boolean & Flag\\
sender & string & {\ft }\\
recent & boolean & Flag\\
seen & boolean  & Flag\\
subject & string| {\ft }\\
mime & string & The mime header declaration\\
email & string & The complete RFC822 message**\\
attachments & list:string & Each non text decoded part as string \\ \hline
\end{tabular}}
\end{center}
*At the application side it is measured as the length of the RFC822
message string

{\bf WARNING}: As row id's are mapped to email sequence numbers, make sure your IMAP client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.

Standard {\ft CRUD} database operations are not supported. There's no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it's possible to access those flag commands through the DAL IMAP interface

To mark last query messages as seen
\begin{lstlisting}
seen = imapdb(q).update(seen=True)
\end{lstlisting}

Here we delete messages in the IMAP database that have mails from mr. Gumby
\begin{lstlisting}
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains("gumby")).delete()
\end{lstlisting}

It is possible also to mark messages for deletion instead of erasing them
directly with
\begin{lstlisting}
myset.update(deleted=True)
\end{lstlisting}

\inxx{IMAP}

\goodbreak\chapter{Access Control}

\inxx{Auth} \inxx{Access Control} \inxx{RBAC} \inxx{DAC} \inxx{MAC}
\noindent web2py includes a powerful and customizable Role Based Access Control mechanism (RBAC).

Here is a definition from Wikipedia:

"Role-Based Access Control (RBAC) is an approach to restricting system access to authorized users. It is a newer alternative approach to mandatory access control (MAC) and discretionary access control (DAC). RBAC is sometimes referred to as role-based security.

RBAC is a policy neutral and flexible access control technology sufficiently powerful to simulate DAC and MAC. Conversely, MAC can simulate RBAC if the role graph is restricted to a tree rather than a partially ordered set.

Prior to the development of RBAC, MAC and DAC were considered to be the only known models for access control: if a model was not MAC, it was considered to be a DAC model, and vice versa. Research in the late 1990s demonstrated that RBAC falls in neither category.

Within an organization, roles are created for various job functions. The permissions to perform certain operations are assigned to specific roles. Members of staff (or other system users) are assigned particular roles, and through those role assignments acquire the permissions to perform particular system functions. Unlike context-based access control (CBAC), RBAC does not look at the message context (such as a connection's source).

Since users are not assigned permissions directly, but only acquire them through their role (or roles), management of individual user rights becomes a matter of simply assigning appropriate roles to the user; this simplifies common operations, such as adding a user, or changing a user's department.

RBAC differs from access control lists (ACLs) used in traditional discretionary access control systems in that it assigns permissions to specific operations with meaning in the organization, rather than to low level data objects. For example, an access control list could be used to grant or deny write access to a particular system file, but it would not dictate how that file could be changed."

The web2py class that implements RBAC is called {\bf Auth}.

{\bf Auth} needs (and defines) the following tables:
\begin{itemize}
\item {\ft auth\_user} stores users' name, email address, password, and status (registration pending, accepted, blocked)

\item {\ft auth\_group} stores groups or roles for users in a many-to-many structure. By default, each user is in its own group, but a user can be in multiple groups, and each group can contain multiple users. A group is identified by a role and a description.

\item {\ft auth\_membership} links users and groups in a many-to-many structure.

\item {\ft auth\_permission} links groups and permissions. A permission is identified by a name and, optionally, a table and a record. For example, members of a certain group can have "update" permissions on a specific record of a specific table.

\item {\ft auth\_event} logs changes in the other tables and successful access via CRUD to objects controlled by the RBAC.

\item {\ft auth\_cas} is used for Central Authentication Service (CAS). Every web2py application is a CAS provider and can optionally be a CAS consumer.
\end{itemize}

The schema is reproduced graphically in the image below:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/schema_auth.png}\end{center}


In principle, there is no restriction on the names of the roles and the names of the permissions; the developer can create them to fix the roles and permissions in the organization. Once they have been created, web2py provides an API to check if a user is logged in, if a user is a member of a given group, and/or if the user is a member of any group that has a given required permission.
\noindent web2py also provides decorators to restrict access to any function based on login, membership and permissions.
\noindent web2py also understands some specific permissions, i.e., those that have a name that correspond to the CRUD methods (create, read, update, delete) and can enforce them automatically without the need to use decorators.

In this chapter, we are going to discuss different parts of RBAC one by one.

\goodbreak\section{Authentication}

In order to use RBAC, users need to be identified. This means that they need to register (or be registered) and log in.

{\bf Auth} provides multiple login methods. The default one consists of identifying users based on the local {\ft auth\_user} table.
Alternatively, it can log in users against third-party authentication systems and single sign on providers such as Google, PAM, LDAP, Facebook, LinkedIn, Dropbox, OpenID, OAuth, etc..

To start using {\ft Auth}, you need at least this code in a model file, which is also provided with the web2py "welcome" application and assumes a {\ft db} connection object:
\begin{lstlisting}
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables()
\end{lstlisting}

Auth has an optional {\ft secure=True} argument, which will force authenticated pages to go over HTTPS. \inxx{https}

\begin{quote}The {\ft password} field of the {\ft db.auth\_user} table defaults to a {\ft CRYPT} validator, which needs and {\ft hmac\_key}. On legacy web2py applications you may see an extra argument passed to the Auth constructor: {\ft hmac\_key = Auth.get\_or\_create\_key()}. The latter is a function that read the HMAC key from a file "private/auth.key" within the application folder. If the file does not exist it creates a random {\ft hmac\_key}. If multiple apps share the same auth database, make sure they also use the same {\ft hmac\_key}. This is no longer necessary for new applications since passwords are salted with an individual random salt.\end{quote}
By default, web2py uses email for login. If instead you want to log in using username set {\ft auth.define\_tables(username=True)}

If multiple apps share the same auth database you may want to disable migrations: {\ft auth.define\_tables(migrate=False)}.

To expose {\bf Auth}, you also need the following function in a controller (for example in "default.py"):
\begin{lstlisting}
def user(): return dict(form=auth())
\end{lstlisting}

\begin{quote}The {\ft auth} object and the {\ft user} action are already defined in the
scaffolding application.\end{quote}
web2py also includes a sample view "welcome/views/default/user.html" to render this function properly that looks like this:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<h2>{{=T( request.args(0).replace('_',' ').capitalize() )}}</h2>
<div id="web2py_user_form">
  {{=form}}
  {{if request.args(0)=='login':}}
    {{if not 'register' in auth.settings.actions_disabled:}}
      <br/><a href="{{=URL(args='register')}}">register</a>
    {{pass}}
    {{if not 'request_reset_password' in auth.settings.actions_disabled:}}
      <br/>
      <a href="{{=URL(args='request_reset_password')}}">lost password</a>
    {{pass}}
  {{pass}}
</div>
\end{lstlisting}

Notice that this function simply displays a {\ft form} and therefore it can be customized using normal custom form syntax. The only caveat is that the form displayed by {\ft form=auth()} depends on {\ft request.args(0)}; therefore, if you replace the default {\ft auth()} login form with a custom login form, you may need an {\ft if} statement like this in the view:
\begin{lstlisting}[keywords={}]
{{if request.args(0)=='login':}}...custom login form...{{pass}}
\end{lstlisting}

\inxx{auth.impersonate} \inxx{auth.is\_impersonating}

The controller above exposes multiple actions:
\begin{lstlisting}[keywords={}]
http://.../[app]/default/user/register
http://.../[app]/default/user/login
http://.../[app]/default/user/logout
http://.../[app]/default/user/profile
http://.../[app]/default/user/change_password
http://.../[app]/default/user/verify_email
http://.../[app]/default/user/retrieve_username
http://.../[app]/default/user/request_reset_password
http://.../[app]/default/user/reset_password
http://.../[app]/default/user/impersonate
http://.../[app]/default/user/groups
http://.../[app]/default/user/not_authorized
\end{lstlisting}
\begin{itemize}
\item {\bf register} allows users to register. It is integrated with CAPTCHA, although this is disabled by default. This is also integrated with a client-side entropy calculator defined in "web2py.js". The calculator indicates the strength of the new password. You can use the {\ft IS\_STRONG} validator to prevent web2py from accepting weak passwords.

\item {\bf login} allows users who are registered to log in (if the registration is verified or does not require verification, if it has been approved or does not require approval, and if it has not been blocked).

\item {\bf logout} does what you would expect but also, as the other methods, logs the event and can be used to trigger some event.

\item {\bf profile} allows users to edit their profile, i.e. the content of the {\ft auth\_user} table. Notice that this table does not have a fixed structure and can be customized.

\item {\bf change\_password} allows users to change their password in a fail-safe way.

\item {\bf verify\_email}. If email verification is turned on, then visitors, upon registration, receive an email with a link to verify their email information. The link points to this action.

\item {\bf retrieve\_username}. By default, {\bf Auth} uses email and password for login, but it can, optionally, use username instead of email. In this latter case, if a user forgets his/her username, the {\ft retrieve\_username} method allows the user to type the email address and retrieve the username by email.

\item {\bf request\_reset\_password}. Allows users who forgot their password to request a new password. They will get a confirmation email pointing to {\bf reset\_password}.

\item {\bf impersonate} allows a user to "impersonate" another user. This is important for debugging and for support purposes. {\ft request.args[0]} is the id of the user to be impersonated. This is only allowed if the logged in user {\ft has\_permission('impersonate', db.auth\_user, user\_id)}. You can use {\ft auth.is\_impersonating()} to check is the current user is impersonating somebody else.

\item {\bf groups} lists the groups of which the current logged in user is a member.

\item {\bf not\_authorized} displays an error message when the visitor tried to do something that he/she is not authorized to do

\item {\bf navbar} is a helper that generates a bar with login/register/etc. links.
\end{itemize}

Logout, profile, change\_password, impersonate, and groups require login.

By default they are all exposed, but it is possible to restrict access to only some of these actions.

All of the methods above can be extended or replaced by subclassing {\bf Auth}.

All of the methods above can be used in separate actions. For example:

\begin{lstlisting}
def mylogin(): return dict(form=auth.login())
def myregister(): return dict(form=auth.register())
def myprofile(): return dict(form=auth.profile())
...
\end{lstlisting}

To restrict access to functions to only logged in visitors, decorate the function as in the following example
\begin{lstlisting}
@auth.requires_login()
def hello():
    return dict(message='hello %(first_name)s' % auth.user)
\end{lstlisting}

Any function can be decorated, not just exposed actions. Of course this is still only a very simple example of access control. More complex examples will be discussed later.
\inxx{auth.user} \inxx{auth.user\_id} {\ft auth.user\_groups}.

\begin{quote}{\ft auth.user} contains a copy of the {\ft db.auth\_user} records for the current logged in user or {\ft None} otherwise. There is also a {\ft auth.user\_id} which is the same as {\ft auth.user.id} (i.e. the id of the current logger in user) or {\ft None}. Similarly, {\ft auth.user\_groups} contains a dictionary where each key is the id of a group of with the current logged in user is member of, the value is the corresponding group role.\end{quote}
\inxx{otherwise}

The {\ft auth.requires\_login()} decorator as well as the other {\ft auth.requires\_*} decorators take an optional {\ft otherwise} argument. It can be set to a string where to redirect the user if registration files or to a callable object. It is called if registration fails.

\goodbreak\subsection{Restrictions on registration}

If you want to allow visitors to register but not to log in until registration has been approved by the administrator:
\begin{lstlisting}
auth.settings.registration_requires_approval = True
\end{lstlisting}

You can approve a registration via the appadmin interface. Look into the table {\ft auth\_user}. Pending registrations have a {\ft registration\_key} field set to "pending". A registration is approved when this field is set to blank.

Via the appadmin interface, you can also block a user from logging in. Locate the user in the table {\ft auth\_user} and set the {\ft registration\_key} to "blocked". "blocked" users are not allowed to log in. Notice that this will prevent a visitor from logging in but it will not force a visitor who is already logged in to log out. The word "disabled" may be used instead of "blocked" if preferred, with exactly the same behavior.

You can also block access to the "register" page completely with this statement:
\begin{lstlisting}
auth.settings.actions_disabled.append('register')
\end{lstlisting}

If you want to allow people to register and automatically log them in after registration but still want to send an email for verification so that they cannot login again after logout, unless they completed the instructions in the email, you can accomplish it as follows:

\begin{lstlisting}
auth.settings.registration_requires_approval = True
auth.settings.login_after_registration = True
\end{lstlisting}

Other methods of {\bf Auth} can be restricted in the same way.

\goodbreak\subsection{Integration with OpenID, Facebook, etc.}

\inxx{Janrain} \inxx{OpenID} \inxx{Facebook} \inxx{LinkedIn} \inxx{Google} \inxx{MySpace} \inxx{Flickr}

You can use the web2py Role Base Access Control and authenticate with other services like OpenID, Facebook, LinkedIn, Google, Dropbox, MySpace, Flickr, etc.
The easiest way is to use Janrain Engage (formerly RPX) (Janrain.com).

Dropbox is discussed as a special case in Chapter 14 since it allows more than just login, it also provides storage services for the logged in users.

Janrain Engage is a service that provides middleware authentication. You can register with Janrain.com, register a domain (the name of your app) and set of URLs you will be using, and they will provide you with an API key.

Now edit the model of your web2py application and place the following lines somewhere after the definition of the {\ft auth} object :

\begin{lstlisting}
from gluon.contrib.login_methods.rpx_account import RPXAccount
auth.settings.actions_disabled=['register','change_password','request_reset_password']
auth.settings.login_form = RPXAccount(request,
    api_key='...',
    domain='...',
    url = "http://your-external-address/%s/default/user/login" % request.application)
\end{lstlisting}

The first line imports the new login method, the second line disables local registration, and the third line asks web2py to use the RPX login method. You must insert your own {\ft api\_key} provided by Janrain.com, the domain you choose upon registration and the external {\ft url} of your login page. To obtain then login at janrain.com, then go to [Deployment][Application Settings]. On the right side there is the "Application Info", The api\_key  is called "API Key (Secret)".

The domain is the "Application Domain" without leading "https://" and without the trailing ".rpxnow.com/"
For example: if you have registered a website as "secure.mywebsite.org", Janrain turns it to the Application Domain "https://secure-mywebsite.rpxnow.com".


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en6900.png}\end{center}


When a new user logins for the first time, web2py creates a new {\ft db.auth\_user} record associated to the user. It will use the {\ft registration\_id} field to store a unique id for the user. Most authentication methods will also provide a username, email, first\_name and last\_name but that is not guaranteed. Which fields are provided depends on the login method selected by the user. If the same user logs in twice using different authentication mechanisms (for example once with OpenID and once with Facebook), Janrain may not recognize his/her as the same user and issue different {\ft registration\_id}.

You can customize the mapping between the data provided by Janrain and the data stored in {\ft db.auth\_user}. Here is an example for Facebook:
\begin{lstlisting}
auth.settings.login_form.mappings.Facebook = lambda profile:\
            dict(registration_id = profile["identifier"],
                 username = profile["preferredUsername"],
                 email = profile["email"],
                 first_name = profile["name"]["givenName"],
                 last_name = profile["name"]["familyName"])
\end{lstlisting}

The keys in the dictionary are fields in {\ft db.auth\_user} and the values are data entries in the profile object provided by Janrain. Look at the online Janrain documentation for details on the latter.

Janrain will also keep statistics about your users' login.

This login form is fully integrated with web2py Role Based Access Control and you can still create groups, make users members of groups, assign permissions, block users, etc.

\begin{quote}Janrain's free Basic service allows up to 2500 unique registered users to sign in annually. Accommodating more users requires an upgrade to one of their paid service tiers.

If you prefer not to use Janrain and want to use a different login method (LDAP, PAM, Google, OpenID, OAuth/Facebook, LinkedIn, etc.) you can do so. The API to do so is described later in the chapter.\end{quote}
\goodbreak\subsection{CAPTCHA and reCAPTCHA}

\inxx{CAPTCHA} \inxx{reCAPTCHA} \inxx{PIL}
To prevent spammers and bots registering on your site, you may require a registration CAPTCHA. web2py supports reCAPTCHA~\cite{recaptcha}  out of the box. This is because reCAPTCHA is very well designed, free, accessible (it can read the words to the visitors), easy to set up, and does not require installing any third-party libraries.

This is what you need to do to use reCAPTCHA:
\begin{itemize}
\item Register with reCAPTCHA~\cite{recaptcha}  and obtain a (PUBLIC\_KEY, PRIVATE\_KEY) couple for your account. These are just two strings.

\item Append the following code to your model after the {\ft auth} object is defined:
\end{itemize}
\begin{lstlisting}
from gluon.tools import Recaptcha
auth.settings.captcha = Recaptcha(request,
    'PUBLIC_KEY', 'PRIVATE_KEY')
\end{lstlisting}
\noindent reCAPTCHA may not work if you access the web site as 'localhost' or '127.0.0.1', because it is registered to work with publicly visible web sites only.

The {\ft Recaptcha} constructor takes some optional arguments:
\begin{lstlisting}
Recaptcha(..., use_ssl=True, error_message='invalid', label='Verify:', options='')
\end{lstlisting}

Notice that {\ft use\_ssl=False} by default.

{\ft options} may be a configuration string, e.g. {\ft options="theme:'white', lang:'fr'"}

More details: {\footnotesize\href{http://www.google.com/recaptcha}{reCAPTCHA}}~\cite{recaptchagoogle}  and {\footnotesize\href{http://code.google.com/apis/recaptcha/docs/customization.html}{customizing}}.

If you do not want to use reCAPTCHA, look into the definition of the {\ft Recaptcha} class in "gluon/tools.py", since it is easy to use other CAPTCHA systems.

Notice that {\ft Recaptcha} is just a helper that extends {\ft DIV}. It generates a dummy field that validates using the {\ft reCaptcha} service and, therefore, it can be used in any form, including used defined FORMs:

\begin{lstlisting}
form = FORM(INPUT(...),Recaptcha(...),INPUT(_type='submit'))
\end{lstlisting}

You can use it in all types of SQLFORM by injection:

\begin{lstlisting}
form = SQLFORM(...) or SQLFORM.factory(...)
form.element('table').insert(-1,TR('',Recaptcha(...),''))
\end{lstlisting}

\goodbreak\subsection{Customizing {\ft Auth}}

The call to
\begin{lstlisting}
auth.define_tables()
\end{lstlisting}
\noindent defines all {\bf Auth} tables that have not been defined already. This means that if you wish to do so, you can define your own {\ft auth\_user} table.

There are a number of ways to customize auth. The simplest way is to add extra fields:

\begin{lstlisting}
## after auth = Auth(db)
auth.settings.extra_fields['auth_user']= [
  Field('address'),
  Field('city'),
  Field('zip'),
  Field('phone')]
## before auth.define_tables(username=True)
\end{lstlisting}

You can declare extra fields not just for table "auth\_user" but also for other "auth\_" tables.
Using {\ft extra\_fields} is the recommended way as it will not break any internal mechanism.

Another way to do this, although not really recommended, consists of defining your auth tables yourself. If a table is declared before {\ft auth.define\_tables()} it is used instead of the default one. Here is how to do it:

\begin{lstlisting}
## after auth = Auth(db)
db.define_table(
    auth.settings.table_user_name,
    Field('first_name', length=128, default=''),
    Field('last_name', length=128, default=''),
    Field('email', length=128, default='', unique=True), # required
    Field('password', 'password', length=512,            # required
          readable=False, label='Password'),
    Field('address'),
    Field('city'),
    Field('zip'),
    Field('phone'),
    Field('registration_key', length=512,                # required
          writable=False, readable=False, default=''),
    Field('reset_password_key', length=512,              # required
          writable=False, readable=False, default=''),
    Field('registration_id', length=512,                 # required
          writable=False, readable=False, default=''))

## do not forget validators
custom_auth_table = db[auth.settings.table_user_name] # get the custom_auth_table
custom_auth_table.first_name.requires = \
  IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.last_name.requires = \
  IS_NOT_EMPTY(error_message=auth.messages.is_empty)
custom_auth_table.password.requires = [IS_STRONG(), CRYPT()]
custom_auth_table.email.requires = [
  IS_EMAIL(error_message=auth.messages.invalid_email),
  IS_NOT_IN_DB(db, custom_auth_table.email)]

auth.settings.table_user = custom_auth_table # tell auth to use custom_auth_table

## before auth.define_tables()
\end{lstlisting}

You can add any field you wish, and you can change validators but you cannot remove
the fields marked as "required" in this example.

It is important to make "password", "registration\_key", "reset\_password\_key" and "registration\_id" fields {\ft readable=False} and {\ft writable=False}, since a visitor must not be allowed to tamper with them.

If you add a field called "username", it will be used in place of "email" for login. If you do, you will need to add a validator as well:
\begin{lstlisting}
auth_table.username.requires = IS_NOT_IN_DB(db, auth_table.username)
\end{lstlisting}

\goodbreak\subsection{Renaming {\ft Auth} tables}

The actual names of the {\ft Auth} tables are stored in
\begin{lstlisting}
auth.settings.table_user_name = 'auth_user'
auth.settings.table_group_name = 'auth_group'
auth.settings.table_membership_name = 'auth_membership'
auth.settings.table_permission_name = 'auth_permission'
auth.settings.table_event_name = 'auth_event'
\end{lstlisting}

The names of the table can be changed by reassigning the above variables after the {\ft auth} object is defined and before the Auth tables are defined. For example:
\begin{lstlisting}
auth = Auth(db)
auth.settings.table_user_name = 'person'
#...
auth.define_tables()
\end{lstlisting}

The actual tables can also be referenced, independently of their actual names, by
\begin{lstlisting}
auth.settings.table_user
auth.settings.table_group
auth.settings.table_membership
auth.settings.table_permission
auth.settings.table_event
\end{lstlisting}

\goodbreak\subsection{Other login methods and login forms}

\inxx{LDAP} \inxx{PAM}

Auth provides multiple login methods and hooks to create new login methods. Each supported login method corresponds to a file in the folder
\begin{lstlisting}
gluon/contrib/login_methods/
\end{lstlisting}

Refer to the documentation in the files themselves for each login method, but here are some examples.

First of all, we need to make a distinction between two types of alternate login methods:
\begin{itemize}
\item login methods that use a web2py login form (although the credentials are verified outside web2py). An example is LDAP.

\item login methods that require an external single-sign-on form (an example is Google and Facebook).
\end{itemize}

In the latter case, web2py never gets the login credentials, only a login token issued by the service provider. The token is stored in {\ft db.auth\_user.registration\_id}.

Let's consider examples of the first case:

{\bf Basic}

Let's say you have an authentication service, for example at the url

\begin{lstlisting}[keywords={}]
https://basic.example.com
\end{lstlisting}
\noindent that accepts basic access authentication. That means the server accepts HTTP requests with a header of the form:

\begin{lstlisting}
GET /index.html HTTP/1.0
Host: basic.example.com
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
\end{lstlisting}
\noindent where the latter string is the base64 encoding of the string username:password. The service responds 200 OK if the user is authorized and 400, 401, 402, 403 or 404 otherwise.

You want to enter username and password using the standard {\ft Auth} login form and verify the credentials against such a service. All you need to do is add the following code to your application
\begin{lstlisting}
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods.append(
    basic_auth('https://basic.example.com'))
\end{lstlisting}

Notice that {\ft auth.settings.login\_methods} is a list of authentication methods that are executed sequentially.
By default it is set to
\begin{lstlisting}
auth.settings.login_methods = [auth]
\end{lstlisting}

When an alternate method is appended, for example {\ft basic\_auth}, {\bf Auth} first tries to log in the visitor based on the content of {\ft auth\_user}, and when this fails, it tries the next method in the list. If a method succeeds in logging in the visitor, and if {\ft auth.settings.login\_methods[0]==auth}, {\ft Auth} takes the following actions:
\begin{itemize}
\item if the user does not exist in {\ft auth\_user}, a new user is created and the username/email and passwords are stored.

\item if the user does exist in {\ft auth\_user} but the new accepted password does not match the old stored password, the old password is replaced with the new one (notice that passwords are always stored hashed unless specified otherwise).
\end{itemize}

If you do not wish to store the new password in {\ft auth\_user}, then it is sufficient to change the order of login methods, or remove {\ft auth} from the list. For example:
\begin{lstlisting}
from gluon.contrib.login_methods.basic_auth import basic_auth
auth.settings.login_methods = \
    [basic_auth('https://basic.example.com')]
\end{lstlisting}

The same applies for any other login method described here.

{\bf SMTP and Gmail}

\inxx{SMTP} \inxx{Gmail}

You can verify login credentials using a remote SMTP server, for example Gmail; i.e., you log the user in if the email and password they provide are valid credentials to access the Gmail SMTP server ({\ft smtp.gmail.com:587}). All that is needed is the following code:
\begin{lstlisting}
from gluon.contrib.login_methods.email_auth import email_auth
auth.settings.login_methods.append(
    email_auth("smtp.gmail.com:587", "@gmail.com"))
\end{lstlisting}

The first argument of {\ft email\_auth} is the address:port of the SMTP server. The second argument is the email domain.

This works with any SMTP server that requires TLS authentication.\inxx{TLS}

{\bf PAM}

\inxx{PAM}

Authentication using Pluggable Authentication Modules (PAM) works as in the previous cases. It allows web2py to authenticate users using the operating system accounts:
\begin{lstlisting}
from gluon.contrib.login_methods.pam_auth import pam_auth
auth.settings.login_methods.append(pam_auth())
\end{lstlisting}

{\bf LDAP}

\inxx{LDAP}

Authentication using LDAP works very much as in the previous cases.

To use LDAP login with MS Active Directory:\inxx{Active Directory}
\begin{lstlisting}
from gluon.contrib.login_methods.ldap_auth import ldap_auth
auth.settings.login_methods.append(ldap_auth(mode='ad',
   server='my.domain.controller',
   base_dn='ou=Users,dc=domain,dc=com'))
\end{lstlisting}

To use LDAP login with Lotus Notes and Domino:\inxx{Lotus Notes} \inxx{Domino}
\begin{lstlisting}
auth.settings.login_methods.append(ldap_auth(mode='domino',
   server='my.domino.server'))
\end{lstlisting}

To use LDAP login with OpenLDAP (with UID):\inxx{OpenLDAP}
\begin{lstlisting}
auth.settings.login_methods.append(ldap_auth(server='my.ldap.server',
   base_dn='ou=Users,dc=domain,dc=com'))
\end{lstlisting}

To use LDAP login with OpenLDAP (with CN):
\begin{lstlisting}
auth.settings.login_methods.append(ldap_auth(mode='cn',
   server='my.ldap.server', base_dn='ou=Users,dc=domain,dc=com'))
\end{lstlisting}

{\bf Google App Engine}

\inxx{GAE login}

Authentication using Google when running on Google App Engine requires skipping the web2py login form, being redirected to the Google login page, and back upon success. Because the behavior is different than in the previous examples, the API is a little different.

\begin{lstlisting}
from gluon.contrib.login_methods.gae_google_login import GaeGoogleAccount
auth.settings.login_form = GaeGoogleAccount()
\end{lstlisting}

{\bf OpenID}

\inxx{OpenID}

We have previously discussed integration with Janrain (which has OpenID support) and that is the easiest way to use OpenID. Yet sometimes you do not want to rely on a third party service and you want to access the OpenID provider directly from the consumer (your app).

Here is an example:

\begin{lstlisting}
from gluon.contrib.login_methods.openid_auth import OpenIDAuth
auth.settings.login_form = OpenIDAuth(auth)
\end{lstlisting}

{\ft OpenIDAuth} requires the {\it python-openid} module to be installed separately. Under the hood, this login method defines the following table:

\begin{lstlisting}
db.define_table('alt_logins',
    Field('username', length=512, default=''),
    Field('type', length =128, default='openid', readable=False),
    Field('user', self.table_user, readable=False))
\end{lstlisting}
\noindent which stores the openid usernames for each user. If you want to display the openids for the current logged in user:

\begin{lstlisting}[keywords={}]
{{=auth.settings.login_form.list_user_openids()}}
\end{lstlisting}

{\bf OAuth2.0 and Facebook}

\inxx{OAuth} \inxx{Facebook}

We have previously discussed integration with Janrain (which has Facebook support), yet sometimes you do not want to rely on a third party service and you want to access a OAuth2.0 provider directly; for example, Facebook. Here is how:

\begin{lstlisting}
from gluon.contrib.login_methods.oauth20_account import OAuthAccount
auth.settings.login_form=OAuthAccount(YOUR_CLIENT_ID,YOUR_CLIENT_SECRET)
\end{lstlisting}

Things get a little more complex if you want to use Facebook OAuth2.0 to login into a specific Facebook app to access its API, instead of your own app. Here is an example for accessing the Facebook Graph API.

First of all you must install the {\footnotesize\href{https://github.com/pythonforfacebook/facebook-sdk/}{Facebook Python SDK}}.

Second, you need the following code in your model:

\begin{lstlisting}
## import required modules
from facebook import GraphAPI
from gluon.contrib.login_methods.oauth20_account import OAuthAccount
## extend the OAUthAccount class
class FaceBookAccount(OAuthAccount):
    """OAuth impl for Facebook"""
    AUTH_URL="https://graph.facebook.com/oauth/authorize"
    TOKEN_URL="https://graph.facebook.com/oauth/access_token"
    def __init__(self, g):
        OAuthAccount.__init__(self, g,
                              YOUR_CLIENT_ID,
                              YOUR_CLIENT_SECRET,
                              self.AUTH_URL,
                              self.TOKEN_URL)
        self.graph = None
    # override function that fetches user info
    def get_user(self):
        "Returns the user using the Graph API"
        if not self.accessToken():
            return None
        if not self.graph:
            self.graph = GraphAPI((self.accessToken()))
        try:
            user = self.graph.get_object("me")
            return dict(first_name = user['first_name'],
                        last_name = user['last_name'],
                        username = user['id'])
        except GraphAPIError:
            self.session.token = None
            self.graph = None
            return None
## use the above class to build a new login form
auth.settings.login_form=FaceBookAccount()
\end{lstlisting}

{\bf LinkedIn}

\inxx{LinkedIn}

We have previously discussed integration with Janrain (which has LinkedIn support) and that is the easiest way to use OAuth. Yet sometime you do not want to rely on a third party service or you may want to access LinkedIn directly to get more information than Janrain provides.

Here is an example:

\begin{lstlisting}
from gluon.contrib.login_methods.linkedin_account import LinkedInAccount
auth.settings.login_form=LinkedInAccount(request,KEY,SECRET,RETURN_URL)
\end{lstlisting}

{\ft LinkedInAccount} requires the "python-linkedin" module installed separately.

{\bf X509}

You can also login by passing to the page an x509 certificate and your credential will be extracted from the certificate. This requires {\ft M2Crypto} installed from

\begin{lstlisting}[keywords={}]
http://chandlerproject.org/bin/view/Projects/MeTooCrypto
\end{lstlisting}

Once you have M2Cryption installed you can do:

\begin{lstlisting}
from gluon.contrib.login_methods.x509_auth import X509Account
auth.settings.actions_disabled=['register','change_password','request_reset_password']
auth.settings.login_form = X509Account()
\end{lstlisting}

You can now authenticate into web2py passing your x509 certificate. How to do this is browser-dependent, but probably you are more likely to use certificates for web services. In this case you can use for example {\ft cURL} to try out your authentication:

\begin{lstlisting}
curl -d "firstName=John&lastName=Smith" -G -v --key private.key \
     --cert  server.crt https://example/app/default/user/profile
\end{lstlisting}

This works out of the box with Rocket (the web2py built-in web server) but you may need some extra configuration work on the web server side if you are using a different web server. In particular you need to tell your web server where the certificates are located on local host and that it needs to verify certificates coming from the clients. How to do it is web server dependent and therefore omitted here.

{\bf Multiple login forms}

Some login methods modify the login\_form, some do not. When they do that, they may not be able to coexist. Yet some coexist by providing multiple login forms in the same page. web2py provides a way to do it. Here is an example mixing normal login (auth) and RPX login (janrain.com):

\begin{lstlisting}
from gluon.contrib.login_methods.extended_login_form import ExtendedLoginForm
other_form = RPXAccount(request, api_key='...', domain='...', url='...')
auth.settings.login_form = ExtendedLoginForm(auth, other_form, signals=['token'])
\end{lstlisting}

If signals are set and a parameter in request matches any signals,
it will return the call of {\ft other\_form.login\_form} instead.
{\ft other\_form} can handle some particular situations, for example,
multiple steps of OpenID login inside {\ft other\_form.login\_form}.

Otherwise it will render the normal login form together with the {\ft other\_form}.

\goodbreak\subsection{Record versioning}

You can use Auth to enable full record versioning:

\begin{lstlisting}
db.enable_record_versioning(db,
    archive_db=None,
    archive_names='%(tablename)s_archive',
    current_record='current_record'):
\end{lstlisting}

This tells web2py to create an archive table for each of the tables in {\ft db} and store a copy of each record when modified. The old copy is stored. The new copy is not.

The last three parameters are optional:

\begin{itemize}
\item {\ft archive\_db} allows to specify another database where the archive tables are to be stored. Setting it to {\ft None} is the same as setting it to {\ft db}.

\item {\ft archive\_names} provides a pattern for naming each archive table.

\item {\ft current\_record} specified the name of the reference field to be used in the archive table to refer to the original, unmodified, record. Notice that {\ft archive\_db!=db} then the reference field is just an integer field since cross database references are not possible.
\end{itemize}

Only tables with {\ft modified\_by} and {\ft modified\_on} fields (as created
for example by auth.signature) will be archived.

When you {\ft enable\_record\_versioning}, if records have an
{\ft is\_active} field (also created by auth.signature),
records will never be deleted but they will be marked with {\ft is\_active=False}.
In fact, {\ft enable\_record\_versioning} adds a {\ft common\_filter} to
every versioned table that filters out records with {\ft is\_active=False} so they essentially become invisible.

If you {\ft enable\_record\_versioning}, you should not use
{\ft auth.archive} or {\ft crud.archive} else you will end up with duplicate records.
Those functions do explicitly what {\ft enable\_record\_versioning} does automatically and
they will be deprecated.

\goodbreak\subsection{{\ft Mail} and {\ft Auth}}

One can define a mailer with

\begin{lstlisting}
from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'

\end{lstlisting}
\noindent or simply use the mailer provided by {\ft auth}:

\begin{lstlisting}
mail = auth.settings.mailer
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'
\end{lstlisting}

You need to replace the mail.settings with the proper parameters for your SMTP server. Set {\ft mail.settings.login = None} if the SMTP server does not require authentication. If you don't want to use TLS, set {\ft mail.settings.tls = False}

You can read more about web2py API for emails and email configuration in Chapter 8. Here we limit the discussion to the interaction between {\ft Mail} and {\ft Auth}.

In {\ft Auth}, by default, email verification is disabled.
To enable email, append the following lines in the model where {\ft auth} is defined:

\begin{lstlisting}
auth.settings.registration_requires_verification = True
auth.settings.registration_requires_approval = False
auth.settings.reset_password_requires_verification = True
auth.messages.verify_email = 'Click on the link http://' + \
    request.env.http_host + \
    URL(r=request,c='default',f='user',args=['verify_email']) + \
    '/%(key)s to verify your email'
auth.messages.reset_password = 'Click on the link http://' + \
    request.env.http_host + \
    URL(r=request,c='default',f='user',args=['reset_password']) + \
    '/%(key)s to reset your password'
\end{lstlisting}

In the two {\ft auth.messages} above, you may need to replace the URL portion of the string with the proper complete URL of the action. This is necessary because web2py may be installed behind a proxy, and it cannot determine its own public URLs with absolute certainty. The above examples (which are the default values) should, however, work in most cases.

\goodbreak\section{Authorization}

Once a new user is registered, a new group is created to contain the user. The role of the new user is conventionally "user\_[id]" where [id] is the id of the newly created user. The creation of the group can be disabled with
\begin{lstlisting}
auth.settings.create_user_groups = None
\end{lstlisting}
\noindent although we do not suggest doing so. Notice that {\ft create\_user\_groups} is not a boolean (although it can be {\ft False}) but it defaults to:

\begin{lstlisting}
auth.settings.create_user_groups="user_%(id)s"
\end{lstlisting}

It store a template for the name of the group created for user {\ft id}.

Users have membership in groups. Each group is identified by a name/role. Groups have permissions. Users have permissions because of the groups they belong to. By default each user is made member of their own group.

You can also do
\begin{lstlisting}
auth.settings.everybody_group_id = 5
\end{lstlisting}
\noindent to make any new user automatically member of group number 5. Here 5 is used as an example and we assume the group was created already.

You can create groups, give membership and permissions via {\bf appadmin}
or programmatically using the following methods:
\begin{lstlisting}
auth.add_group('role', 'description')
\end{lstlisting}
\noindent returns the id of the newly created group.

\begin{lstlisting}
auth.del_group(group_id)
\end{lstlisting}
\noindent deletes the group with {\ft group\_id}.

\begin{lstlisting}
auth.del_group(auth.id_group('user_7'))
\end{lstlisting}
\noindent deletes the group with role "user\_7", i.e., the group uniquely associated to user number 7.

\begin{lstlisting}
auth.user_group(user_id)
\end{lstlisting}
\noindent returns the id of the group uniquely associated to the user identified by {\ft user\_id}.

\begin{lstlisting}
auth.add_membership(group_id, user_id)
\end{lstlisting}
\noindent gives {\ft user\_id} membership of the group {\ft group\_id}.
If the {\ft user\_id} is not specified, then web2py assumes the current logged-in user.

\begin{lstlisting}
auth.del_membership(group_id, user_id)
\end{lstlisting}
\noindent revokes {\ft user\_id} membership of the group {\ft group\_id}.
If the {\ft user\_id} is not specified, then web2py assumes the current logged-in user.

\begin{lstlisting}
auth.has_membership(group_id, user_id, role)
\end{lstlisting}
\noindent checks whether {\ft user\_id} has membership of the group {\ft group\_id} or the group with the specified role. Only {\ft group\_id} or {\ft role} should be passed to the function, not both. If the {\ft user\_id} is not specified, then web2py assumes the current logged-in user.

\begin{lstlisting}
auth.add_permission(group_id, 'name', 'object', record_id)
\end{lstlisting}
\noindent gives permission "name" (user defined) on the object "object" (also user defined) to members of the group {\ft group\_id}. If "object" is a tablename then the permission can refer to the entire table by setting {\ft record\_id} to a value of zero, or the permission can refer to a specific record by specifying a {\ft record\_id} value greater than zero. When giving permissions on tables, it is common to use a permission name in the set ('create', 'read', 'update', 'delete', 'select') since these permissions are understood and can be enforced by the CRUD APIs.

If {\ft group\_id} is zero, web2py uses the group uniquely associated to the current logged-in user.

You can also use {\ft auth.id\_group(role="...")} to get the id of a group given its name. \inxx{id\_group}

\begin{lstlisting}
auth.del_permission(group_id, 'name', 'object', record_id)
\end{lstlisting}
\noindent revokes the permission.

\begin{lstlisting}
auth.has_permission('name', 'object', record_id, user_id)
\end{lstlisting}
\noindent checks whether the user identified by {\ft user\_id} has membership in a group with the requested permission.

\begin{lstlisting}
rows = db(auth.accessible_query('read', db.mytable, user_id))\
    .select(db.mytable.ALL)
\end{lstlisting}
\noindent returns all rows of table "mytable" that user {\ft user\_id} has "read" permission on.
If the {\ft user\_id} is not specified, then web2py assumes the current logged-in user.
The {\ft accessible\_query(...)} can be combined with other queries to make more complex ones.
{\ft accessible\_query(...)} is the only {\bf Auth} method to require a JOIN, so it does not work on the Google App Engine.

Assuming the following definitions:
\begin{lstlisting}
>>> from gluon.tools import Auth
>>> auth = Auth(db)
>>> auth.define_tables()
>>> secrets = db.define_table('document', Field('body'))
>>> james_bond = db.auth_user.insert(first_name='James',
                                     last_name='Bond')
\end{lstlisting}

Here is an example:
\begin{lstlisting}
>>> doc_id = db.document.insert(body = 'top secret')
>>> agents = auth.add_group(role = 'Secret Agent')
>>> auth.add_membership(agents, james_bond)
>>> auth.add_permission(agents, 'read', secrets)
>>> print auth.has_permission('read', secrets, doc_id, james_bond)
True
>>> print auth.has_permission('update', secrets, doc_id, james_bond)
False
\end{lstlisting}

\goodbreak\subsection{Decorators}

The most common way to check permission is not by explicit calls to the above methods, but by decorating functions so that permissions are checked relative to the logged-in visitor. Here are some examples:
\begin{lstlisting}
def function_one():
    return 'this is a public function'

@auth.requires_login()
def function_two():
    return 'this requires login'

@auth.requires_membership('agents')
def function_three():
    return 'you are a secret agent'

@auth.requires_permission('read', secrets)
def function_four():
    return 'you can read secret documents'

@auth.requires_permission('delete', 'any file')
def function_five():
    import os
    for file in os.listdir('./'):
        os.unlink(file)
    return 'all files deleted'

@auth.requires(auth.user_id==1 or request.client=='127.0.0.1', requires_login=True)
def function_six():
    return 'you can read secret documents'

@auth.requires_permission('add', 'number')
def add(a, b):
    return a + b

def function_seven():
    return add(3, 4)
\end{lstlisting}

The condition argument of {\ft @auth.requires(condition)} can be a callable and unless the condition is simple, it better to pass a callable than a condition since this will be faster, as the condition will only be evaluated if needed. For example

\begin{lstlisting}
@auth.requires(lambda: check_condition())
def action():
    ....
\end{lstlisting}

{\ft @auth.requires} also takes an optional argument {\ft requires\_login} which defaults to {\ft True}. If set to False, it does not require login before evaluating the condition as true/false. The condition can be a boolean value or a function evaluating to boolean.

Note that access to all functions apart from the first one is restricted based on permissions that the visitor may or may not have.

If the visitor is not logged in, then the permission cannot be checked; the visitor is redirected to the login page and then back to the page that requires permissions.

\goodbreak\subsection{Combining requirements}

Occasionally, it is necessary to combine requirements. This can be done via a generic {\ft requires} decorator which takes a single argument, a true or false condition. For example, to give access to agents, but only on Tuesday:
\begin{lstlisting}
@auth.requires(auth.has_membership(group_id='agents' \
               and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
\end{lstlisting}
\noindent or equivalently:
\begin{lstlisting}
@auth.requires(auth.has_membership(role='Secret Agent') \
               and request.now.weekday()==1)
def function_seven():
    return 'Hello agent, it must be Tuesday!'
\end{lstlisting}

\goodbreak\subsection{Authorization and CRUD}

Using decorators and/or explicit checks provides one way to implement access control.

Another way to implement access control is to always use CRUD (as opposed to {\ft SQLFORM}) to access the database and to ask CRUD to enforce access control on database tables and records. This is done by linking {\ft Auth} and CRUD with the following statement:
\begin{lstlisting}
crud.settings.auth = auth
\end{lstlisting}

This will prevent the visitor from accessing any of the CRUD functions unless the visitor is logged in and has explicit access. For example, to allow a visitor to post comments, but only update their own comments (assuming crud, auth and db.comment are defined):
\begin{lstlisting}
def give_create_permission(form):
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'read', db.comment)
    auth.add_permission(group_id, 'create', db.comment)
    auth.add_permission(group_id, 'select', db.comment)

def give_update_permission(form):
    comment_id = form.vars.id
    group_id = auth.id_group('user_%s' % auth.user.id)
    auth.add_permission(group_id, 'update', db.comment, comment_id)
    auth.add_permission(group_id, 'delete', db.comment, comment_id)

auth.settings.register_onaccept = give_create_permission
crud.settings.auth = auth

def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   comments = db(db.comment).select()
   return dict(form=form, comments=comments)

def update_comment():
   form = crud.update(db.comment, request.args(0))
   return dict(form=form)
\end{lstlisting}

You can also select specific records (those you have 'read' access to):
\begin{lstlisting}
def post_comment():
   form = crud.create(db.comment, onaccept=give_update_permission)
   query = auth.accessible_query('read', db.comment, auth.user.id)
   comments = db(query).select(db.comment.ALL)
   return dict(form=form, comments=comments)
\end{lstlisting}

The permissions names enforced by :

\begin{lstlisting}
crud.settings.auth = auth
\end{lstlisting}
\noindent are "read", "create", "update", "delete", "select", "impersonate".

\goodbreak\subsection{Authorization and downloads}

The use of decorators and the use of {\ft crud.settings.auth} do not enforce authorization on files downloaded by the usual download function
\begin{lstlisting}
def download(): return response.download(request, db)
\end{lstlisting}

If one wishes to do so, one must declare explicitly which "upload" fields contain files that need access control upon download.
For example:
\begin{lstlisting}
db.define_table('dog',
   Field('small_image', 'upload'),
   Field('large_image', 'upload'))

db.dog.large_image.authorization = lambda record: \
   auth.is_logged_in() and \
   auth.has_permission('read', db.dog, record.id, auth.user.id)
\end{lstlisting}

The attribute {\ft authorization} of upload field can be None (the default) or a function that decides whether the user is logged in and has permission to 'read' the current record. In this example, there is no restriction on downloading images linked by the "small\_image" field, but we require access control on images linked by the "large\_image" field.

\goodbreak\subsection{Access Control and Basic Authentication}

Occasionally, it may be necessary to expose actions that have decorators that require access control as services; i.e., to call them from a program or script and still be able to use authentication to check for authorization.

{\bf Auth} enables login via basic authentication:
\begin{lstlisting}
auth.settings.allow_basic_login = True
\end{lstlisting}

With this set, an action like
\begin{lstlisting}
@auth.requires_login()
def give_me_time():
    import time
    return time.ctime()
\end{lstlisting}
\noindent can be called, for example, from a shell command:
\begin{lstlisting}
wget --user=[username] --password=[password]
    http://.../[app]/[controller]/give_me_time
\end{lstlisting}

It is also possible to log in by calling {\ft auth.basic()} rather than using an {\ft @auth} decorator:
\begin{lstlisting}
def give_me_time():
    import time
    auth.basic()
    if auth.user:
        return time.ctime()
    else:
        return 'Not authorized'
\end{lstlisting}

Basic login is often the only option for services (described in the next chapter), but it is disabled by default.

\goodbreak\subsection{Manual Authentication}

Some times you want to implement your own logic and do "manual" user login.
This can also be done by calling the function:

\begin{lstlisting}
user = auth.login_bare(username,password)
\end{lstlisting}

{\ft login\_bare} returns user if the user exists and the password is valid, else it returns False. {\ft username} is the email if the "auth\_user" table does not have a "username" field.

\goodbreak\subsection{Settings and messages}

Here is a list of all parameters that can be customized for {\bf Auth}

The following must point to a {\ft gluon.tools.Mail} object to allow {\ft auth} to send emails:

\begin{lstlisting}
auth.settings.mailer = None
\end{lstlisting}

The following must be the name of the controller that defined the {\ft user} action:

\begin{lstlisting}
auth.settings.controller = 'default'
\end{lstlisting}

The following is a very important setting:

\begin{lstlisting}
auth.settings.hmac_key = None
\end{lstlisting}

It must be set to something like "sha512:a-pass-phrase" and it will be passed to the CRYPT validator for the "password" field of the {\ft auth\_user} table. It will be the algorithm and a-pass-phrase used to hash the passwords.

By default, auth also requires a minimum password length of 4. This can be changed:
\begin{lstlisting}
auth.settings.password_min_length = 4
\end{lstlisting}

To disabled an action append its name to this list:
\begin{lstlisting}
auth.settings.actions_disabled = []
\end{lstlisting}

For example:

\begin{lstlisting}
auth.settings.actions_disabled.append('register')
\end{lstlisting}
\noindent will disable registration.

If you want to receive an email to verify registration set this to {\ft True}:

\begin{lstlisting}
auth.settings.registration_requires_verification = False
\end{lstlisting}

To automatically login people after registration, even if they have not completed the email verification process, set the following to {\ft True}:

\begin{lstlisting}
auth.settings.login_after_registration = False
\end{lstlisting}

If new registrants must wait for approval before being able to login set this to {\ft True}:

\begin{lstlisting}
auth.settings.registration_requires_approval = False
\end{lstlisting}

Approval consists of setting {\ft registration\_key==''} via appadmin or programmatically.

If you do not want a new group for each new user set the following to {\ft False}:

\begin{lstlisting}
auth.settings.create_user_groups = True
\end{lstlisting}

The following settings determine alternative login methods and login forms, as discussed previously:

\begin{lstlisting}
auth.settings.login_methods = [auth]
auth.settings.login_form = auth
\end{lstlisting}

Do you want to allow basic login?

\begin{lstlisting}
auth.settings.allows_basic_login = False
\end{lstlisting}

The following is the URL of the {\ft login} action:

\begin{lstlisting}
auth.settings.login_url = URL('user', args='login')
\end{lstlisting}

If the user tried to access the register page but is already logged in, he will be redirected to this URL:

\begin{lstlisting}
auth.settings.logged_url = URL('user', args='profile')
\end{lstlisting}

This must point to the URL of the download action, in case the profile contains images:

\begin{lstlisting}
auth.settings.download_url = URL('download')
\end{lstlisting}

These must point to the URL you want to redirect your users to after the various possible {\ft auth} actions (in case there is no referrer):

\begin{lstlisting}
auth.settings.login_next = URL('index')
auth.settings.logout_next = URL('index')
auth.settings.profile_next = URL('index')
auth.settings.register_next = URL('user', args='login')
auth.settings.retrieve_username_next = URL('index')
auth.settings.retrieve_password_next = URL('index')
auth.settings.change_password_next = URL('index')
auth.settings.request_reset_password_next = URL('user', args='login')
auth.settings.reset_password_next = URL('user', args='login')
auth.settings.verify_email_next = URL('user', args='login')
\end{lstlisting}

If the visitor is not logger in, and calls a function that requires authentication,
the user is redirected to {\ft auth.settings.login\_url} which defaults to {\ft URL('default','user/login')}.
One can replace this behavior by redefining:
\inxx{on\_failed\_authentication}

\begin{lstlisting}
auth.settings.on_failed_authentication = lambda url: redirect(url)
\end{lstlisting}

This is the function called for the redirection. The argument {\ft url}' passed to this function is the url for the login page.

If the visitor does not have permission to access a given function, the visitor is redirect to the URL defined by
\inxx{on\_failed\_authorization}

\begin{lstlisting}
auth.settings.on_failed_authorization = \
    URL('user',args='on_failed_authorization')
\end{lstlisting}

You can change this variable and redirect the user elsewhere.

Often {\ft on\_failed\_authorization} is a URL but it can be a function that returns the URL and it will be called on failed authorization.

These are lists of callbacks that should be executed after form validation for each of the corresponding action before any database IO:

\begin{lstlisting}
auth.settings.login_onvalidation = []
auth.settings.register_onvalidation = []
auth.settings.profile_onvalidation = []
auth.settings.retrieve_password_onvalidation = []
auth.settings.reset_password_onvalidation = []
\end{lstlisting}

Each callback must be a function that takes the {\ft form} object and it can modify the attributes of the form object before database IO is performed.

These are lists of callbacks that should be executed after the database IO is performed and before redirection:

\begin{lstlisting}
auth.settings.login_onaccept = []
auth.settings.register_onaccept = []
auth.settings.profile_onaccept = []
auth.settings.verify_email_onaccept = []
\end{lstlisting}

Here is an example:

\begin{lstlisting}
auth.settings.register_onaccept.append(lambda form:\
   mail.send(to='you@example.com',subject='new user',
             message='new user email is %s'%form.vars.email))
\end{lstlisting}

You can enable captcha for any of the {\ft auth} actions:

\begin{lstlisting}
auth.settings.captcha = None
auth.settings.login_captcha = None
auth.settings.register_captcha = None
auth.settings.retrieve_username_captcha = None
auth.settings.retrieve_password_captcha = None
\end{lstlisting}

If the {\ft .captcha} settings points to a {\ft gluon.tools.Recaptcha}, all forms for which the corresponding option (like {\ft .login\_captcha}) is set to {\ft None} will have a captcha, while those for which the corresponding option is set to {\ft False} will not. If, instead, {\ft .captcha} is set to {\ft None}, only those form who have a corresponding option set to a {\ft gluon.tools.Recaptcha} object will have captcha and the others will not.

This is the login session expiration time:

\begin{lstlisting}
auth.settings.expiration = 3600  # seconds
\end{lstlisting}

You can change the name of the password field (in Firebird for example "password" is a keyword and cannot be used to name a field):

\begin{lstlisting}
auth.settings.password_field = 'password'
\end{lstlisting}

Normally the login form tries to validate an email. This can be disabled by changing this setting:

\begin{lstlisting}
auth.settings.login_email_validate = True
\end{lstlisting}

Do you want to show the record id in the edit profile page?

\begin{lstlisting}
auth.settings.showid = False
\end{lstlisting}

For custom forms you may want to disable automatic error notification in forms:

\begin{lstlisting}
auth.settings.hideerror = False
\end{lstlisting}

Also for custom forms you can change the style:

\begin{lstlisting}
auth.settings.formstyle = 'table3cols'
\end{lstlisting}

(it can be "table2cols", "divs" and "ul")

And you can set the separator for auth-generated forms:

\begin{lstlisting}
auth.settings.label_separator =        ':'
\end{lstlisting}

By default the login form gives the option to extend the login via "remember me" option. The expiration time can be changed or the option disabled via these settings:

\begin{lstlisting}
auth.settings.long_expiration = 3600*24*30 # one month
auth.settings.remember_me_form = True
\end{lstlisting}

You can also customize the following messages whose use and context should be obvious:
\begin{lstlisting}
auth.messages.submit_button = 'Submit'
auth.messages.verify_password = 'Verify Password'
auth.messages.delete_label = 'Check to delete:'
auth.messages.function_disabled = 'Function disabled'
auth.messages.access_denied = 'Insufficient privileges'
auth.messages.registration_verifying = 'Registration needs verification'
auth.messages.registration_pending = 'Registration is pending approval'
auth.messages.login_disabled = 'Login disabled by administrator'
auth.messages.logged_in = 'Logged in'
auth.messages.email_sent = 'Email sent'
auth.messages.unable_to_send_email = 'Unable to send email'
auth.messages.email_verified = 'Email verified'
auth.messages.logged_out = 'Logged out'
auth.messages.registration_successful = 'Registration successful'
auth.messages.invalid_email = 'Invalid email'
auth.messages.unable_send_email = 'Unable to send email'
auth.messages.invalid_login = 'Invalid login'
auth.messages.invalid_user = 'Invalid user'
auth.messages.is_empty = "Cannot be empty"
auth.messages.mismatched_password = "Password fields don't match"
auth.messages.verify_email = ...
auth.messages.verify_email_subject = 'Password verify'
auth.messages.username_sent = 'Your username was emailed to you'
auth.messages.new_password_sent = 'A new password was emailed to you'
auth.messages.password_changed = 'Password changed'
auth.messages.retrieve_username = 'Your username is: %(username)s'
auth.messages.retrieve_username_subject = 'Username retrieve'
auth.messages.retrieve_password = 'Your password is: %(password)s'
auth.messages.retrieve_password_subject = 'Password retrieve'
auth.messages.reset_password = ...
auth.messages.reset_password_subject = 'Password reset'
auth.messages.invalid_reset_password = 'Invalid reset password'
auth.messages.profile_updated = 'Profile updated'
auth.messages.new_password = 'New password'
auth.messages.old_password = 'Old password'
auth.messages.group_description = \
    'Group uniquely assigned to user %(id)s'
auth.messages.register_log = 'User %(id)s Registered'
auth.messages.login_log = 'User %(id)s Logged-in'
auth.messages.logout_log = 'User %(id)s Logged-out'
auth.messages.profile_log = 'User %(id)s Profile updated'
auth.messages.verify_email_log = 'User %(id)s Verification email sent'
auth.messages.retrieve_username_log = 'User %(id)s Username retrieved'
auth.messages.retrieve_password_log = 'User %(id)s Password retrieved'
auth.messages.reset_password_log = 'User %(id)s Password reset'
auth.messages.change_password_log = 'User %(id)s Password changed'
auth.messages.add_group_log = 'Group %(group_id)s created'
auth.messages.del_group_log = 'Group %(group_id)s deleted'
auth.messages.add_membership_log = None
auth.messages.del_membership_log = None
auth.messages.has_membership_log = None
auth.messages.add_permission_log = None
auth.messages.del_permission_log = None
auth.messages.has_permission_log = None
auth.messages.label_first_name = 'First name'
auth.messages.label_last_name = 'Last name'
auth.messages.label_username = 'Username'
auth.messages.label_email = 'E-mail'
auth.messages.label_password = 'Password'
auth.messages.label_registration_key = 'Registration key'
auth.messages.label_reset_password_key = 'Reset Password key'
auth.messages.label_registration_id = 'Registration identifier'
auth.messages.label_role = 'Role'
auth.messages.label_description = 'Description'
auth.messages.label_user_id = 'User ID'
auth.messages.label_group_id = 'Group ID'
auth.messages.label_name = 'Name'
auth.messages.label_table_name = 'Table name'
auth.messages.label_record_id = 'Record ID'
auth.messages.label_time_stamp = 'Timestamp'
auth.messages.label_client_ip = 'Client IP'
auth.messages.label_origin = 'Origin'
auth.messages.label_remember_me = "Remember me (for 30 days)"
\end{lstlisting}
{\ft add|del|has} membership logs allow the use of "\%(user\_id)s" and "\%(group\_id)s".
{\ft add|del|has} permission logs allow the use of "\%(user\_id)s", "\%(name)s", "\%(table\_name)s", and "\%(record\_id)s".

\goodbreak\section{Central Authentication Service}

\inxx{CAS} \inxx{authentication}
\noindent web2py provides support for third party authentication and single sign on.
Here we discuss the Central Authentication Service (CAS) which is an industry standard and both client and server are built-into web2py.

CAS is an open protocol for distributed authentication and it works in the following way: When a visitor arrives at our web site, our application check in the session if the user is already authenticated (for example via a {\ft session.token} object). If the user is not authenticated, the controller redirects the visitor from the CAS appliance, where the user can log in, register, and manage his credentials (name, email and password). If the user registers, he receives an email, and registration is not complete until he responds to the email. Once the user has successfully registered and logged in, the CAS appliance redirects the user to our application together with a key. Our application uses the key to get the credentials of the user via an HTTP request in the background to the CAS server.

Using this mechanism, multiple applications can use a single sign-on via a single CAS server. The server providing authentication is called a service provider. Applications seeking to authenticate visitors are called service consumers.

CAS is similar to OpenID, with one main difference. In the case of OpenID, the visitor chooses the service provider. In the case of CAS, our application makes this choice, making CAS more secure.

Running a web2py CAS provider is as easy as copying the scaffolding app. In fact any web2py app that exposes the action

\begin{lstlisting}
## in provider app
def user(): return dict(form=auth())
\end{lstlisting}
\noindent is a CAS 2.0 provider and its services can be accessed at the URL

\begin{lstlisting}[keywords={}]
http://.../provider/default/user/cas/login
http://.../provider/default/user/cas/validate
http://.../provider/default/user/cas/logout
\end{lstlisting}
(we assume the app to be called "provider").

You can access this service from any other web application (the consumer) by simply delegating authentication to the provider:

\begin{lstlisting}
## in consumer app
auth = Auth(db,cas_provider = 'http://127.0.0.1:8000/provider/default/user/cas')
\end{lstlisting}

When you visit the login url the consumer app, it will redirect you to the provider app which will perform authentication and will redirect back to the consumer. All processes of registration, logout, change password, retrieve password, have to be completed on the provider app. An entry about the logged-in user will be created on the consumer side so that you add extra fields and have a local profile. Thanks to CAS 2.0 all fields that are readable on the provider and have a corresponding field in the {\ft auth\_user} table of the consumer will be copied automatically.

{\ft Auth(...,cas\_provider='...')} works with third party providers and supports CAS 1.0 and 2.0. The version is detected automatically. By default it builds the URLs of the provider from a base (the {\ft cas\_provider} url above) by appending

\begin{lstlisting}
/login
/validate
/logout
\end{lstlisting}

These can be changed in consumer and in provider

\begin{lstlisting}
## in consumer or provider app (must match)
auth.settings.cas_actions['login']='login'
auth.settings.cas_actions['validate']='validate'
auth.settings.cas_actions['logout']='logout'
\end{lstlisting}

If you want to connect to a web2py CAS provider from a different domain, you must enable them by attending to the list of allowed domain:

\begin{lstlisting}
## in provider app
auth.settings.cas_domains.append('example.com')
\end{lstlisting}

\goodbreak\subsection{Using web2py to authorize non-web2py apps}

This is possible but dependent on the web server.
here we assume two applications running under the same web server: Apache with {\ft mod\_wsgi}.
One of the applications is web2py with an app proving access control via Auth.
The other can be a CGI script, a PHP program or anything else.
We want to instruct the web server to ask permission to the former application when a client requests access to the latter.

First of all we need to modify the web2py application and add the following controller:

\begin{lstlisting}
def check_access():
    return 'true' if auth.is_logged_in() else 'false'
\end{lstlisting}
\noindent which returns {\ft true} if the user is logged in and {\ft false} otherwise. Now run a web2py process in background:

\begin{lstlisting}
nohup python web2py.py -a '' -p 8002
\end{lstlisting}

Port 8002 is a must and there is no need to enable admin so no admin password.

Then we need to edit the Apache config file (for example "/etc/apache2/sites-available/default") and instruct apache so that when the non-web2py program is called, it should call the above {\ft check} action instead and only if it returns {\ft true} it should proceed and respond to the request, else if should deny access.

Because web2py and the non-web2py application run under the same domain, if the user is logged into the web2py app, the web2py session cookie will be passed to Apache even when the other app is requested and will allow credential verification.

In order to achieve this we need a script, "web2py/scripts/access.wsgi" that can play this trick.
The script ships with web2py. All we need to do it tell apache to call this script, the URL of the application needing access control, and the location of the script:

\begin{lstlisting}[keywords={}]
<VirtualHost *:80>
   WSGIDaemonProcess web2py user=www-data group=www-data
   WSGIProcessGroup web2py
   WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

   AliasMatch ^myapp/path/needing/authentication/myfile /path/to/myfile
   <Directory /path/to/>
     WSGIAccessScript /path/to/web2py/scripts/access.wsgi
   </Directory>
</VirtualHost>
\end{lstlisting}

Here "\^myapp/path/needing/authentication/myfile" is the regular expression that should match the incoming request and "/path/to/" is the absolute location of the web2py folder.

The "access.wsgi" script contains the following line:

\begin{lstlisting}
URL_CHECK_ACCESS = 'http://127.0.0.1:8002/%(app)s/default/check_access'
\end{lstlisting}
\noindent which points to the web2py application we have requested but you can edit it to point to a specific application, running on a port other than 8002.

You can also change the {\ft check\_access()} action and make its logic more complex. This action can retrieve the URL that was originally requested using the environment variable

\begin{lstlisting}
request.env.request_uri
\end{lstlisting}
\noindent and you can implement more complex rules:

\begin{lstlisting}
def check_access():
    if not auth.is_logged_in():
       return 'false'
    elif not user_has_access(request.env.request_uri):
       return 'false'
    else:
       return 'true'
\end{lstlisting}

\goodbreak\chapter{Services}

\inxx{Web Services} \inxx{API}

The W3C defines a web service as "a software system designed to support interoperable machine-to-machine interaction over a network". This is a broad definition, and it encompasses a large number of protocols designed not for machine-to-human communication, but for machine-to-machine communication such as XML, JSON, RSS, etc.

In this chapter we discuss how to expose web services using web2py. If you are interested in examples of consuming third party services (Twitter, Dropbox, etc.) you should look into Chapter 9 and Chapter 14.
\noindent web2py provides, out of the box, support for many protocols, including XML, JSON, RSS, CSV, XMLRPC, JSONRPC, AMFRPC, and SOAP. web2py can also be extended to support additional protocols.

Each of those protocols are supported in multiple ways, and we make a distinction between:
\begin{itemize}
\item Rendering the output of a function in a given format (for example XML, JSON, RSS, CSV)

\item Remote Procedure Calls (for example XMLRPC, JSONRPC, AMFRPC)
\end{itemize}

\goodbreak\section{Rendering a dictionary}

\goodbreak\subsection{HTML, XML, and JSON}

\inxx{HTML} \inxx{XML} \inxx{JSON}

Consider the following action:
\begin{lstlisting}
def count():
    session.counter = (session.counter or 0) + 1
    return dict(counter=session.counter, now=request.now)
\end{lstlisting}

This action returns a counter that is increased by one when a visitor reloads the page, and the timestamp of the current page request.

Normally this page would be requested via:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/count
\end{lstlisting}
\noindent and rendered in HTML. Without writing one line of code, we can ask web2py to render this page using different protocols by adding an extension to the URL:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/count.html
http://127.0.0.1:8000/app/default/count.xml
http://127.0.0.1:8000/app/default/count.json
\end{lstlisting}

The dictionary returned by the action will be rendered in HTML, XML and JSON, respectively.

Here is the XML output:
\begin{lstlisting}[keywords={}]
<document>
   <counter>3</counter>
   <now>2009-08-01 13:00:00</now>
</document>
\end{lstlisting}

Here is the JSON output:
\begin{lstlisting}
{ 'counter':3, 'now':'2009-08-01 13:00:00' }
\end{lstlisting}

Notice that date, time and datetime objects are rendered as strings in ISO format. This is not part of the JSON standard, but rather a web2py convention.

\goodbreak\subsection{Generic views}

When, for example, the ".xml" extension is called, web2py looks for a template file called "default/count.xml", and if it does not find it, looks for a template called "generic.xml".  The files "generic.html", "generic.xml", "generic.json" are provided with the current scaffolding application. Other extensions can be easily defined by the user.

\begin{quote}For security reasons the generic views are only allowed to be accessed on localhost. In order to enable the access from remote clients you may need to set the response.generic\_patterns.\end{quote}Assuming you are using a copy of scaffold app, edit the following line in models/db.py

\begin{itemize}
\item restrict access only to localhost
\end{itemize}
\begin{lstlisting}
response.generic_patterns = ['*'] if request.is_local else []
\end{lstlisting}

\begin{itemize}
\item to allow all generic views
\end{itemize}
\begin{lstlisting}
response.generic_patterns = ['*']
\end{lstlisting}

\begin{itemize}
\item to allow only.json
\end{itemize}

\begin{lstlisting}
response.generic_patterns = ['*.json']
\end{lstlisting}

The generic\_patterns is a glob pattern, it means you can use any patterns that matches with your app actions or pass a list of patterns.

\begin{lstlisting}
response.generic_patterns = ['*.json','*.xml']
\end{lstlisting}

To use it in an older web2py app, you may need to copy the "generic.*" files from a later scaffolding app (after version 1.60).

Here is the code for "generic.html"
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}

{{=BEAUTIFY(response._vars)}}

<button onclick="document.location='{{=URL("admin","default","design",
args=request.application)}}'">admin</button>
<button onclick="jQuery('#request').slideToggle()">request</button>
<div class="hidden" id="request"><h2>request</h2>{{=BEAUTIFY(request)}}</div>
<button onclick="jQuery('#session').slideToggle()">session</button>
<div class="hidden" id="session"><h2>session</h2>{{=BEAUTIFY(session)}}</div>
<button onclick="jQuery('#response').slideToggle()">response</button>
<div class="hidden" id="response"><h2>response</h2>{{=BEAUTIFY(response)}}</div>
<script>jQuery('.hidden').hide();</script>
\end{lstlisting}

Here is the code for "generic.xml"
\begin{lstlisting}[keywords={}]
{{
try:
   from gluon.serializers import xml
   response.write(xml(response._vars),escape=False)
   response.headers['Content-Type']='text/xml'
except:
   raise HTTP(405,'no xml')
}}
\end{lstlisting}

And here is the code for "generic.json"
\begin{lstlisting}[keywords={}]
{{
try:
   from gluon.serializers import json
   response.write(json(response._vars),escape=False)
   response.headers['Content-Type']='text/json'
except:
   raise HTTP(405,'no json')
}}
\end{lstlisting}

Any dictionary can be rendered in HTML, XML and JSON as long as it only contains python primitive types (int, float, string, list, tuple, dictionary). {\ft response.\_vars} contains the dictionary returned by the action.

If the dictionary contains other user-defined or web2py-specific objects, they must be rendered by a custom view.

\goodbreak\subsection{Rendering {\ft Rows}}

\inxx{as\_list}

If you need to render a set of Rows as returned by a select in XML or JSON or another format,
first transform the Rows object into a list of dictionaries using the {\ft as\_list()} method.

Consider for example the following mode:
\begin{lstlisting}
db.define_table('person', Field('name'))
\end{lstlisting}

The following action can be rendered in HTML, but not in XML or JSON:
\begin{lstlisting}
def everybody():
    people = db().select(db.person.ALL)
    return dict(people=people)
\end{lstlisting}
\noindent while the following action can rendered in XML and JSON:

\begin{lstlisting}
def everybody():
    people = db().select(db.person.ALL).as_list()
    return dict(people=people)
\end{lstlisting}

\goodbreak\subsection{Custom formats}

If, for example, you want to render an action as a Python pickle:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/count.pickle
\end{lstlisting}
\noindent you just need to create a new view file "default/count.pickle" that contains:
\begin{lstlisting}[keywords={}]
{{
import cPickle
response.headers['Content-Type'] = 'application/python.pickle'
response.write(cPickle.dumps(response._vars),escape=False)
}}
\end{lstlisting}

If you want to be able to render any action as a pickled file, you need only to save the above file with the name "generic.pickle".

Not all objects are pickleable, and not all pickled objects can be un-pickled. It is safe to stick to primitive Python objects and combinations of them. Objects that do not contain references to file streams or database connections are usually pickleable, but they can only be un-pickled in an environment where the classes of all pickled objects are already defined.

\goodbreak\subsection{RSS}

\inxx{RSS}
\noindent web2py includes a "generic.rss" view that can render the dictionary returned by the action as an RSS feed.

Because the RSS feeds have a fixed structure (title, link, description, items, etc.) then for this to work, the dictionary returned by the action must have the proper structure:
\begin{lstlisting}
{'title'      : '',
 'link'       : '',
 'description': '',
 'created_on' : '',
 'entries'    : []}
\end{lstlisting}
\noindent and each entry in entries must have the same similar structure:

\begin{lstlisting}
{'title'      : '',
 'link'       : '',
 'description': '',
 'created_on' : ''}
\end{lstlisting}

For example the following action can be rendered as an RSS feed:
\begin{lstlisting}
def feed():
    return dict(title="my feed",
                link="http://feed.example.com",
                description="my first feed",
                entries=[
                  dict(title="my feed",
                  link="http://feed.example.com",
                  description="my first feed")
                ])
\end{lstlisting}
\noindent by simply visiting the URL:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/feed.rss
\end{lstlisting}

Alternatively, assuming the following model:
\begin{lstlisting}
db.define_table('rss_entry',
    Field('title'),
    Field('link'),
    Field('created_on','datetime'),
    Field('description'))
\end{lstlisting}
\noindent the following action can also be rendered as an RSS feed:

\begin{lstlisting}
def feed():
    return dict(title="my feed",
                link="http://feed.example.com",
                description="my first feed",
                entries=db().select(db.rss_entry.ALL).as_list())
\end{lstlisting}

The {\ft as\_list()} method of a Rows object converts the rows into a list of dictionaries.

If additional dictionary items are found with key names not explicitly listed here, they are ignored.

Here is the "generic.rss" view provided by web2py:
\begin{lstlisting}[keywords={}]
{{
try:
   from gluon.serializers import rss
   response.write(rss(response._vars),escape=False)
   response.headers['Content-Type']='application/rss+xml'
except:
   raise HTTP(405,'no rss')
}}
\end{lstlisting}

As one more example of an RSS application, we consider an RSS aggregator that collects data from the "slashdot" feed and returns a new web2py rss feed.
\begin{lstlisting}
def aggregator():
    import gluon.contrib.feedparser as feedparser
    d = feedparser.parse(
        "http://rss.slashdot.org/Slashdot/slashdot/to")
    return dict(title=d.channel.title,
                link = d.channel.link,
                description = d.channel.description,
                created_on = request.now,
                entries = [
                  dict(title = entry.title,
                  link = entry.link,
                  description = entry.description,
                  created_on = request.now) for entry in d.entries])
\end{lstlisting}

It can be accessed at:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/aggregator.rss
\end{lstlisting}

\goodbreak\subsection{CSV}

\inxx{CSV}

The Comma Separated Values (CSV) format is a protocol to represent tabular data.

Consider the following model:
\begin{lstlisting}
db.define_table('animal',
    Field('species'),
    Field('genus'),
    Field('family'))
\end{lstlisting}
\noindent and the following action:
\begin{lstlisting}
def animals():
    animals = db().select(db.animal.ALL)
    return dict(animals=animals)
\end{lstlisting}
\noindent web2py does not provide a "generic.csv"; you must define a custom view "default/animals.csv"
that serializes the animals into CSV. Here is a possible implementation:
\begin{lstlisting}[keywords={}]
{{
import cStringIO
stream=cStringIO.StringIO()
animals.export_to_csv_file(stream)
response.headers['Content-Type']='application/vnd.ms-excel'
response.write(stream.getvalue(), escape=False)
}}
\end{lstlisting}

Notice that one could also define a "generic.csv" file, but one would have to specify the name of the object to be serialized ("animals" in the example). This is why we do not provide a "generic.csv" file.

\goodbreak\section{Remote procedure calls}

\inxx{RPC}
\noindent web2py provides a mechanism to turn any function into a web service.
The mechanism described here differs from the mechanism described before because:
\begin{itemize}
\item The function may take arguments

\item The function may be defined in a model or a module instead of controller

\item You may want to specify in detail which RPC method should be supported

\item It enforces a more strict URL naming convention

\item It is smarter than the previous methods because it works for a fixed set of protocols. For the same reason it is not as easily extensible.
\end{itemize}

To use this feature:

First, you must import and initiate a service object.
\begin{lstlisting}
from gluon.tools import Service
service = Service()
\end{lstlisting}

\begin{quote}This is already done in the "db.py" model file in the scaffolding application.\end{quote}
Second, you must expose the service handler in the controller:
\begin{lstlisting}
def call():
    session.forget()
    return service()
\end{lstlisting}

\begin{quote}This is already done in the "default.py" controller of the scaffolding application. Remove {\ft session.forget()} if you plan to use session cookies with the services.\end{quote}
Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:
\begin{lstlisting}
@service.run
@service.xml
@service.json
@service.rss
@service.csv
@service.xmlrpc
@service.jsonrpc
@service.jsonrpc2
@service.amfrpc3('domain')
@service.soap('FunctionName',returns={'result':type},args={'param1':type,})
\end{lstlisting}

As an example, consider the following decorated function:
\begin{lstlisting}
@service.run
def concat(a,b):
    return a+b
\end{lstlisting}

This function can be defined in a model or in the controller where the {\ft call} action is defined. This function can now be called remotely in two ways:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/call/run/concat?a=hello&b=world
http://127.0.0.1:8000/app/default/call/run/concat/hello/world
\end{lstlisting}

In both cases the http request returns:
\begin{lstlisting}
helloworld
\end{lstlisting}

If the {\ft @service.xml} decorator is used, the function can be called via:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/call/xml/concat?a=hello&b=world
http://127.0.0.1:8000/app/default/call/xml/concat/hello/world
\end{lstlisting}
\noindent and the output is returned as XML:
\begin{lstlisting}[keywords={}]
<document>
   <result>helloworld</result>
</document>
\end{lstlisting}

It can serialize the output of the function even if this is a DAL Rows object. In this case, in fact, it will call {\ft as\_list()} automatically.

If the {\ft @service.json} decorator is used, the function can be called via:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/call/json/concat?a=hello&b=world
http://127.0.0.1:8000/app/default/call/json/concat/hello/world
\end{lstlisting}
\noindent and the output returned as JSON.

If the {\ft @service.csv} decorator is used, the service handler requires, as the return value, an iterable object of iterable objects, such as a list of lists. Here is an example:
\begin{lstlisting}
@service.csv
def table1(a,b):
    return [[a,b],[1,2]]
\end{lstlisting}

This service can be called by visiting one of the following URLs:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/call/csv/table1?a=hello&b=world
http://127.0.0.1:8000/app/default/call/csv/table1/hello/world
\end{lstlisting}
\noindent and it returns:
\begin{lstlisting}
hello,world
1,2
\end{lstlisting}

The {\ft @service.rss} decorator expects a return value in the same format as the "generic.rss" view discussed in the previous section.

Multiple decorators are allowed for each function.

So far, everything discussed in this section is simply an alternative to the method described in the previous section. The real power of the service object comes with XMLRPC, JSONRPC and AMFRPC, as discussed below.

\goodbreak\subsection{XMLRPC}

\inxx{XMLRPC}

Consider the following code, for example, in the "default.py" controller:
\begin{lstlisting}
@service.xmlrpc
def add(a,b):
    return a+b

@service.xmlrpc
def div(a,b):
    return a/b
\end{lstlisting}

Now in a python shell you can do
\begin{lstlisting}
>>> from xmlrpclib import ServerProxy
>>> server = ServerProxy(
       'http://127.0.0.1:8000/app/default/call/xmlrpc')
>>> print server.add(3,4)
7
>>> print server.add('hello','world')
'helloworld'
>>> print server.div(12,4)
3
>>> print server.div(1,0)
ZeroDivisionError: integer division or modulo by zero
\end{lstlisting}

The Python xmlrpclib module provides a client for the XMLRPC protocol. web2py acts as the server.

The client connects to the server via ServerProxy and can remotely call decorated functions in the server. The data (a,b) is passed to the function(s), not via GET/POST variables, but properly encoded in the request body using the XMLPRC protocol, and thus it carries with itself type information (int or string or other). The same is true for the return value(s). Moreover, any exception raised on the server propagates back to the client.

There are XMLRPC libraries for many programming languages (including C, C++, Java, C\#, Ruby, and Perl), and they can interoperate with each other. This is one the best methods to create applications that talk to each other independent of the programming language.

The XMLRPC client can also be implemented inside a web2py action, so that one action can talk to another web2py application (even within the same installation) using XMLRPC. Beware of session deadlocks in this case. If an action calls via XMLRPC a function in the same app, the caller must release the session lock before the call:
\begin{lstlisting}
session.forget(response)
\end{lstlisting}

\goodbreak\subsection{JSONRPC}

\inxx{JSONRPC}

In this section we are going to use the same code example as for XMLRPC but we will expose the service using JSONRPC instead:

\begin{lstlisting}
@service.jsonrpc
@service.jsonrpc2
def add(a,b):
    return a+b

def call():
    return service()
\end{lstlisting}

JSONRPC is very similar to XMLRPC but uses JSON instead of XML as data serialization protocol.

Of course we can call the service from any program in any language but here we will do it in Python. web2py ships with a module "gluon/contrib/simplejsonrpc.py" created by Mariano Reingart. Here is an example of how to use to call the above service:

\begin{lstlisting}
>>> from gluon.contrib.simplejsonrpc import ServerProxy
>>> URL = "http://127.0.0.1:8000/app/default/call/jsonrpc"
>>> service = ServerProxy(URL, verbose=True)
>>> print service.add(1, 2)
\end{lstlisting}

Use "http://127.0.0.1:8000/app/default/call/jsonrpc2" for jsonrpc2.

\goodbreak\subsection{JSONRPC and Pyjamas}

\inxx{JSONRPC} \inxx{Pyjamas}

JSONRPC is very similar to XMLRPC, but uses the JSON-based protocol instead of XML to encode the data. As an example of application here, we discuss its usage with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.

Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.

We are going to build a simple "todo" application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.

First, create a new application called "todo".

Second, in "models/db.py", enter the following code:
\begin{lstlisting}
db=DAL('sqlite://storage.sqlite')
db.define_table('todo', Field('task'))
service = Service()
\end{lstlisting}

{\it (Note: Service class is from gluon.tools).}

Third, in "controllers/default.py", enter the following code:
\begin{lstlisting}
    def index():
    redirect(URL('todoApp'))

    @service.jsonrpc
    def getTasks():
        todos = db(db.todo).select()
        return [(todo.task,todo.id) for todo in todos]

    @service.jsonrpc
    def addTask(taskFromJson):
        db.todo.insert(task= taskFromJson)
        return getTasks()

    @service.jsonrpc
    def deleteTask (idFromJson):
        del db.todo[idFromJson]
        return getTasks()

    def call():
        session.forget()
        return service()

    def todoApp():
        return dict()
\end{lstlisting}

The purpose of each function should be obvious.

Fourth, in "views/default/todoApp.html", enter the following code:
\begin{lstlisting}[keywords={}]
<html>
  <head>
    <meta name="pygwt:module"
     content="{{=URL('static','output/TodoApp')}}" />
    <title>
      simple todo application
    </title>
  </head>
  <body bgcolor="white">
    <h1>
      simple todo application
    </h1>
    <i>
      type a new task to insert in db,
      click on existing task to delete it
    </i>
    <script language="javascript"
     src="{{=URL('static','output/pygwt.js')}}">
    </script>
  </body>
</html>
\end{lstlisting}

This view just executes the Pyjamas code in "static/output/todoapp" - code that we have not yet created.

Fifth, in "static/TodoApp.py" (notice it is TodoApp, not todoApp!),
enter the following client code:
\begin{lstlisting}
from pyjamas.ui.RootPanel import RootPanel
from pyjamas.ui.Label import Label
from pyjamas.ui.VerticalPanel import VerticalPanel
from pyjamas.ui.TextBox import TextBox
import pyjamas.ui.KeyboardListener
from pyjamas.ui.ListBox import ListBox
from pyjamas.ui.HTML import HTML
from pyjamas.JSONService import JSONProxy

class TodoApp:
    def onModuleLoad(self):
        self.remote = DataService()
        panel = VerticalPanel()

        self.todoTextBox = TextBox()
        self.todoTextBox.addKeyboardListener(self)

        self.todoList = ListBox()
        self.todoList.setVisibleItemCount(7)
        self.todoList.setWidth("200px")
        self.todoList.addClickListener(self)
        self.Status = Label("")

        panel.add(Label("Add New Todo:"))
        panel.add(self.todoTextBox)
        panel.add(Label("Click to Remove:"))
        panel.add(self.todoList)
        panel.add(self.Status)
        self.remote.getTasks(self)

        RootPanel().add(panel)

    def onKeyUp(self, sender, keyCode, modifiers):
        pass

    def onKeyDown(self, sender, keyCode, modifiers):
        pass

    def onKeyPress(self, sender, keyCode, modifiers):
        """
        This function handles the onKeyPress event, and will add the
        item in the text box to the list when the user presses the
        enter key. In the future, this method will also handle the
        auto complete feature.
        """
        if keyCode == KeyboardListener.KEY_ENTER and \
           sender == self.todoTextBox:
            id = self.remote.addTask(sender.getText(),self)
            sender.setText("")
            if id<0:
                RootPanel().add(HTML("Server Error or Invalid Response"))

    def onClick(self, sender):
        id = self.remote.deleteTask(
                sender.getValue(sender.getSelectedIndex()),self)
        if id<0:
            RootPanel().add(
                HTML("Server Error or Invalid Response"))

    def onRemoteResponse(self, response, request_info):
        self.todoList.clear()
        for task in response:
            self.todoList.addItem(task[0])
            self.todoList.setValue(self.todoList.getItemCount()-1,
                                   task[1])

    def onRemoteError(self, code, message, request_info):
        self.Status.setText("Server Error or Invalid Response: " \
                            + "ERROR " + code + " - " + message)

class DataService(JSONProxy):
    def __init__(self):
        JSONProxy.__init__(self, "../../default/call/jsonrpc",
                           ["getTasks", "addTask","deleteTask"])

if __name__ == '__main__':
    app = TodoApp()
    app.onModuleLoad()
\end{lstlisting}

Sixth, run Pyjamas before serving the application:
\begin{lstlisting}
cd /path/to/todo/static/
python /python/pyjamas-0.5p1/bin/pyjsbuild TodoApp.py
\end{lstlisting}

This will translate the Python code into JavaScript so that it can be executed in the browser.

To access this application, visit the URL:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/todo/default/todoApp
\end{lstlisting}

This subsection was created by Chris Prinos with help from Luke Kenneth Casson Leighton (creators of Pyjamas), updated by Alexei Vinidiktov. It has been tested with Pyjamas 0.5p1. The example was inspired by this Django page in ref.~\cite{blogspot1}.

\goodbreak\subsection{AMFRPC}

\inxx{PyAMF} \inxx{Adobe Flash}

AMFRPC is the Remote Procedure Call protocol used by Flash clients to communicate with a server. web2py supports AMFRPC, but it requires that you run web2py from source and that you preinstall the PyAMF library. This can be installed from the Linux or Windows shell by typing:
\begin{lstlisting}
easy_install pyamf
\end{lstlisting}

(please consult the PyAMF documentation for more details).

In this subsection we assume that you are already familiar with
ActionScript programming.

We will create a simple service that takes two numerical values, adds them together, and returns the sum. We will call our web2py application "pyamf\_test", and we will call the service {\ft addNumbers}.

First, using Adobe Flash (any version starting from MX 2004), create the Flash client application by starting with a new Flash FLA file. In the first frame of the file, add these lines:
\begin{lstlisting}
import mx.remoting.Service;
import mx.rpc.RelayResponder;
import mx.rpc.FaultEvent;
import mx.rpc.ResultEvent;
import mx.remoting.PendingCall;

var val1 = 23;
var val2 = 86;

service = new Service(
    "http://127.0.0.1:8000/pyamf_test/default/call/amfrpc3",
    null, "mydomain", null, null);

var pc:PendingCall = service.addNumbers(val1, val2);
pc.responder = new RelayResponder(this, "onResult", "onFault");

function onResult(re:ResultEvent):Void {
    trace("Result : " + re.result);
    txt_result.text = re.result;
}

function onFault(fault:FaultEvent):Void {
    trace("Fault: " + fault.fault.faultstring);
}

stop();
\end{lstlisting}

This code allows the Flash client to connect to a service that corresponds to a function called "addNumbers" in the file "/pyamf\_test/default/gateway". You must also import ActionScript version 2 MX remoting classes to enable Remoting in Flash. Add the path to these classes to the classpath settings in the Adobe Flash IDE, or just place the "mx" folder next to the newly created file.

Notice the arguments of the Service constructor. The first argument is the URL corresponding to the service that we want will create. The third argument is the domain of the service. We choose to call this domain "mydomain".

Second, create a dynamic text field called
"txt\_result" and place it on the stage.

Third, you need to set up a web2py gateway that can communicate with the Flash client defined above.

Proceed by creating a new web2py app called {\ft pyamf\_test} that will host the new service and the AMF gateway for the flash client.
Edit the "default.py" controller and make sure it contains
\begin{lstlisting}
@service.amfrpc3('mydomain')
def addNumbers(val1, val2):
    return val1 + val2

def call(): return service()
\end{lstlisting}

Fourth, compile and export/publish the SWF flash client as {\ft pyamf\_test.swf}, place the "pyamf\_test.amf", "pyamf\_test.html", "AC\_RunActiveContent.js", and "crossdomain.xml" files in the "static" folder of the newly created appliance that is hosting the gateway, "pyamf\_test".

You can now test the client by visiting:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/pyamf_test/static/pyamf_test.html
\end{lstlisting}

The gateway is called in the background when the client connects to addNumbers.

If you are using AMF0 instead of AMF3 you can also use the decorator:
\begin{lstlisting}
@service.amfrpc
\end{lstlisting}
\noindent instead of:
\begin{lstlisting}
@service.amfrpc3('mydomain')
\end{lstlisting}

In this case you also need to change the service URL to:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/pyamf_test/default/call/amfrpc
\end{lstlisting}

\goodbreak\subsection{SOAP}

\inxx{SOAP}
\noindent web2py includes a SOAP client and server created by Mariano Reingart. It can be used very much like XML-RPC:

Consider the following code, for example, in the "default.py" controller:
\begin{lstlisting}
@service.soap('MyAdd',returns={'result':int},args={'a':int,'b':int,})
def add(a,b):
    return a+b
\end{lstlisting}

Now in a python shell you can do:
\begin{lstlisting}
>>> from gluon.contrib.pysimplesoap.client import SoapClient
>>> client = SoapClient(wsdl="http://localhost:8000/app/default/call/soap?WSDL")
>>> print client.MyAdd(a=1,b=2)
{'result': 3}
\end{lstlisting}

To get proper encoding when returning a text values, specify string as u'proper utf8 text'.

You can obtain the WSDL for the service at

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/call/soap?WSDL
\end{lstlisting}

And you can obtain documentation for any of the exposed methods:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/app/default/call/soap
\end{lstlisting}

\goodbreak\section{Low level API and other recipes}

\goodbreak\subsection{simplejson}

\inxx{JSON} \inxx{simplejson}
\noindent web2py includes gluon.contrib.simplejson, developed by Bob Ippolito. This module provides the most standard Python-JSON encoder-decoder.

SimpleJSON consists of two functions:
\begin{itemize}
\item {\ft gluon.contrib.simplesjson.dumps(a)} encodes a Python object {\ft a} into JSON.

\item {\ft gluon.contrib.simplejson.loads(b)} decodes a JavaScript object {\ft b} into a Python object.
\end{itemize}

Object types that can be serialized include primitive types, lists, and dictionaries. Compound objects can be serialized with the exception of user defined classes.

Here is a sample action (for example in controller "default.py") that serializes the Python list containing weekdays using this low level API:
\begin{lstlisting}
def weekdays():
    names=['Sunday','Monday','Tuesday','Wednesday',
           'Thursday','Friday','Saturday']
    import gluon.contrib.simplejson
    return gluon.contrib.simplejson.dumps(names)
\end{lstlisting}

Below is a sample HTML page that sends an Ajax request to the above action, receives the JSON message and stores the list in a corresponding JavaScript variable:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<script>
$.getJSON('/application/default/weekdays',
          function(data){ alert(data); });
</script>
\end{lstlisting}

The code uses the jQuery function {\ft \$.getJSON}, which performs the Ajax call and, on response, stores the weekdays names in a local JavaScript variable {\ft data} and passes the variable to the callback function. In the example the callback function simply alerts the visitor that the data has been received.

\goodbreak\subsection{PyRTF}

\inxx{PyRTF} \inxx{RTF}

Another common need of web sites is that of generating Word-readable text documents. The simplest way to do so is using the Rich Text Format (RTF) document format. This format was invented by Microsoft and it has since become a standard.
\noindent web2py includes gluon.contrib.pyrtf, developed by Simon Cusack and revised by Grant Edwards. This module allows you to generate RTF documents programmatically, including colored formatted text and pictures.

In the following example we initiate two basic RTF classes, Document and Section, append the latter to the former and insert some dummy text in the latter:
\begin{lstlisting}
def makertf():
    import gluon.contrib.pyrtf as q
    doc=q.Document()
    section=q.Section()
    doc.Sections.append(section)
    section.append('Section Title')
    section.append('web2py is great. '*100)
    response.headers['Content-Type']='text/rtf'
    return q.dumps(doc)
\end{lstlisting}

In the end the Document is serialized by {\ft q.dumps(doc)}. Notice that before returning an RTF document it is necessary to specify the content-type in the header else the browser does not know how to handle the file.

Depending on the configuration, the browser may ask you whether to save this file or open it using a text editor.

\goodbreak\subsection{ReportLab and PDF}

\inxx{ReportLab} \inxx{PDF}
\noindent web2py can also generate PDF documents, with an additional library called "ReportLab"~\cite{ReportLab}.

If you are running web2py from source, it is sufficient to have ReportLab installed. If you are running the Windows binary distribution, you need to unzip ReportLab in the "web2py/" folder. If you are running the Mac binary distribution, you need to unzip ReportLab  in the folder:
\begin{lstlisting}
web2py.app/Contents/Resources/
\end{lstlisting}

From now on we assume ReportLab is installed and that web2py can find it.
We will create a simple action called "get\_me\_a\_pdf" that generates a PDF document.
\begin{lstlisting}
from reportlab.platypus import *
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.rl_config import defaultPageSize
from reportlab.lib.units import inch, mm
from reportlab.lib.enums import TA_LEFT, TA_RIGHT, TA_CENTER, TA_JUSTIFY
from reportlab.lib import colors
from uuid import uuid4
from cgi import escape
import os

def get_me_a_pdf():
    title = "This The Doc Title"
    heading = "First Paragraph"
    text = 'bla '* 10000

    styles = getSampleStyleSheet()
    tmpfilename=os.path.join(request.folder,'private',str(uuid4()))
    doc = SimpleDocTemplate(tmpfilename)
    story = []
    story.append(Paragraph(escape(title),styles["Title"]))
    story.append(Paragraph(escape(heading),styles["Heading2"]))
    story.append(Paragraph(escape(text),styles["Normal"]))
    story.append(Spacer(1,2*inch))
    doc.build(story)
    data = open(tmpfilename,"rb").read()
    os.unlink(tmpfilename)
    response.headers['Content-Type']='application/pdf'
    return data
\end{lstlisting}

Notice how we generate the PDF into a unique temporary file, {\ft tmpfilename}, we read the generated PDF from the file, then we deleted the file.

For more information about the ReportLab API, refer to the ReportLab documentation. We strongly recommend using the Platypus API of ReportLab, such as {\ft Paragraph}, {\ft Spacer}, etc.

\goodbreak\section{Restful Web Services}

\inxx{REST}

REST stands for "REpresentational State Transfer" and it is a type of web service architecture and not, like SOAP, a protocol. In fact there is no standard for REST.

Loosely speaking REST says that a service can be thought of as a collection of resources. Each resource should be identified by a URL. There are four methods actions on a resource and they are POST (create), GET (read), PUT (update) and DELETE, from which the acronym CRUD (create-read-update-delete) stands for. A client communicates with the resource by making an HTTP request to the URL that identifies the resource and using the HTTP method POST/PUT/GET/DELETE to pass instructions to the resource. The URL may have an extension, for example {\ft json} that specify how the protocol for encoding the data.

So for example a POST request to

\begin{lstlisting}[keywords={}]
http://127.0.0.1/myapp/default/api/person
\end{lstlisting}
\noindent means that you want to create a new {\ft person}. In this case a {\ft person} may correspond to a record in table {\ft person} but may also be some other type of resource (for example a file).

Similarly a GET request to

\begin{lstlisting}[keywords={}]
http://127.0.0.1/myapp/default/api/persons.json
\end{lstlisting}
\noindent indicates a request for a list of persons (records from the data {\ft person}) in json format.

A GET request to

\begin{lstlisting}[keywords={}]
http://127.0.0.1/myapp/default/api/person/1.json
\end{lstlisting}
\noindent indicates a request for the information associated to {\ft person/1} (the record with {\ft id==1}) and in json format.

In the case of web2py each request can be split into three parts:

\begin{itemize}
\item A first part that identify the location of the service, i.e. the action that exposes the service:
\end{itemize}
\begin{lstlisting}[keywords={}]
http://127.0.0.1/myapp/default/api/
\end{lstlisting}
\begin{itemize}
\item The name of the resource ({\ft person}, {\ft persons}, {\ft person/1}, etc.)

\item The communication protocol specified y the extension.
\end{itemize}

Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:

\begin{lstlisting}[keywords={}]
http://127.0.0.1/myapp/default/api/person/1.json
\end{lstlisting}
\noindent into this:

\begin{lstlisting}[keywords={}]
http://127.0.0.1/api/person/1.json
\end{lstlisting}
\noindent yet this is a matter of test and we have already discussed it at length in chapter 4.

In our example we used an action called {\ft api} but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the sake of argument we will continue to assume that our RESTful action is called {\ft api}.

We will also assume we have defined the following two tables:

\begin{lstlisting}
db.define_table('person',Field('name'),Field('info'))
db.define_table('pet',Field('owner',db.person),Field('name'),Field('info'))
\end{lstlisting}
\noindent and they are the resources we want to expose.

The first thing we do is create the RESTful action:

\begin{lstlisting}
def api():
    return locals()
\end{lstlisting}

Now we modify it so that the extension is filtered out of the request args (so that {\ft request.args} can be used to identify the resource) and so that it can handle the different methods separately:

\begin{lstlisting}
@request.restful()
def api():
    def GET(*args,**vars):
        return dict()
    def POST(*args,**vars):
        return dict()
    def PUT(*args,**vars):
        return dict()
    def DELETE(*args,**vars):
        return dict()
    return locals()
\end{lstlisting}

Now when we make a GET http request to

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/myapp/default/api/person/1.json
\end{lstlisting}
\noindent it calls and returns {\ft GET('person','1')} where GET is the function defined inside the action. Notice that:
\begin{itemize}
\item we do not need to define all four methods, only those that we wish to expose.

\item the method function can take named arguments

\item the extension is stored in {\ft request.extension} and the content type is set automatically.
\end{itemize}

\begin{quote}The {\ft @request.restful()} decorator makes sure that the extension in the path info is stored into {\ft request.extension}, maps the request method into the corresponding function within the action (POST, GET, PUT, DELETE), and passes {\ft request.args} and {\ft request.vars} to the selected function.\end{quote}
Now we build a service to POST and GET individual records:

\begin{lstlisting}
@request.restful()
def api():
    response.view = 'generic.json'
    def GET(tablename,id):
        if not tablename=='person': raise HTTP(400)
        return dict(person = db.person(id))
    def POST(tablename,**fields):
        if not tablename=='person': raise HTTP(400)
        return db.person.validate_and_insert(**fields)
    return locals()
\end{lstlisting}

Notice that:
\begin{itemize}
\item the GET and POST are dealt with by different functions

\item the function expect the correct arguments (un-named arguments parsed by {\ft request.args} and named arguments are from {\ft request.vars})

\item they check the input is correct and eventually raise an exception

\item GET perform a select and returns the record, {\ft db.person(id)}. The output is automatically converted to JSON because the generic view is called.

\item POST performs a {\ft validate\_and\_insert(..)} and returns the {\ft id} of the new record or, alternatively, validation errors. The POST variables, {\ft **fields}, are the post variables.
\end{itemize}

\goodbreak\subsection{{\ft parse\_as\_rest} (experimental)}

The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.

In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.

\inxx{parse\_as\_rest}

This is done using URL patterns.
A pattern is a string that maps the request args from a URL into a database query.
There 4 types of atomic patterns:

\begin{itemize}
\item String constants for example "friend"

\item String constant corresponding to a table. For example "friend[person]" will match "friends" in the URL to the "person" table.

\item Variables to be used to filter. For example "\{person.id\}" will apply a {\ft db.person.name==\{person.id\}} filter.

\item Names of fields, represented by ":field"
\end{itemize}

Atomic patters can be combined into complex URL patters using "/" such as in

\begin{lstlisting}
"/friend[person]/{person.id}/:field"
\end{lstlisting}
\noindent which gives a url of the form

\begin{lstlisting}[keywords={}]
http://..../friend/1/name
\end{lstlisting}

Into a query for a person.id that returns the name of the person. Here "friend[person]" matches "friend" and filters the table "person". "\{person.id\}" matches "1" and filters "person.id==1". ":field" matches "name" and returns:

\begin{lstlisting}
db(db.person.id==1).select().first().name
\end{lstlisting}

Multiple URL patters can be combined into a list so that one single RESTful action can serve different types of requests.

The DAL has a method {\ft parse\_as\_rest(pattern,args,vars)} that given a list of patterns, the {\ft request.args} and the {\ft request.vars} matches the pattern and returns a response (GET only).

So here is a more complex example:

\begin{lstlisting}

@request.restful()
def api():
    response.view = 'generic.'+request.extension
    def GET(*args,**vars):
        patterns = [
            "/friends[person]",
            "/friend/{person.name.startswith}",
            "/friend/{person.name}/:field",
            "/friend/{person.name}/pets[pet.owner]",
            "/friend/{person.name}/pet[pet.owner]/{pet.name}",
            "/friend/{person.name}/pet[pet.owner]/{pet.name}/:field"
            ]
        parser = db.parse_as_rest(patterns,args,vars)
        if parser.status == 200:
            return dict(content=parser.response)
        else:
            raise HTTP(parser.status,parser.error)
    def POST(table_name,**vars):
        if table_name == 'person':
            return db.person.validate_and_insert(**vars)
        elif table_name == 'pet':
            return db.pet.validate_and_insert(**vars)
        else:
            raise HTTP(400)
    return locals()
\end{lstlisting}

Which understands the following URLs that correspond to the listed patters:

\begin{itemize}
\item GET all persons
\end{itemize}
\begin{lstlisting}[keywords={}]
http://.../api/friends
\end{lstlisting}
\begin{itemize}
\item GET one person with name starting with "t"
\end{itemize}
\begin{lstlisting}[keywords={}]
http://.../api/friend/t
\end{lstlisting}
\begin{itemize}
\item GET the "info" field value of the first person with name equal to "Tim"
\end{itemize}
\begin{lstlisting}[keywords={}]
http://.../api/friend/Tim/info
\end{lstlisting}
\begin{itemize}
\item GET a list of pets of the person (friend) above
\end{itemize}
\begin{lstlisting}[keywords={}]
http://.../api/friend/Tim/pets
\end{lstlisting}
\begin{itemize}
\item GET the pet with name "Snoopy of person with name "Tim"
\end{itemize}
\begin{lstlisting}[keywords={}]
http://.../api/friend/Tim/pet/Snoopy
\end{lstlisting}
\begin{itemize}
\item GET the "info" field value for the pet
\end{itemize}
\begin{lstlisting}[keywords={}]
http://.../api/friend/Tim/pet/Snoopy/info
\end{lstlisting}

The action also exposes two POST urls:

\begin{itemize}
\item POST a new friend

\item POST a new pet
\end{itemize}

If you have the "curl" utility installed you can try:

\begin{lstlisting}
$ curl -d "name=Tim" http://127.0.0.1:8000/myapp/default/api/friend.json
{"errors": {}, "id": 1}
$ curl http://127.0.0.1:8000/myapp/default/api/friends.json
{"content": [{"info": null, "name": "Tim", "id": 1}]}
$ curl -d "name=Snoopy&owner=1" http://127.0.0.1:8000/myapp/default/api/pet.json
{"errors": {}, "id": 1}
$ curl http://127.0.0.1:8000/myapp/default/api/friend/Tim/pet/Snoopy.json
{"content": [{"info": null, "owner": 1, "name": "Snoopy", "id": 1}]}
\end{lstlisting}

It is possible to declare more complex queries such where a value in the URL is used to build a query not involving equality. For example

{\ft patterns = ['friends/\{person.name.contains\}'}
\noindent maps

\begin{lstlisting}[keywords={}]
http://..../friends/i
\end{lstlisting}
\noindent into

\begin{lstlisting}
db.person.name.contains('i')
\end{lstlisting}

And similarly:

{\ft patterns = ['friends/\{person.name.ge\}/\{person.name.gt.not\}'}
\noindent maps

\begin{lstlisting}[keywords={}]
http://..../friends/aa/uu
\end{lstlisting}
\noindent into

\begin{lstlisting}
(db.person.name>='aa')&(~(db.person.name>'uu'))
\end{lstlisting}
\noindent valid attributes for a field in a pattern are: {\ft contains}, {\ft startswith}, {\ft le}, {\ft ge}, {\ft lt}, {\ft gt}, {\ft eq} (equal, default), {\ft ne} (not equal). Other attributes specifically for date and datetime fields are {\ft day}, {\ft month}, {\ft year}, {\ft hour}, {\ft minute}, {\ft second}.

Notice that this pattern syntax is not designed to be general. Not every possible query can be described via a pattern but a lot of them are. The syntax may be extended in the future.

Often you want to expose some RESTful URLs but you want to restrict the possible queries. This can be done by passing an extra argument {\ft queries} to the {\ft parse\_as\_rest} method. {\ft queries} is a dictionary of {\ft (tablename,query)} where query is a DAL query to restrict access to table {\ft tablename}.

We can also order results using the order GET variables

\begin{lstlisting}[keywords={}]
http://..../api/friends?order=name|~info
\end{lstlisting}
which order alphabetically ({\ft name}) and then by reversed info {\ft order}.

We can also limit the number of records by specifying a {\ft limit} and {\ft offset} GET variables

\begin{lstlisting}[keywords={}]
http://..../api/friends?offset=10&limit=1000
\end{lstlisting}
which will return up to 1000 friends (persons) and skip the first 10. {\ft limit} defaults to 1000 and {\ft offset} default to 0.

Let's now consider an extreme case. We want to build all possible patterns for all tables (except {\ft auth\_} tables). We want to be able to search by any text field, any integer field, any double field (by range) and any date (also by range). We also want to be able to POST into any table:

In the general case this requires a lot of patterns. Web2py makes it simple:

\begin{lstlisting}
@request.restful()
def api():
    response.view = 'generic.'+request.extension
    def GET(*args,**vars):
        patterns = 'auto'
        parser = db.parse_as_rest(patterns,args,vars)
        if parser.status == 200:
            return dict(content=parser.response)
        else:
            raise HTTP(parser.status,parser.error)
    def POST(table_name,**vars):
        return db[table_name].validate_and_insert(**vars)
    return locals()
\end{lstlisting}

Settings {\ft patterns='auto'} results in web2py generating all possible patterns for all non-auth tables.
There is even a pattern for querying about patterns:

\begin{lstlisting}[keywords={}]
http://..../api/patterns.json
\end{lstlisting}
\noindent which for out {\ft person} and {\ft pet} tables results in:

\begin{lstlisting}
{"content": [
   "/person[person]",
   "/person/id/{person.id}",
   "/person/id/{person.id}/:field",
   "/person/id/{person.id}/pet[pet.owner]",
   "/person/id/{person.id}/pet[pet.owner]/id/{pet.id}",
   "/person/id/{person.id}/pet[pet.owner]/id/{pet.id}/:field",
   "/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}",
   "/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}/:field",
   "/person/name/pet[pet.owner]",
   "/person/name/pet[pet.owner]/id/{pet.id}",
   "/person/name/pet[pet.owner]/id/{pet.id}/:field",
   "/person/name/pet[pet.owner]/owner/{pet.owner}",
   "/person/name/pet[pet.owner]/owner/{pet.owner}/:field",
   "/person/info/pet[pet.owner]",
   "/person/info/pet[pet.owner]/id/{pet.id}",
   "/person/info/pet[pet.owner]/id/{pet.id}/:field",
   "/person/info/pet[pet.owner]/owner/{pet.owner}",
   "/person/info/pet[pet.owner]/owner/{pet.owner}/:field",
   "/pet[pet]",
   "/pet/id/{pet.id}",
   "/pet/id/{pet.id}/:field",
   "/pet/owner/{pet.owner}",
   "/pet/owner/{pet.owner}/:field"
]}
\end{lstlisting}

You can specify auto patterns for some tables only:

\begin{lstlisting}
patterns = [':auto[person]',':auto[pet]']
\end{lstlisting}

\goodbreak\subsection{{\ft smart\_query} (experimental)}

\inxx{smart\_query}

There are times when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like

\begin{lstlisting}[keywords={}]
http://.../api.json?search=person.name starts with 'T' and person.name contains 'm'
\end{lstlisting}

You can do this using

\begin{lstlisting}
@request.restful()
def api():
    response.view = 'generic.'+request.extension
    def GET(search):
        try:
            rows = db.smart_query([db.person,db.pet],search).select()
            return dict(result=rows)
        except RuntimeError:
            raise HTTP(400,"Invalid search string")
    def POST(table_name,**vars):
        return db[table_name].validate_and_insert(**vars)
    return locals()
\end{lstlisting}

The method {\ft db.smart\_query} takes two arguments:
\begin{itemize}
\item a list of field or table that should be allowed in the query

\item a string containing the query expressed in natural language
\end{itemize}
and it returns a {\ft db.set} object with the records that have been found.

Notice that the search string is parsed, not evaluated or executed and therefore it provides no security risk.

\goodbreak\subsection{Access Control}

Access to the API can be restricted as usual by using decorators. So, for example

\begin{lstlisting}
auth.settings.allow_basic_login = True

@auth.requires_login()
@request.restful()
def api():
   def GET(s):
       return 'access granted, you said %s' % s
   return locals()
\end{lstlisting}
\noindent can now be accessed with

\begin{lstlisting}
$ curl --user name:password http://127.0.0.1:8000/myapp/default/api/hello
access granted, you said hello
\end{lstlisting}

\goodbreak\section{Services and Authentication}

\inxx{Authentication}

In the previous chapter we have discussed the use of the following decorators:
\begin{lstlisting}
@auth.requires_login()
@auth.requires_membership(...)
@auth.requires_permission(...)
\end{lstlisting}

For normal actions (not decorated as services), these decorators can be used even if the output is rendered in a format other than HTML.

For functions defined as services and decorated using the {\ft @service...} decorators, the {\ft @auth...} decorators should not be used. The two types of decorators cannot be mixed. If authentication is to be performed, it is the {\ft call} actions that needs to be decorated:
\begin{lstlisting}
@auth.requires_login()
def call(): return service()
\end{lstlisting}

Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:
\begin{lstlisting}
public_services=Service()
private_services=Service()

@public_service.jsonrpc
@private_service.jsonrpc
def f(): return 'public'

@private_service.jsonrpc
def g(): return 'private'

def public_call(): return public_service()

@auth.requires_login()
def private_call(): return private_service()
\end{lstlisting}

This assumes that the caller is passing credentials in the HTTP header (a valid session cookie or using basic authentication, as discussed in the previous section). The client must support it; not all clients do.

\goodbreak\chapter{jQuery and Ajax}

\inxx{Ajax}

While web2py is mainly for server-side development, the {\bf welcome} scaffolding app comes with the base jQuery library~\cite{jquery}, jQuery calendars (date picker, datetime picker and clock), the "superfish.js" menu, and some additional JavaScript functions based on jQuery.

Nothing in web2py prevents you from using other
Ajax libraries such as Prototype, ExtJS, or YUI, but we decided to package jQuery because we find it to be easier to use and more powerful than other equivalent libraries. We also find that it captures the web2py spirit of being functional and concise.

\goodbreak\section{web2py\_ajax.html}

The scaffolding web2py application "welcome" includes a file called
\begin{lstlisting}
views/web2py_ajax.html
\end{lstlisting}
\noindent which looks like this:

\begin{lstlisting}[keywords={}]
{{
response.files.insert(0,URL('static','js/jquery.js'))
response.files.insert(1,URL('static','css/calenadar.css'))
response.files.insert(2,URL('static','js/calendar.js'))
response.include_meta()
response.include_files()
}}
<script type="text/javascript"><!--
    // These variables are used by the web2py_ajax_init
        // function in web2py.js (which is loaded below).
    var w2p_ajax_confirm_message =
        "{{=T('Are you sure you want to delete this object?')}}";
    var w2p_ajax_date_format = "{{=T('%Y-%m-%d')}}";
    var w2p_ajax_datetime_format = "{{=T('%Y-%m-%d %H:%M:%S')}}";
//--></script>
<script src="{{=URL('static','js/web2py.js')}}"
        type="text/javascript"></script>
\end{lstlisting}

This file is included in the HEAD of the default "layout.html" and it provides the following services:
\begin{itemize}
\item Includes "static/jquery.js".

\item Includes "static/calendar.js" and "static/calendar.css", which are used for the popup calendar.

\item Includes all {\ft response.meta} headers

\item Includes all {\ft response.files} (requires CSS and JS, as declared in the code)

\item Sets form variables and includes "static/js/web2y.js"
\end{itemize}

"web2py.js" does the following:
\begin{itemize}
\item Defines an {\ft ajax} function (based on jQuery \$.ajax).

\item Makes any DIV of class "error" or any tag object of class "flash" slide down.

\item Prevents typing invalid integers in INPUT fields of class "integer".

\item Prevents typing invalid floats in INPUT fields of class "double".

\item Connects INPUT fields of type "date" with a popup date picker.

\item Connects INPUT fields of type "datetime" with a popup datetime picker.

\item Connects INPUT fields of type "time" with a popup time picker.

\item Defines {\ft web2py\_ajax\_component}, a very important tool that will be described in Chapter 12.

\item Defines {\ft web2py\_websocket}, a function that can be used for HTML5 websockets (not described in this book but read the examples in the source of "gluon/contrib/websocket\_\_messaging.py"). \inxx{websockets}

\item Defines functions to the entropy calculation and input validation of the password field.
\end{itemize}

It also includes {\ft popup}, {\ft collapse}, and {\ft fade} functions for backward compatibility.

Here is an an example of how the other effects play well together.

Consider a {\bf test} app with the following model:
\begin{lstlisting}
db = DAL("sqlite://db.db")
db.define_table('child',
     Field('name'),
     Field('weight', 'double'),
     Field('birth_date', 'date'),
     Field('time_of_birth', 'time'))

db.child.name.requires=IS_NOT_EMPTY()
db.child.weight.requires=IS_FLOAT_IN_RANGE(0,100)
db.child.birth_date.requires=IS_DATE()
db.child.time_of_birth.requires=IS_TIME()
\end{lstlisting}
\noindent with this "default.py" controller:
\begin{lstlisting}
def index():
    form = SQLFORM(db.child)
    if form.process().accepted:
        response.flash = 'record inserted'
    return dict(form=form)
\end{lstlisting}
\noindent and the following "default/index.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html}}
{{=form}}
\end{lstlisting}

The "index" action generates the following form:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7000.png}\end{center}


If an invalid form is submitted, the server returns the page with a modified form containing error messages. The error messages are DIVs of class "error", and because of the above web2py.js code, the errors appears with a slide-down effect:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7100.png}\end{center}


The color of the errors is given in the CSS code in "layout.html".

The web2py.js code prevents you from typing an invalid value in the input field. This is done before and in addition to, not as a substitute for, the server-side validation.

The web2py.js code displays a date picker when you enter an INPUT field of class "date", and it displays a datetime picker when you enter an INPUT field of class "datetime". Here is an example:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7200.png}\end{center}


The web2py.js code also displays the following time picker when you try to edit an INPUT field of class "time":


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7300.png}\end{center}


Upon submission, the controller action sets the response flash to the message "record inserted". The default layout renders this message in a DIV with id="flash". The web2py.js code is responsible for making this DIV appear and making it disappear when you click on it:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7400.png}\end{center}


These and other effects are accessible programmatically in the views and via helpers in controllers.

\goodbreak\section{jQuery effects}

\inxx{effects}

The basic effects described here do not require any additional files; everything you need is already included in web2py\_ajax.html.

HTML/XHTML objects can be identified by their type (for example a DIV), their classes, or their id. For example:
\begin{lstlisting}[keywords={}]
<div class="one" id="a">Hello</div>
<div class="two" id="b">World</div>
\end{lstlisting}

They belong to class "one" and "two" respectively. They have ids equal to "a" and "b" respectively.

In jQuery you can refer to the former with the following a CSS-like equivalent notations
\begin{lstlisting}
jQuery('.one')    // address object by class "one"
jQuery('#a')      // address object by id "a"
jQuery('DIV.one') // address by object of type "DIV" with class "one"
jQuery('DIV #a')  // address by object of type "DIV" with id "a"
\end{lstlisting}
\noindent and to the latter with
\begin{lstlisting}
jQuery('.two')
jQuery('#b')
jQuery('DIV.two')
jQuery('DIV #b')
\end{lstlisting}
\noindent or you can refer to both with
\begin{lstlisting}
jQuery('DIV')
\end{lstlisting}

Tag objects are associated to events, such as "onclick". jQuery allows linking these events to effects, for example "slideToggle":
\begin{lstlisting}[keywords={}]
<div class="one" id="a" onclick="jQuery('.two').slideToggle()">Hello</div>
<div class="two" id="b">World</div>
\end{lstlisting}

Now if you click on "Hello", "World" disappears. If you click again, "World" reappears. You can make a tag hidden by default by giving it a hidden class:

\begin{lstlisting}[keywords={}]
<div class="one" id="a" onclick="jQuery('.two').slideToggle()">Hello</div>
<div class="two hidden" id="b">World</div>
\end{lstlisting}

You can also link actions to events outside the tag itself. The previous code can be rewritten as follows:
\begin{lstlisting}[keywords={}]
<div class="one" id="a">Hello</div>
<div class="two" id="b">World</div>
<script>
jQuery('.one').click(function(){jQuery('.two').slideToggle()});
</script>
\end{lstlisting}

Effects return the calling object, so they can be chained.

When the {\ft click} sets the callback function to be called on click. Similarly for {\ft change}, {\ft keyup}, {\ft keydown}, {\ft mouseover}, etc.

A common situation is the need to execute some JavaScript code only after the entire document has been loaded. This is usually done by the {\ft onload} attribute of BODY but jQuery provides an alternative way that does not require editing the layout:
\begin{lstlisting}[keywords={}]
<div class="one" id="a">Hello</div>
<div class="two" id="b">World</div>
<script>
jQuery(document).ready(function(){
   jQuery('.one').click(function(){jQuery('.two').slideToggle()});
});
</script>
\end{lstlisting}

The body of the unnamed function is executed only when the document is ready, after it has been fully loaded.

Here is a list of useful event names:

{\bf Form events}

\begin{itemize}
\item {\ft onchange}:   Script to be run when the element changes

\item {\ft onsubmit}:   Script to be run when the form is submitted

\item {\ft onreset}:    Script to be run when the form is reset

\item {\ft onselect}:   Script to be run when the element is selected

\item {\ft onblur}:     Script to be run when the element loses focus

\item {\ft onfocus}:    Script to be run when the element gets focus
\end{itemize}

{\bf Keyboard events}

\begin{itemize}
\item {\ft onkeydown}:  Script to be run when key is pressed

\item {\ft onkeypress}: Script to be run when key is pressed and released

\item {\ft onkeyup}:    Script to be run when key is released
\end{itemize}

{\bf Mouse events}

\begin{itemize}
\item {\ft onclick}:     Script to be run on a mouse click

\item {\ft ondblclick}:  Script to be run on a mouse double-click

\item {\ft onmousedown}: Script to be run when mouse button is pressed

\item {\ft onmousemove}: Script to be run when mouse pointer moves

\item {\ft onmouseout}:  Script to be run when mouse pointer moves out of an element

\item {\ft onmouseover}: Script to be run when mouse pointer moves over an element

\item {\ft onmouseup}:   Script to be run when mouse button is released
\end{itemize}

Here is a list of useful effects defined by jQuery:

{\bf Effects}

\begin{itemize}
\item {\ft jQuery(...).attr(name)}: Returns the name of the attribute value

\item {\ft jQuery(...).attr(name, value)}: Sets the attribute name to value

\item {\ft jQuery(...).show()}: Makes the object visible

\item {\ft jQuery(...).hide()}: Makes the object hidden

\item {\ft jQuery(...).slideToggle(speed, callback)}: Makes the object slide up or down

\item {\ft jQuery(...).slideUp(speed, callback)}: Makes the object slide up

\item {\ft jQuery(...).slideDown(speed, callback)}: Makes the object slide down

\item {\ft jQuery(...).fadeIn(speed, callback)}: Makes the object fade in

\item {\ft jQuery(...).fadeOut(speed, callback)}: Makes the object fade out
\end{itemize}

The speed argument is usually "slow", "fast" or omitted (the default). The callback is an optional function that is called when the effect is completed.
\noindent jQuery effects can also easily be embedded in helpers, for example,
in a view:
\begin{lstlisting}[keywords={}]
{{=DIV('click me!', _onclick="jQuery(this).fadeOut()")}}
\end{lstlisting}
\noindent jQuery is a very compact and concise Ajax library; therefore web2py does not need an additional abstraction layer on top of jQuery (except for the {\ft ajax} function discussed below). The jQuery APIs are accessible and readily available in their native form when needed.

Consult the documentation for more information about these effects and other jQuery APIs.

The jQuery library can also be extended using plugins and User Interface Widgets. This topic is not covered here; see ref.~\cite{jquery-ui} for details.

\goodbreak\subsection{Conditional fields in forms}

A typical application of jQuery effects is a form that changes its appearance based on the value of its fields.

This is easy in web2py because the SQLFORM helper generates forms that are "CSS friendly". The form contains a table with rows. Each row contains a label, an input field, and an optional third column. The items have ids derived strictly from the name of the table and names of the fields.

The convention is that every INPUT field has an id {\ft tablename\_fieldname} and is contained in a row with id {\ft tablename\_fieldname\_\_row}.

As an example, create an input form that asks for a taxpayer's name and for the name of the taxpayer's spouse, but only if he/she is married.

Create a test application with the following model:
\begin{lstlisting}
db = DAL('sqlite://db.db')
db.define_table('taxpayer',
    Field('name'),
    Field('married', 'boolean'),
    Field('spouse_name'))
\end{lstlisting}
\noindent the following "default.py" controller:
\begin{lstlisting}
def index():
    form = SQLFORM(db.taxpayer)
    if form.process().accepted:
        response.flash = 'record inserted'
    return dict(form=form)
\end{lstlisting}
\noindent and the following "default/index.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=form}}
<script>
jQuery(document).ready(function(){
   jQuery('#taxpayer_spouse_name__row').hide();
   jQuery('#taxpayer_married').change(function(){
        if(jQuery('#taxpayer_married').attr('checked'))
            jQuery('#taxpayer_spouse_name__row').show();
        else jQuery('#taxpayer_spouse_name__row').hide();});
});
</script>
\end{lstlisting}

The script in the view has the effect of hiding the row containing the spouse's name:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7500.png}\end{center}


When the taxpayer checks the "married" checkbox, the spouse's name field reappears:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7600.png}\end{center}


Here "taxpayer\_married" is the checkbox associated to the "boolean" field "married" of table "taxpayer". "taxpayer\_spouse\_name\_\_row" is the row containing the input field for "spouse\_name" of table "taxpayer".

\goodbreak\subsection{Confirmation on delete}

\inxx{confirmation}

Another useful application is requiring confirmation when checking a "delete" checkbox such as the delete checkbox that appears in edit forms.

Consider the above example and add the following controller action:
\begin{lstlisting}
def edit():
    row = db.taxpayer[request.args(0)]
    form = SQLFORM(db.taxpayer, row, deletable=True)
    if form.process().accepted:
        response.flash = 'record updated'
    return dict(form=form)
\end{lstlisting}
\noindent and the corresponding view "default/edit.html"
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=form}}
\end{lstlisting}

\inxx{deletable}
The {\ft deletable=True} argument in the SQLFORM constructor instructs web2py to display a "delete" checkbox in the edit form. It is {\ft False} by default.
\noindent web2py's "web2py.js" includes the following code:
\begin{lstlisting}
jQuery(document).ready(function(){
   jQuery('input.delete').attr('onclick',
     'if(this.checked) if(!confirm(
        "{{=T('Sure you want to delete this object?')}}"))
      this.checked=false;');
});
\end{lstlisting}

By convention this checkbox has a class equal to "delete". The jQuery code above connects the onclick event of this checkbox with a confirmation dialog (standard in JavaScript) and unchecks the checkbox if the taxpayer does not confirm:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7700.png}\end{center}


\goodbreak\section{The {\ft ajax} function}

In web2py.js, web2py defines a function called {\ft ajax} which is based on, but should not be confused with, the jQuery function {\ft \$.ajax}. The latter is much more powerful than the former, and for its usage, we refer you to ref.~\cite{jquery} and ref.~\cite{jquery-b}. However, the former function is sufficient for many complex tasks, and is easier to use.

The {\ft ajax} function is a JavaScript function that has the following syntax:
\begin{lstlisting}
ajax(url, [name1, name2, ...], target)
\end{lstlisting}

It asynchronously calls the url (first argument), passes the values of the field inputs with the name equal to one of the names in the list (second argument), then stores the response in the innerHTML of the tag with the id equal to target (the third argument).

Here is an example of a {\ft default} controller:
\begin{lstlisting}
def one():
    return dict()

def echo():
    return request.vars.name
\end{lstlisting}
\noindent and the associated "default/one.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<form>
   <input name="name" onkeyup="ajax('echo', ['name'], 'target')" />
</form>
<div id="target"></div>
\end{lstlisting}

When you type something in the INPUT field, as soon as you release a key (onkeyup), the {\ft ajax} function is called, and the value of the {\ft name="name"} field is passed to the action "echo", which sends the text back to the view. The {\ft ajax} function receives the response and displays the echo response in the "target" DIV.

\goodbreak\subsection{Eval target}

The third argument of the {\ft ajax} function can be the string ":eval". This means that the string returned by server will not be embedded in the document but it will be evaluated instead.

Here is an example of a {\ft default} controller:
\begin{lstlisting}
def one():
    return dict()

def echo():
    return "jQuery('#target').html(%s);" % repr(request.vars.name)
\end{lstlisting}
\noindent and the associated "default/one.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<form>
   <input name="name" onkeyup="ajax('echo', ['name'], ':eval')" />
</form>
<div id="target"></div>
\end{lstlisting}

This allows for more complex responses that can update multiple targets.

\goodbreak\subsection{Auto-completion}

Web2py contains a built-in autocomplete widget, described in the Forms chapter. Here we will build a simpler one from scratch.

Another application of the above {\ft ajax} function is auto-completion. Here we wish to create an input field that expects a month name and, when the visitor types an incomplete name, performs auto-completion via an Ajax request. In response, an auto-completion drop-box appears below the input field.

This can be achieved via the following {\ft default} controller:
\begin{lstlisting}
def month_input():
    return dict()

def month_selector():
    if not request.vars.month: return ''
    months = ['January', 'February', 'March', 'April', 'May',
              'June', 'July', 'August', 'September' ,'October',
              'November', 'December']
    month_start = request.vars.month.capitalize()
    selected = [m for m in months if m.startswith(month_start)]
    return DIV(*[DIV(k,
                     _onclick="jQuery('#month').val('%s')" % k,
                     _onmouseover="this.style.backgroundColor='yellow'",
                     _onmouseout="this.style.backgroundColor='white'"
                     ) for k in selected])
\end{lstlisting}
\noindent and the corresponding "default/month\_input.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
<style>
#suggestions { position: relative; }
.suggestions { background: white; border: solid 1px #55A6C8; }
.suggestions DIV { padding: 2px 4px 2px 4px; }
</style>

<form>
 <input type="text" id="month" name="month" style="width: 250px" /><br />
 <div style="position: absolute;" id="suggestions"
      class="suggestions"></div>
</form>
<script>
jQuery("#month").keyup(function(){
      ajax('month_selector', ['month'], 'suggestions')});
</script>
\end{lstlisting}

The jQuery script in the view triggers the Ajax request each time the visitor types something in the "month" input field. The value of the input field is submitted with the Ajax request to the "month\_selector" action. This action finds a list of month names that start with the submitted text (selected), builds a list of DIVs (each one containing a suggested month name), and returns a string with the serialized DIVs. The view displays the response HTML in the "suggestions" DIV. The "month\_selector" action generates both the suggestions and the JavaScript code embedded in the DIVs that must be executed when the visitor clicks on each suggestion. For example when the visitor types "M" the callback action returns:
\begin{lstlisting}[keywords={}]
<div>
     <div onclick="jQuery('#month').val('March')"
          onmouseout="this.style.backgroundColor='white'"
          onmouseover="this.style.backgroundColor='yellow'">March</div>
     <div onclick="jQuery('#month').val('May')"
          onmouseout="this.style.backgroundColor='white'"
          onmouseover="this.style.backgroundColor='yellow'">May</div>
</div>
\end{lstlisting}

Here is the final effect:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en7800.png}\end{center}


If the months are stored in a database table such as:
\begin{lstlisting}
db.define_table('month', Field('name'))
\end{lstlisting}
\noindent then simply replace the {\ft month\_selector} action with:
\begin{lstlisting}
def month_input():
    return dict()

def month_selector():
    if not request.vars.month:
        return ''
    pattern = request.vars.month.capitalize() + '%'
    selected = [row.name for row in db(db.month.name.like(pattern)).select()]
    return ''.join([DIV(k,
                 _onclick="jQuery('#month').val('%s')" % k,
                 _onmouseover="this.style.backgroundColor='yellow'",
                 _onmouseout="this.style.backgroundColor='white'"
                 ).xml() for k in selected])
\end{lstlisting}
\noindent jQuery provides an optional Auto-complete Plugin with additional functionalities, but that is not discussed here.

\goodbreak\subsection{Ajax form submission}

\inxx{asynchronous}

Here we consider a page that allows the visitor to submit messages using Ajax without reloading the entire page. Using the LOAD helper, web2py provides a better mechanism for doing it than described here, which will be described in Chapter 12. Here we want to show you how to do it simply using jQuery.

It contains a form "myform" and a "target" DIV. When the form is submitted, the server may accept it (and perform a database insert) or reject it (because it did not pass validation). The corresponding notification is returned with the Ajax response and displayed in the "target" DIV.

Build a {\ft test} application with the following model:
\begin{lstlisting}
db = DAL('sqlite://db.db')
db.define_table('post', Field('your_message', 'text'))
db.post.your_message.requires = IS_NOT_EMPTY()
\end{lstlisting}

Notice that each post has a single field "your\_message" that is required to be not-empty.

Edit the {\ft default.py} controller and  write two actions:
\begin{lstlisting}
def index():
    return dict()

def new_post():
    form = SQLFORM(db.post)
    if form.accepts(request, formname=None):
        return DIV("Message posted")
    elif form.errors:
        return TABLE(*[TR(k, v) for k, v in form.errors.items()])
\end{lstlisting}

The first action does nothing other than return a view.

The second action is the Ajax callback. It expects the form variables in {\ft request.vars}, processes them and returns {\ft DIV("Message posted")} upon success or a {\ft TABLE} of error messages upon failure.

Now edit the "default/index.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}

<div id="target"></div>

<form id="myform">
  <input name="your_message" id="your_message" />
  <input type="submit" />
</form>

<script>
jQuery('#myform').submit(function() {
  ajax('{{=URL('new_post')}}',
       ['your_message'], 'target');
  return false;
});
</script>
\end{lstlisting}

Notice how in this example the form is created manually using HTML, but it is processed by the SQLFORM in a different action than the one that displays the form. The SQLFORM object is never serialized in HTML. {\ft SQLFORM.accepts} in this case does not take a session and sets {\ft formname=None}, because we chose not to set the form name and a form key in the manual HTML form.

The script at the bottom of the view connects the "myform" submit button to an inline function which submits the INPUT with {\ft id="your\_message"} using the web2py {\ft ajax} function, and displays the answer inside the DIV with {\ft id="target"}.

\goodbreak\subsection{Voting and rating}

Another Ajax application is voting or rating items in a page. Here we consider an application that allows visitors to vote on posted images. The application consists of a single page that displays the images sorted according to their vote. We will allow visitors to vote multiple times, although it is easy to change this behavior if visitors are authenticated, by keeping track of the individual votes in the database and associating them with the {\ft request.env.remote\_addr} of the voter.

Here is a sample model:
\begin{lstlisting}
db = DAL('sqlite://images.db')
db.define_table('item',
    Field('image', 'upload'),
    Field('votes', 'integer', default=0))
\end{lstlisting}

Here is the {\ft default} controller:
\begin{lstlisting}
def list_items():
    items = db().select(db.item.ALL, orderby=db.item.votes)
    return dict(items=items)

def download():
    return response.download(request, db)

def vote():
    item = db.item[request.vars.id]
    new_votes = item.votes + 1
    item.update_record(votes=new_votes)
    return str(new_votes)
\end{lstlisting}

The download action is necessary to allow the list\_items view to download images stored in the "uploads" folder. The votes action is used for the Ajax callback.

Here is the "default/list\_items.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}

<form><input type="hidden" id="id" name="id" value="" /></form>
{{for item in items:}}
<p>
<img src="{{=URL('download', args=item.image)}}"
     width="200px" />
<br />
Votes=<span id="item{{=item.id}}">{{=item.votes}}</span>
[<span onclick="jQuery('#id').val('{{=item.id}}');
       ajax('vote', ['id'], 'item{{=item.id}}');">vote up</span>]
</p>
{{pass}}
\end{lstlisting}

When the visitor clicks on "[vote up]" the JavaScript code stores the item.id in the hidden "id" INPUT field and submits this value to the server via an Ajax request. The server increases the votes counter for the corresponding record and returns the new vote count as a string. This value is then inserted in the target {\ft item\{\{=item.id\}\}} SPAN.

\begin{quote}Ajax callbacks can be used to perform computations in the background, but we recommend using {\bf cron} or a background process instead (discussed in chapter 4), since the web server enforces a timeout on threads. If the computation takes too long, the web server kills it. Refer to your web server parameters to set the timeout value.\end{quote}
\goodbreak\chapter{Components and plugins}

\inxx{component}
\inxx{plugin}

Components and plugins are relatively new features of web2py, and there is some disagreement between developers about what they are and what they should be. Most of the confusion stems from the different uses of these terms in other software projects and from the fact that developers are still working to finalize the specifications.

However, plugin support is an important feature and we need to provide some definitions. These definitions are not meant to be final, just consistent with the programming patterns we want to discuss in this chapter.

We will try to address two issues here:

\begin{itemize}
\item How can we build modular applications that minimize server load and maximize code reuse?

\item How can we distribute pieces of code in a more or less plugin-and-play fashion?
\end{itemize}

{\it Components} address the first issue; {\it plugins} address the second.

\goodbreak\section{Components}

\inxx{load}
\inxx{LOAD}
\inxx{Ajax}

\begin{quote}A {\bf component} is a functionally autonomous part of a web page.\end{quote}
A component may be composed of modules, controllers and views, but there is no strict requirement other than, when embedded in a web page, it must be localized within an html tag (for example a DIV, a SPAN, or an IFRAME) and it must perform its task independently of the rest of the page. We are specifically interested in components that are loaded in the page and communicate with the component controller function via Ajax.

An example of a component is a "comments component" that is contained into a DIV and shows users' comments and a post-new-comment form. When the form is submitted, it is sent to the server via Ajax, the list is updated, and the comment is stored server-side in the database. The DIV content is refreshed without reloading the rest of the page.

The web2py LOAD function makes this easy to do without explicit JavaScript/Ajax knowledge or programming.

Our goal is to be able to develop web applications by assembling components into page layouts.

Consider a simple web2py app "test" that extends the default scaffolding app with a custom model in file "models/db\_comments.py":

\begin{lstlisting}
db.define_table('comment_post',
   Field('body','text',label='Your comment'),
   auth.signature)
\end{lstlisting}
\noindent one action in "controllers/comments.py"

\begin{lstlisting}
@auth.requires_login()
def post():
    return dict(form=SQLFORM(db.comment_post).process(),
                comments=db(db.comment_post).select())
\end{lstlisting}
\noindent and the corresponding "views/comments/post.html"

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{for post in comments:}}
<div class="post">
  On {{=post.created_on}} {{=post.created_by.first_name}}
  says <span class="post_body">{{=post.body}}</span>
</div>
{{pass}}
{{=form}}
\end{lstlisting}

You can access it as usual at:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/test/comments/post
\end{lstlisting}

So far there is nothing special in this action, but we can turn it into a component by defining a new view with extension ".load" that does not extend the layout.

Hence we create a "views/comments/post.load":

\begin{lstlisting}[keywords={}]
{{for post in comments:}}
<div class="post">
  On {{=post.created_on}} {{=post.created_by.first_name}}
  says <blockquote class="post_body">{{=post.body}}</blockquote>
</div>
{{pass}}
{{=form}}
\end{lstlisting}

We can access it at the URL

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/test/comments/post.load
\end{lstlisting}

This is a component that we can embed into any other page by simply doing

\begin{lstlisting}[keywords={}]
{{=LOAD('comments','post.load',ajax=True)}}
\end{lstlisting}

For example in "controllers/default.py" we can edit

\begin{lstlisting}
def index():
    return dict()
\end{lstlisting}
\noindent and in the corresponding view add the component:

\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}
{{=LOAD('comments','post.load',ajax=True)}}
\end{lstlisting}

Visiting the page

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8000/test/default/index
\end{lstlisting}
\noindent will show the normal content and the comments component:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en8100.png}\end{center}


The {\ft \{\{=LOAD(...)\}\}} component is rendered as follows:

\begin{lstlisting}[keywords={}]
<script type="text/javascript"><!--
web2py_component("/test/comment/post.load","c282718984176")
//--></script><div id="c282718984176">loading...</div>
\end{lstlisting}

(the actual generated code depends on the options passed to the LOAD function).

The {\ft web2py\_component(url,id)} function is defined in "web2py\_ajax.html" and it performs all the magic: it calls the {\ft url} via Ajax and embeds the response into the DIV with corresponding {\ft id}; it traps every form submission into the DIV and submits those forms via Ajax. The Ajax target is always the DIV itself.

The full signature of the LOAD helper is the following:

\begin{lstlisting}
LOAD(c=None, f='index', args=[], vars={},
     extension=None, target=None,
     ajax=False, ajax_trap=False,
     url=None,user_signature=False,
     timeout=None, times=1,
     content='loading...',**attr):
\end{lstlisting}

Here:
\begin{itemize}
\item the first two arguments {\ft c} and {\ft f} are the controller and the function that we want to call respectively.

\item {\ft args} and {\ft vars} are the arguments and variables that we want to pass to the function. The former is a list, the latter is a dictionary.

\item {\ft extension} is an optional extension. Notice that the extension can also be passed as part of the function as in {\ft f='index.load'}.

\item {\ft target} is the {\ft id} of the target DIV. If it is not specified a random target {\ft id} is generated.

\item {\ft ajax} should be set to {\ft True} if the DIV has to be filled via Ajax and to {\ft False} if the DIV has to be filled before the current page is returned (thus avoiding the Ajax call).

\item {\ft ajax\_trap=True} means that any form submission in the DIV must be captured and submitted via Ajax, and the response must be rendered inside the DIV. {\ft ajax\_trap=False} indicates that forms must be submitted normally, thus reloading the entire page. {\ft ajax\_trap} is ignored and assumed to be {\ft True} if {\ft ajax=True}.

\item {\ft url}, if specified, overrides the values of {\ft c}, {\ft f}, {\ft args}, {\ft vars}, and {\ft extension} and loads the component at the {\ft url}. It is used to load as components pages served by other applications (which my or may not be created with web2py).

\item {\ft user\_signature} defaults to False but, if you are logged in, it should be set to True. This will make sure the ajax callback is digitally signed. This is documented in chapter 4.

\item {\ft times} specifies how many times the component is to be requested. Use "infinity" to keep loading the component continuously. This option is useful for triggering regular routines for a given document request.

\item {\ft timeout} sets the time to wait in milliseconds before starting the request or the frequency if {\ft times} is greater than 1.

\item {\ft content} is the content to be displayed while performing the ajax call. It can be a helper as in {\ft content=IMG(..)}.

\item optional {\ft **attr} (attributes) can be passed to the contained {\ft DIV}.
\end{itemize}

If no {\ft .load} view is specified, there is a {\ft generic.load} that renders the dictionary returned by the action without layout. It works best if the dictionary contains a single item.

If you LOAD a component having the {\ft .load} extension and the corresponding controller function redirects to another action (for example a login form), the {\ft .load} extension propagates and the new url (the one to redirect too) is also loaded with a {\ft .load} extension.

If you call an action via Ajax and you want the action to force a redirect of the parent page you can do it with

\begin{lstlisting}
redirect(url,type='auto')
\end{lstlisting}

Because Ajax post does not support multipart forms, i.e. file uploads, upload fields will not work with the LOAD component. You could be fooled into thinking it would work because upload fields will function normally if POST is done from the individual component's.load view. Instead, uploads are done with ajax-compatible 3rd-party widgets and web2py manual upload store commands.

\goodbreak\subsection{Client-Server component communications}

When the action of a component is called via Ajax, web2py passes two HTTP headers with the request:

\begin{lstlisting}
web2py-component-location
web2py-component-element
\end{lstlisting}
\noindent which can be accessed by the action via the variables:

\begin{lstlisting}
request.env.http_web2py_component_location
request.env.http_web2py_component_element
\end{lstlisting}

The latter is also accessible via: \inxx{request.cid}

\begin{lstlisting}
request.cid
\end{lstlisting}

The former contains the URL of the page that called the component action.
The latter contains the {\ft id} of the DIV that will contain the response.

The component action can also store data in two special HTTP response headers that will be interpreted by the full page upon response. They are:

\begin{lstlisting}
web2py-component-flash
web2py-component-command
\end{lstlisting}
\noindent and they can be set via:

\begin{lstlisting}
response.headers['web2py-component-flash']='....'
response.headers['web2py-component-command']='...'
\end{lstlisting}
\noindent or (if the action is called by a component) automatically via:

\begin{lstlisting}
response.flash='...'
response.js='...'
\end{lstlisting}

The former contains text that you want to be flashed upon response.
The latter contains JavaScript code that you want to be executed upon response. It cannot contain newlines.

As an example, let's define a contact form component in "controllers/contact/ask.py" that allows the user to ask a question. The component will email the question to the system administrator, flash a "thank you" message, and remove the component from the page:

\begin{lstlisting}
def ask():
    form=SQLFORM.factory(
        Field('your_email',requires=IS_EMAIL()),
        Field('question',requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        if mail.send(to='admin@example.com',
                  subject='from %s' % form.vars.your_email,
                  message = form.vars.question):
            response.flash = 'Thank you'
            response.js = "jQuery('#%s').hide()" % request.cid
        else:
            form.errors.your_email = "Unable to send the email"
    return dict(form=form)
\end{lstlisting}

The first four lines define the form and accept it. The mail object used for sending is defined in the default scaffolding application. The last four lines implement all the component-specific logic by getting data from the HTTP request headers and setting the HTTP response headers.

Now you can embed this contact form in any page via

\begin{lstlisting}[keywords={}]
{{=LOAD('contact','ask.load',ajax=True)}}
\end{lstlisting}

Notice that we did not define a {\ft .load} view for our {\ft ask} component. We do not have to because it returns a single object (form) and therefore the "generic.load" will do just fine. Remember that generic views are a development tool. In production you should copy "views/generic.load" into "views/contact/ask.load".

\inxx{user\_signature} \inxx{requires\_signature}
We can block access to a function called via Ajax by digitally signing the URL using the {\ft user\_signature} argument:

\begin{lstlisting}[keywords={}]
{{=LOAD('contact','ask.load',ajax=True,user_signature=True)}}
\end{lstlisting}
\noindent which add a digital signature to the URL.
The digital signature must then be validated using a decorator in the callback function:

\begin{lstlisting}
@auth.requires_signature()
def ask(): ...
\end{lstlisting}

\goodbreak\subsection{Trapped Ajax links}

\inxx{A}
\inxx{Ajax links}

Normally a link is not trapped, and by clicking in a link inside a component, the entire linked page is loaded. Sometimes you want the linked page to be loaded inside the component. This can be achieved using the {\ft A} helper:

\begin{lstlisting}[keywords={}]
{{=A('linked page',_href='http://example.com',cid=request.cid)}}
\end{lstlisting}

If {\ft cid} is specified, the linked page is loaded via Ajax.
The {\ft cid} is the {\ft id} of the html element where to place the loaded page content.
In this case we set it to {\ft request.cid}, i.e. the {\ft id} of the component that generates the link. The linked page can be and usually is an internal URL generated using the URL command.

\goodbreak\section{Plugins}

\begin{quote}A {\bf plugin} is any subset of the files of an application.\end{quote}
and we really mean {\it any}:

\begin{itemize}
\item A plugin is not a module, is not a model, it is not a controller, is not a view, yet it may contain modules, models, controllers and/or views.

\item A plugin does not need to be functionally autonomous and it may depend on other plugins or specific user code.

\item A {\it plugin} is not a {\it plugins system} and therefore has no concept of registration nor isolation, although we will give rules to try to achieve some isolation.

\item We are talking about a plugin for your app, not a plugin for web2py.
\end{itemize}

So why is it called a {\it plugin}? Because it provides a mechanism for packing a subset of an app and unpacking it over another app (i.e. {\it plug-in}). Under this definition, any file in your app can be treated as a plugin.

When the app is distributed, its plugins are packed and distributed with it.

In practice, the {\bf admin} provides an interface for packing and unpacking plugins separately from your app. Files and folder of your application that have names with the prefix {\ft plugin\_}{\it name} can be packed together into a file called:

{\ft web2py.plugin.}{\it name}{\ft .w2p}
\noindent and distributed together.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en8200.png}\end{center}


The files that compose a plugin are not treated by web2py any differently than other files except that {\bf admin} understands from their names that they are meant to be distributed together, and it displays them in a separate page:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en8300.png}\end{center}


Yet as a matter of fact, by the definition above, these plugins are more general than those recognized as such by {\bf admin}.

In practice we will only be concerned with two types of plugins:

\begin{itemize}
\item {\it Component Plugins}. These are plugins that contain components as defined in the previous section. A component plugin can contain one or more components. We can think for example of a {\ft plugin\_comments} that contains the {\it comments} component proposed above. Another example could be {\ft plugin\_tagging} that contains a {\it tagging} component and a {\it tag-cloud} component that share some database tables also defined by the plugin.

\item {\it Layout Plugins}. These are plugins that contain a layout view and the static files required by such layout. When the plugin is applied it gives the app a new look and feel.
\end{itemize}

By the above definitions, the components created in the previous section, for example "controllers/contact.py", are already plugins. We can move them from one app to another and use the components they define. Yet they are not recognized as such by {\bf admin} because there is nothing that labels them as plugins. So there are two problems we need to solve:

\begin{itemize}
\item Name the plugin files using a convention, so that {\bf admin} can recognize them as belonging to the same plugin

\item If the plugin has model files, establish a convention so that the objects it defines do not pollute the namespace and do not conflict with each other.
\end{itemize}

Let's assume a plugin is called {\it name}. Here are the rules that should be followed:

{\bf Rule 1}:
Plugin models and controllers should be called, respectively

\begin{itemize}
\item {\ft models/plugin\_}{\it name}{\ft .py}

\item {\ft controllers/plugin\_}{\it name}{\ft .py}
\end{itemize}
\noindent and plugin views, modules, static, and private files should be in folders called, respectively:

\begin{itemize}
\item {\ft views/plugin\_}{\it name}{\ft /}

\item {\ft modules/plugin\_}{\it name}{\ft /}

\item {\ft static/plugin\_}{\it name}{\ft /}

\item {\ft private/plugin\_}{\it name}{\ft /}
\end{itemize}

{\bf Rule 2}:
Plugin models can only define objects with names that start with
\begin{itemize}
\item {\ft plugin\_}{\it name}

\item {\ft Plugin}{\it Name}

\item {\ft \_}
\end{itemize}

{\bf Rule 3}:
Plugin models can only define session variables with names that start with
\begin{itemize}
\item {\ft session.plugin\_}{\it name}

\item {\ft session.Plugin}{\it Name}
\end{itemize}

{\bf Rule 4}:
Plugins should include license and documentation. These should be placed in:
\begin{itemize}
\item {\ft static/plugin\_}{\it name}{\ft /license.html}

\item {\ft static/plugin\_}{\it name}{\ft /about.html}
\end{itemize}

{\bf Rule 5}:
The plugin can only rely on the existence of the global objects defined in scaffolding "db.py", i.e.

\begin{itemize}
\item a database connection called {\ft db}

\item an {\ft Auth} instance called {\ft auth}

\item a {\ft Crud} instance called {\ft crud}

\item a {\ft Service} instance called {\ft service}
\end{itemize}

Some plugins may be more sophisticated and have a configuration parameter in case more than one db instance exists.

{\bf Rule 6}:
If a plugin needs configuration parameters, these should be set via a PluginManager as described below.
\inxx{PluginManager}

By following the above rules we can make sure that:
\begin{itemize}
\item {\bf admin} recognizes all the {\ft plugin\_}{\it name} files and folder as part of a single entity.

\item plugins do not interfere with each other.
\end{itemize}

The rules above do not solve the problem of plugin versions and dependencies. That is beyond our scope.

\goodbreak\subsection{Component plugins}

\inxx{component plugin}

Component plugins are plugins that define components. Components usually access the database and define with their own models.

Here we turn the previous {\ft comments} component into a {\ft comments\_plugin} by using the same code we wrote before, but following all of the previous rules.

First, we create a model called "models/plugin\_comments.py":

\begin{lstlisting}
db.define_table('plugin_comments_comment',
   Field('body','text', label='Your comment'),
   auth.signature)

def plugin_comments():
    return LOAD('plugin_comments','post',ajax=True)
\end{lstlisting}
(notice the last two lines define a function that will simplify the embedding of the plugin)

Second, we define a "controllers/plugin\_comments.py"

\begin{lstlisting}
def post():
    if not auth.user:
        return A('login to comment',_href=URL('default','user/login'))
    comment = db.plugin_comments_comment
    return dict(form=SQLFORM(comment).process(),
                comments=db(comment).select())
\end{lstlisting}

Third, we create a view called "views/plugin\_comments/post.load":

\begin{lstlisting}[keywords={}]
{{for comment in comments:}}
<div class="comment">
  on {{=comment.created_on}} {{=comment.created_by.first_name}}
  says <span class="comment_body">{{=comment.body}}</span>
</div>
{{pass}}
{{=form}}
\end{lstlisting}

Now we can use {\bf admin} to pack the plugin for distribution. Admin will save this plugin as:

\begin{lstlisting}
web2py.plugin.comments.w2p
\end{lstlisting}

We can use the plugin in any view by simply installing the plugin via the {\bf edit} page in {\bf admin} and adding this to our own views

\begin{lstlisting}[keywords={}]
{{=plugin_comments()}}
\end{lstlisting}

Of course we can make the plugin more sophisticated by having components that take parameters and configuration options. The more complex the components, the more difficult it becomes to avoid name collisions. The Plugin Manager described below is designed to avoid this problem.

\goodbreak\subsection{Plugin manager}

The {\ft PluginManager} is a class defined in {\ft gluon.tools}. Before we explain how it works inside, we will explain how to use it.

Here we consider the previous {\ft comments\_plugin} and we make it better. We want to be able to customize:

\begin{lstlisting}
db.plugin_comments_comment.body.label
\end{lstlisting}
\noindent without having to edit the plugin code itself.

Here is how we can do it:

First, rewrite the plugin "models/plugin\_comments.py" in this way:

\begin{lstlisting}
def _():
    from gluon.tools import PluginManager
    plugins = PluginManager('comments', body_label='Your comment')

    db.define_table('plugin_comments_comment',
        Field('body','text',label=plugins.comments.body_label),
        auth.signature)
    return lambda: LOAD('plugin_comments','post.load',ajax=True)
plugin_comments = _()
\end{lstlisting}

Notice how all the code except the table definition is encapsulated in a single function called {\ft \_} so that it does not pollute the global namespace. Also notice how the function creates an instance of a {\ft PluginManager}.

Now in any other model in your app, for example in "models/db.py", you can configure this plugin as follows:

\begin{lstlisting}
from gluon.tools import PluginManager
plugins = PluginManager()
plugins.comments.body_label = T('Post a comment')
\end{lstlisting}

\begin{quote}The {\ft plugins} object is already instantiated in the default scaffolding app in "models/db.py"\end{quote}
The PluginManager object is a thread-level singleton Storage object of Storage objects. That means you can instantiate as many as you like within the same application but (whether they have the same name or not) they act as if there were a single PluginManager instance.

In particular each plugin file can make its own PluginManager object and register itself and its default parameters with it:

\begin{lstlisting}
plugins = PluginManager('name', param1='value', param2='value')
\end{lstlisting}

You can override these parameters elsewhere (for example in "models/db.py") with the code:

\begin{lstlisting}
plugins = PluginManager()
plugins.name.param1 = 'other value'
\end{lstlisting}

You can configure multiple plugins in one place.

\begin{lstlisting}
plugins = PluginManager()
plugins.name.param1 = '...'
plugins.name.param2 = '...'
plugins.name1.param3 = '...'
plugins.name2.param4 = '...'
plugins.name3.param5 = '...'
\end{lstlisting}

\begin{quote}When the plugin is defined, the PluginManager must take arguments: the plugin name and optional named arguments which are default parameters. However, when the plugins are configured, the PluginManager constructor must take no arguments. The configuration must precede the definition of the plugin (i.e. it must be in a model file that comes first alphabetically).\end{quote}
\goodbreak\subsection{Layout plugins}

\inxx{layout plugin}

Layout plugins are simpler than component plugins because usually they do not contain code, but only views and static files. Yet you should still follow  good practice:

First, create a folder called "static/plugin\_layout\_{\it name}/" (where name is the name of your layout) and place all your static files there.

Second, create a layout file called "views/plugin\_layout\_{\it name}/layout.html" that contains your layout and links the images, CSS and JavaScript files in "static/plugin\_layout\_{\it name}/"

Third, modify the "views/layout.html" so that it simply reads:

\begin{lstlisting}[keywords={}]
{{extend 'plugin_layout_name/layout.html'}}
{{include}}
\end{lstlisting}

The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing "views/layout.html". Moreover, "views/layout.html" will not be packed by {\bf admin} together with the plugin, so there is no risk that the plugin will override the user's code in the previously installed layout.

\goodbreak\subsection{Plugins repositories}

While there is no single repository of web2py plugins you can find many of them at one of the following to URLs:

\begin{lstlisting}[keywords={}]
http://dev.s-cubism.com/web2py_plugins
http://web2py.com/plugins
http://web2py.com/layouts
\end{lstlisting}

Here is a screenshot from the s-cubism repository:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/plugins.png}\end{center}


\goodbreak\chapter{Deployment recipes}

There are multiple ways to deploy web2py in a production environment. The details depend on the configuration and the services provided by the host.

In this chapter we consider the following issues:
\begin{itemize}
\item Production deployment (Apache, Nginx, Lighttpd, Cherokee)

\item Security

\item Scalability using Redis and a load balancer.

\item Deployment on PythonAnywhere, Heroku, Amazon EC2, and on the Google App Engine platform(GAE~\cite{gae} )
\end{itemize}

\inxx{Apache} \inxx{CGI} \inxx{mod\_python} \inxx{mod\_wsgi} \inxx{mod\_proxy}
\inxx{WSGI} \inxx{Nginx} \inxx{Heroku} \inxx{PythonAnywhere}
\noindent web2py comes with an SSL~\cite{ssl}  enabled web server, the Rocket wsgiserver~\cite{rocket}. While this is a fast web server, it has limited configuration capabilities. For this reason it is best to deploy web2py behind Apache~\cite{apache},~\cite{Nginx} Lighttpd~\cite{lighttpd}  or Cherokee~\cite{cherokee}. These are free and open-source web servers that are customizable and have been proven to be reliable in high traffic production environments. They can be configured to serve static files directly, deal with HTTPS, and pass control to web2py for dynamic content.

Until a few years ago, the standard interface for communication between web servers and web applications was the Common Gateway Interface (CGI)~\cite{cgi}. The main problem with CGI is that it creates a new process for each HTTP request. If the web application is written in an interpreted language, each HTTP request served by the CGI scripts starts a new instance of the interpreter. This is slow, and it should be avoided in a production environment. Moreover, CGI can only handle simple responses. It cannot handle, for example, file streaming.
\noindent web2py provides a file {\ft cgihandler.py} to interface to CGI.

One solution to this problem is to use the mod\_python module for Apache. We discuss it here because its use is still very common, though the mod\_python project has officially been abandoned by the Apache Software Foundation. mod\_python starts one instance of the Python interpreter when Apache starts, and serves each HTTP request in its own thread without having to restart Python each time. This is a better solution than CGI, but it is not an optimal solution, since mod\_python uses its own interface for communication between the web server and the web application. In mod\_python, all hosted applications run under the same user-id/group-id, which presents security issues.
\noindent web2py provides a file {\ft modpythonhandler.py} to interface to mod\_python.

In the last few years, the Python community has come together behind a new standard interface for communication between web servers and web applications written in Python. It is called Web Server Gateway Interface (WSGI)~\cite{wsgi-w}~\cite{wsgi-o}. web2py was built on WSGI, and it provides handlers for using other interfaces when WSGI is not available.

Apache supports WSGI via the module mod\_wsgi~\cite{modwsgi}  developed by Graham Dumpleton.
\noindent web2py provides a file {\ft wsgihandler.py} to interface to WSGI.

Some web hosting services do not support mod\_wsgi. In this case, we must use Apache as a proxy and forward all incoming requests to the web2py built-in web server (running for example on localhost:8000).

In both cases, with mod\_wsgi and/or mod\_proxy, Apache can be configured to serve static files and deal with SSL encryption directly, taking the burden off web2py.

Nginx uses uWSGI instead of WSGI, a similar but different protocol which requires its own python adapter.

The Lighttpd web server does not currently support the WSGI interface, but it does support the FastCGI~\cite{fastcgi}  interface, which is an improvement over CGI. FastCGI's main aim is to reduce the overhead associated with interfacing the web server and CGI programs, allowing a server to handle more HTTP requests at once.

According to the Lighttpd web site, "Lighttpd powers several popular Web 2.0 sites such as YouTube and Wikipedia. Its high speed IO-infrastructure allows them to scale several times better with the same hardware than with alternative web-servers". Lighttpd with FastCGI is, in fact, faster than Apache with mod\_wsgi.
\noindent web2py provides a file {\ft fcgihandler.py} to interface to FastCGI.
\noindent web2py also includes a {\ft gaehandler.py} to interface with the
Google App Engine (GAE). On GAE, web applications run "in the cloud". This means that the framework completely abstracts any hardware details. The web application is automatically replicated as many times as necessary to serve all concurrent requests. Replication in this case means more than multiple threads on a single server; it also means multiple processes on different servers. GAE achieves this level of scalability by blocking write access to the file system, and all persistent information must be stored in the Google BigTable datastore or in memcache.

On non-GAE platforms, scalability is an issue that needs to be addressed, and it may require some tweaks in the web2py applications. The most common way to achieve scalability is by using multiple web servers behind a load-balancer (a simple round robin, or something more sophisticated, receiving heartbeat feedback from the servers).

Even if there are multiple web servers, there must be one, and only one, database server. By default, web2py uses the file system for storing sessions, error tickets, uploaded files, and the cache. This means that in the default configuration, the corresponding folders have to be shared folders.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en9100.png}\end{center}


In the rest of the chapter, we consider various recipes that may provide an improvement over this naive approach, including:
\begin{itemize}
\item Store sessions in the database, in cache or do not store sessions at all.

\item Store tickets on local filesystem and move them into the database in batches.

\item Use memcache instead of cache.ram and cache.disk.

\item Store uploaded files in the database instead of the shared filesystem.
\end{itemize}

While we recommend following the first three recipes, the fourth recipe may provide an advantage mainly in the case of small files, but may be counterproductive for large files.

\goodbreak\section{{\ft anyserver.py}}

\inxx{anyserver} \inxx{bjoern} \inxx{cgi} \inxx{cherrypy} \inxx{diesel} \inxx{eventlet} \inxx{fapws} \inxx{flup} \inxx{gevent} \inxx{gnuicorn} \inxx{mongrel2} \inxx{paste} \inxx{tornado} \inxx{twisted} \inxx{wsgiref}

Web2py comes with a file called {\ft anyserver.py} that implements WSGI interfaces to the following popular servers: bjoern, cgi, cherrypy, diesel, eventlet,
fapws, flup, gevent, gnuicorn, mongrel2, paste,
rocket, tornado,  twisted, wsgiref

You can use any of these servers, for example Tornado, simply by doing:

\begin{lstlisting}
python anyserver.py -s tornado -i 127.0.0.1 -p 8000 -l -P
\end{lstlisting}

Here {\ft -l} is for logging and {\ft -P} is for the profiler.
For information on all the command line options use "-h":

\begin{lstlisting}
python anyserver.py -h
\end{lstlisting}

\goodbreak\section{Linux and Unix}

\goodbreak\subsection{One step production deployment}

Here are some steps to install apache+python+mod\_wsgi+web2py+postgresql from scratch.

On Ubuntu:
\begin{lstlisting}
wget http://web2py.googlecode.com/hg/scripts/setup-web2py-ubuntu.sh
chmod +x setup-web2py-ubuntu.sh
sudo ./setup-web2py-ubuntu.sh
\end{lstlisting}
On Fedora:
\begin{lstlisting}
wget http://web2py.googlecode.com/hg/scripts/setup-web2py-fedora.sh
chmod +x setup-web2py-fedora.sh
sudo ./setup-web2py-fedora.sh
\end{lstlisting}
Both of these scripts should run out of the box, but every Linux installation is a bit different, so make sure you check the source code of these scripts before you run them. In the case of Ubuntu, most of what they do is explained below. They do not implement the scalability optimizations discussed below.

\goodbreak\subsection{Apache setup}

In this section, we use Ubuntu 8.04 Server Edition as the reference platform. The configuration commands are very similar on other Debian-based Linux distribution, but they may differ for Fedora-based systems (which uses {\ft yum} instead of {\ft apt-get}).

First, make sure all the necessary Python and Apache packages are installed by typing the following shell commands:
\begin{lstlisting}
sudo apt-get update
sudo apt-get -y upgrade
sudo apt-get -y install openssh-server
sudo apt-get -y install python
sudo apt-get -y install python-dev
sudo apt-get -y install apache2
sudo apt-get -y install libapache2-mod-wsgi
sudo apt-get -y install libapache2-mod-proxy-html
\end{lstlisting}

Then, enable the SSL module, the proxy module, and the WSGI module in Apache:
\begin{lstlisting}
sudo ln -s /etc/apache2/mods-available/proxy_http.load \
           /etc/apache2/mods-enabled/proxy_http.load
sudo a2enmod ssl
sudo a2enmod proxy
sudo a2enmod proxy_http
sudo a2enmod wsgi
\end{lstlisting}

Create the SSL folder, and put the SSL certificates inside it:
\begin{lstlisting}
sudo mkdir /etc/apache2/ssl
\end{lstlisting}

You should obtain your SSL certificates from a trusted Certificate Authority such as verisign.com, but, for testing purposes, you can generate your own self-signed certificates following the instructions in ref.~\cite{openssl}

Then restart the web server:
\begin{lstlisting}
sudo /etc/init.d/apache2 restart
\end{lstlisting}

The Apache configuration file is:
\begin{lstlisting}
/etc/apache2/sites-available/default
\end{lstlisting}

The Apache logs are in:
\begin{lstlisting}
/var/log/apache2/
\end{lstlisting}

\goodbreak\subsection{mod\_wsgi}

Download and unzip web2py source on the machine where you installed the web server above.

Install web2py under {\ft /home/www-data/}, for example, and give ownership to user www-data and group www-data. These steps can be performed with the following shell commands:
\begin{lstlisting}
cd /home/www-data/
sudo wget http://web2py.com/examples/static/web2py_src.zip
sudo unzip web2py_src.zip
sudo chown -R www-data:www-data /home/www-data/web2py
\end{lstlisting}

To set up web2py with mod\_wsgi, create a new Apache configuration file:
\begin{lstlisting}
/etc/apache2/sites-available/web2py
\end{lstlisting}
\noindent and include the following code:
\begin{lstlisting}[keywords={}]
<VirtualHost *:80>
  ServerName web2py.example.com
  WSGIDaemonProcess web2py user=www-data group=www-data display-name=%{GROUP}
  WSGIProcessGroup web2py
  WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

  <Directory /home/www-data/web2py>
    AllowOverride None
    Order Allow,Deny
    Deny from all
    <Files wsgihandler.py>
      Allow from all
    </Files>
  </Directory>

  AliasMatch ^/([^/]+)/static/(.*) \
           /users/www-data/web2py/applications/$1/static/$2
  <Directory /users/www-data/web2py/applications/*/static/>
    Order Allow,Deny
    Allow from all
  </Directory>

  <Location /admin>
  Deny from all
  </Location>

  <LocationMatch ^/([^/]+)/appadmin>
  Deny from all
  </LocationMatch>

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log
</VirtualHost>
\end{lstlisting}

When you restart Apache, it should pass all the requests to web2py without going through the Rocket wsgiserver.

Here are some explanations:
\begin{lstlisting}
WSGIDaemonProcess web2py user=www-data group=www-data display-name=%{GROUP}
\end{lstlisting}
\noindent defines a daemon process group in context of "web2py.example.com". By
defining this inside of the virtual host, only this virtual host can access this using WSGIProcessGroup, including any virtual host with the same server name but on a different
port. The "user" and "group"
options should be set to the user who has write access to the
directory where web2py was setup. You do not need to set "user" and
"group" if you made the web2py installation directory writable by
the default user that Apache runs as. The "display-name" option
makes the process name appears in {\ft ps} output as "(wsgi-web2py)"
instead of as name of Apache web server executable. As no "processes"
or "threads" options are specified, the daemon process group will have a
single process with 15 threads running within that process. This is
usually more than adequate for most sites and should be left as is.
If overriding it, do not use "processes=1" as doing so will disable
any in-browser WSGI debugging tools that check the "wsgi.multiprocess"
flag. This is because any use of the "processes" option will cause
that flag to be set to true, even a single process, and such tools
expect that it be set to false. Note: if your application code
or third party extension module is not
thread safe, use options "processes=5 threads=1" instead. This will
create five processes in the daemon process group where each process
is single threaded. You might consider using "maximum-requests=1000"
if your application leaks Python objects because it is unable to garbage collect properly.
\begin{lstlisting}
WSGIProcessGroup web2py
\end{lstlisting}
\noindent delegates running of all WSGI applications to the daemon process group
that was configured using the WSGIDaemonProcess directive.
\begin{lstlisting}
WSGIScriptAlias / /users/www-data/web2py/wsgihandler.py
\end{lstlisting}
\noindent mounts the web2py application. In this case it is mounted at the root
of the web site.
\begin{lstlisting}[keywords={}]
<Directory /users/www-data/web2py>
  ...
</Directory>
\end{lstlisting}
\noindent gives Apache permission to access the WSGI script file.
\begin{lstlisting}[keywords={}]
<Directory /users/www-data/web2py/applications/*/static/>
  Order Allow,Deny
  Allow from all
</Directory>
\end{lstlisting}

Instructs Apache to bypass web2py when searching static files.
\begin{lstlisting}[keywords={}]
<Location /admin>
  Deny from all
</Location>
\end{lstlisting}
\noindent and
\begin{lstlisting}[keywords={}]
<LocationMatch ^/([^/]+)/appadmin>
  Deny from all
</LocationMatch>
\end{lstlisting}
\noindent blocks public access to {\bf admin} and {\bf appadmin}

Normally we would just allow permission to the whole directory where the WSGI
script file is located, but web2py places
the WSGI script file in a directory which contains other source code,
including the admin interface password. Opening up
the whole directory would cause security issues, because technically
Apache would be given permission to serve all the files up to any user
who traversed to that directory via a mapped URL.
To avoid security problems, explicitly deny access to the contents of
the directory, except for the WSGI script file, and prohibit a user
from doing any overrides from a.htaccess file to be extra safe.

You can find a completed, commented, Apache wsgi configuration file in:
\begin{lstlisting}
scripts/web2py-wsgi.conf
\end{lstlisting}

This section was created with help from Graham Dumpleton, developer of mod\_wsgi.

\goodbreak\subsection{Setting password}

In production it may be necessary to set the admin password programmatically.
This can be done from the Bash shell with

\begin{lstlisting}
sudo -u www-data python -c "from gluon.main import save_password; save_password(raw_input('admin password: '),443)"
\end{lstlisting}

\goodbreak\subsection{mod\_wsgi and SSL}

To force some applications (for example {\bf admin} and {\bf appadmin}) to go over HTTPS, store the SSL certificate and key files:
\begin{lstlisting}
/etc/apache2/ssl/server.crt
/etc/apache2/ssl/server.key
\end{lstlisting}
\noindent and edit the Apache configuration file {\ft web2py.conf} and append:
\begin{lstlisting}[keywords={}]
<VirtualHost *:443>
  ServerName web2py.example.com
  SSLEngine on
  SSLCertificateFile /etc/apache2/ssl/server.crt
  SSLCertificateKeyFile /etc/apache2/ssl/server.key

  WSGIProcessGroup web2py

  WSGIScriptAlias / /users/www-data/web2py/wsgihandler.py

  <Directory /users/www-data/web2py>
    AllowOverride None
    Order Allow,Deny
    Deny from all
    <Files wsgihandler.py>
      Allow from all
    </Files>
  </Directory>

  AliasMatch ^/([^/]+)/static/(.*) \
        /users/www-data/web2py/applications/$1/static/$2

  <Directory /users/www-data/web2py/applications/*/static/>
    Order Allow,Deny
    Allow from all
  </Directory>

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log

</VirtualHost>
\end{lstlisting}

Restart Apache and you should be able to access:

\begin{lstlisting}[keywords={}]
https://www.example.com/admin
https://www.example.com/examples/appadmin
http://www.example.com/examples
\end{lstlisting}
\noindent but not:

\begin{lstlisting}[keywords={}]
http://www.example.com/admin
http://www.example.com/examples/appadmin
\end{lstlisting}

\goodbreak\subsection{mod\_proxy}

Some Unix/Linux distributions can run Apache, but do not support mod\_wsgi. In this case, the simplest solution is to run Apache as a proxy and have Apache deal with static files only.

Here is a minimalist Apache configuration:
\begin{lstlisting}
NameVirtualHost *:80
#### deal with requests on port 80
<VirtualHost *:80>
   Alias / /users/www-data/web2py/applications
   ### serve static files directly
   <LocationMatch "^/welcome/static/.*">
    Order Allow, Deny
    Allow from all
   </LocationMatch>
   ### proxy all the other requests
   <Location "/welcome">
     Order deny,allow
     Allow from all
     ProxyRequests off
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
     ProxyHTMLURLMap http://127.0.0.1:8000/welcome/ /welcome
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
\end{lstlisting}

The above script exposes only the "welcome" application. To expose other applications, you need to add the corresponding <Location>...</Location> with the same syntax as done for the "welcome" app.

The script assumes there is a web2py server running on port 8000. Before restarting Apache, make sure this is the case:
\begin{lstlisting}
nohup python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000 &
\end{lstlisting}

You can specify a password with the {\ft -a} option or use the "<recycle>" parameter instead of a password. In the latter case, the previously stored password is reused and the password is not stored in the shell history.

You can also use the parameter "<ask>", to be prompted for a password.

The {\ft nohup} commands makes sure the server does not die when you close the shell. {\ft nohup} logs all output into {\ft nohup.out}.

To force admin and appadmin over HTTPS use the following Apache configuration file instead:
\begin{lstlisting}
NameVirtualHost *:80
NameVirtualHost *:443
#### deal with requests on port 80
<VirtualHost *:80>
   Alias / /users/www-data/web2py/applications
   ### admin requires SSL
   <LocationMatch "^/admin">
     SSLRequireSSL
   </LocationMatch>
   ### appadmin requires SSL
   <LocationMatch "^/welcome/appadmin/.*">
     SSLRequireSSL
   </LocationMatch>
   ### serve static files directly
   <LocationMatch "^/welcome/static/.*">
     Order Allow,Deny
     Allow from all
   </LocationMatch>
   ### proxy all the other requests
   <Location "/welcome">
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
<VirtualHost *:443>
   SSLEngine On
   SSLCertificateFile /etc/apache2/ssl/server.crt
   SSLCertificateKeyFile /etc/apache2/ssl/server.key
   <Location "/">
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/
     ProxyPassReverse http://localhost:8000/
   </Location>
   LogFormat "%h %l %u %t "%r" %>s %b" common
   CustomLog /var/log/apache2/access.log common
</VirtualHost>
\end{lstlisting}

\begin{quote}The administrative interface must be disabled when web2py runs on a shared host with mod\_proxy, or it will be exposed to other users.\end{quote}
\goodbreak\subsection{Start as Linux daemon}

Unless you are using mod\_wsgi, you should setup the web2py server so that it can be started/stopped/restarted as any other Linux daemon, and so it can start automatically at the computer boot stage.

The process to set this up is specific to various Linux/Unix distributions.

In the web2py folder, there are two scripts which can be used for this purpose:
\begin{lstlisting}
scripts/web2py.ubuntu.sh
scripts/web2py.fedora.sh
\end{lstlisting}

On Ubuntu, or other Debian-based Linux distribution, edit "web2py.ubuntu.sh" and replace the "/usr/lib/web2py" path with the path of your web2py installation, then type the following shell commands to move the file into the proper folder, register it as a startup service, and start it:
\begin{lstlisting}
sudo cp scripts/web2py.ubuntu.sh /etc/init.d/web2py
sudo update-rc.d web2py defaults
sudo /etc/init.d/web2py start
\end{lstlisting}

On Fedora, or any other distributions based on Fedora, edit "web2py.fedora.sh" and replace the "/usr/lib/web2py" path with the path of your web2py installation, then type the following shell commands to move the file into the proper folder, register it as a startup service and start it:
\begin{lstlisting}
sudo cp scripts/web2py.fedora.sh /etc/rc.d/init.d/web2pyd
sudo chkconfig --add web2pyd
sudo service web2py start
\end{lstlisting}

\goodbreak\subsection{Nginx}

Nginx is a free, open-source, that has rapidly been gaining popularity for its amazing perfomance.

Unlike traditional servers, Nginx does not use threads. Instead it uses an ansynchronous/event-driven architecture to handle concurrency. This architecture results in a small and predictable memory usage, even under heavy load.

Nginx is more than an HTTP server and reverse proxy, it is also an IMAP/POP3 proxy server.

Nginx is easy to configure and its configuration files and simpler and more compact than the corresponding Apache ones.

Nginx does not support WSGI but provides native support for the uWSGI~\cite{uwsgi} protocol.\inxx{uwsgi}

On Ubuntu you can install Nginx with:
\begin{lstlisting}
apt-get -y install nginx-full
\end{lstlisting}

Then you will need to create a configuration file such as the following:

\begin{lstlisting}
# file /etc/nginx/sites-available/web2py
server {
        listen          80;
        server_name     $hostname;
        #to enable correct use of response.static_version
        #location ~* /(\w+)/static(?:/_[\d]+\.[\d]+\.[\d]+)?/(.*)$ {
        #    alias /home/www-data/web2py/applications/$1/static/$2;
        #    expires max;
        #}
        location ~* /(\w+)/static/ {
            root /home/www-data/web2py/applications/;
            #remove next comment on production
            #expires max;
        }
        location / {
            #uwsgi_pass      127.0.0.1:9001;
            uwsgi_pass      unix:///tmp/web2py.socket;
            include         uwsgi_params;
            uwsgi_param     UWSGI_SCHEME $scheme;
            uwsgi_param     SERVER_SOFTWARE    nginx/$nginx_version;
        }
}
server {
        listen 443 default_server ssl;
        server_name     $hostname;
        ssl_certificate         /etc/nginx/ssl/web2py.crt;
        ssl_certificate_key     /etc/nginx/ssl/web2py.key;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_ciphers ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA;
        ssl_protocols SSLv3 TLSv1;
        keepalive_timeout    70;
        location / {
            #uwsgi_pass      127.0.0.1:9001;
            uwsgi_pass      unix:///tmp/web2py.socket;
            include         uwsgi_params;
            uwsgi_param     UWSGI_SCHEME $scheme;
            uwsgi_param     SERVER_SOFTWARE    nginx/$nginx_version;
        }
 
}
\end{lstlisting}

You will need to symlink the file and remove the default

\begin{lstlisting}
ln -s /etc/nginx/sites-available/web2py /etc/nginx/sites-enabled/web2py
rm /etc/nginx/sites-enabled/default
\end{lstlisting}

You may also need to create the ssl folder for certificates and put certificates in there:
\begin{lstlisting}
mkdir /etc/nginx/ssl
cp web2py.key /etc/nginx/ssl
cp web2py.crt /etc/nginx/ssl
\end{lstlisting}

You then need to install and setup uWSGI

\begin{lstlisting}
sudo mkdir /etc/uwsgi
sudo mkdir /var/log/uwsgi
\end{lstlisting}

And create a configuration file "/etc/uwsgi/web2py.xml":

\begin{lstlisting}[keywords={}]
<uwsgi>
    <socket>/tmp/web2py.socket</socket>
    <pythonpath>/home/www-data/web2py/</pythonpath>
    <mount>/=wsgihandler:application</mount>
    <master/>
    <processes>4</processes>
    <harakiri>60</harakiri>
    <reload-mercy>8</reload-mercy>
    <cpu-affinity>1</cpu-affinity>
    <stats>/tmp/stats.socket</stats>
    <max-requests>2000</max-requests>
    <limit-as>512</limit-as>
    <reload-on-as>256</reload-on-as>
    <reload-on-rss>192</reload-on-rss>
    <uid>www-data</uid>
    <gid>www-data</gid>
    <no-orphans/>
</uwsgi>
\end{lstlisting}

This file assumes web2py is installed under "/home/www-data/web2py", as in the Aapache case.

You also need to edit a second configuration file "/etc/init/uwsgi-emperor.conf":

\begin{lstlisting}
# Emperor uWSGI script 
description "uWSGI Emperor"
start on runlevel [2345]
stop on runlevel [06]
respawn
exec uwsgi --master --die-on-term --emperor /etc/uwsgi --logto /var/log/uwsgi/uwsgi.log
\end{lstlisting}

Finally restart everything:

\begin{lstlisting}
start uwsgi-emperor
/etc/init.d/nginx restart 
\end{lstlisting}

You can reload uwsgi with
\begin{lstlisting}
restart uwsgi-emperor
\end{lstlisting}
You can stop it with
\begin{lstlisting}
stop uwsgi-emperor
\end{lstlisting}
You can reload web2py only (without restarting uwsgi) with
\begin{lstlisting}
touch /etc/uwsgi/web2py.xml
\end{lstlisting}

All these steps are performed automatically by the provided scripts:

\begin{lstlisting}
scripts/setup-web2py-nginx-uwsgi-on-centos.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
\end{lstlisting}

\goodbreak\subsection{Lighttpd}

\inxx{Lighttpd} \inxx{FastCGI} \inxx{fcgihandler}

You can install Lighttpd on a Ubuntu or other Debian-based Linux distribution with the following shell command:
\begin{lstlisting}
apt-get -y install lighttpd
\end{lstlisting}

Once installed, edit {\ft /etc/rc.local} and create a fcgi web2py background process
\begin{lstlisting}
cd /var/www/web2py && sudo -u www-data nohup python fcgihandler.py &
\end{lstlisting}

Then, you need to edit the Lighttpd configuration file
\begin{lstlisting}
/etc/lighttpd/lighttpd.conf
\end{lstlisting}
\noindent so that it can find the socket created by the above process. In the config file, write something like:
\begin{lstlisting}
server.modules              = (
        "mod_access",
        "mod_alias",
        "mod_compress",
        "mod_rewrite",
        "mod_fastcgi",
        "mod_redirect",
        "mod_accesslog",
        "mod_status",
)

server.port = 80
server.bind = "0.0.0.0"
server.event-handler = "freebsd-kqueue"
server.error-handler-404 = "/test.fcgi"
server.document-root = "/users/www-data/web2py/"
server.errorlog      = "/tmp/error.log"

fastcgi.server = (
  "/handler_web2py.fcgi" => (
      "handler_web2py" => ( #name for logs
         "check-local" => "disable",
         "socket" => "/tmp/fcgi.sock"
      )
   ),
)

$HTTP["host"] = "(^|\.)example\.com$" {
 server.document-root="/var/www/web2py"
    url.rewrite-once = (
      "^(/.+?/static/.+)$" => "/applications$1",
      "(^|/.*)$" => "/handler_web2py.fcgi$1",
    )
}
\end{lstlisting}

Now check for syntax errors:
\begin{lstlisting}
lighttpd -t -f /etc/lighttpd/lighttpd.conf
\end{lstlisting}
\noindent and (re)start the web server with:
\begin{lstlisting}
/etc/init.d/lighttpd restart
\end{lstlisting}

Notice that FastCGI binds the web2py server to a Unix socket,
not to an IP socket:
\begin{lstlisting}
/tmp/fcgi.sock
\end{lstlisting}

This is where Lighttpd forwards the HTTP requests to and receives responses from. Unix sockets are lighter than Internet sockets, and this is one of the reasons Lighttpd+FastCGI+web2py is fast.
As in the case of Apache, it is possible to setup Lighttpd to deal with static files directly, and to force some applications over HTTPS. Refer to the Lighttpd documentation for details.

Examples in this section were taken from John Heenan's post in web2pyslices.

\begin{quote}The administrative interface must be disabled when web2py runs on a shared host with FastCGI, or it will be exposed to the other users.\end{quote}
\goodbreak\subsection{Shared hosting with mod\_python}

There are times, specifically on shared hosts, when one does not have the permission to configure the Apache config files directly. At the time of writing most of these hosts still run mod\_python even if it is not maintained any more in favor of mod\_wsgi.

You can still run web2py. Here we show an example of how to set it up.

Place contents of web2py into the "htdocs" folder.

In the web2py folder, create a file "web2py\_modpython.py" file with the following contents:

\begin{lstlisting}
from mod_python import apache
import modpythonhandler

def handler(req):
    req.subprocess_env['PATH_INFO'] = req.subprocess_env['SCRIPT_URL']
    return modpythonhandler.handler(req)
\end{lstlisting}

Create/update the file ".htaccess" with the following contents:

\begin{lstlisting}
SetHandler python-program
PythonHandler web2py_modpython
#PythonDebug On
\end{lstlisting}

This example was provided by Niktar.

\goodbreak\subsection{Cherokee with FastCGI}

\inxx{Cherokee} \inxx{FastCGI}
Cherokee is a very fast web server and, like web2py, it provides an AJAX-enabled web-based interface for its configuration. Its web interface is written in Python. In addition, there is no restart required for most of the changes.

Here are the steps required to setup web2py with Cherokee:

Download Cherokee~\cite{cherokee}

Untar, build, and install:

\begin{lstlisting}
tar -xzf cherokee-0.9.4.tar.gz
cd cherokee-0.9.4
./configure --enable-fcgi && make
make install
\end{lstlisting}

Start web2py normally at least once to make sure it creates the "applications" folder.

Write a shell script named "startweb2py.sh" with the following code:

\begin{lstlisting}
#!/bin/bash
cd /var/web2py
python /var/web2py/fcgihandler.py &
\end{lstlisting}
\noindent and give the script execute privileges and run it.  This will start web2py under FastCGI handler.

Start Cherokee and cherokee-admin:

\begin{lstlisting}
sudo nohup cherokee &
sudo nohup cherokee-admin &
\end{lstlisting}

By default, cherokee-admin only listens at local interface on port 9090. This is not a problem if you have full, physical access on that machine. If this is not the case, you can force it to bind to an IP address and port by using the following options:
\begin{lstlisting}
-b,  --bind[=IP]
-p,  --port=NUM
\end{lstlisting}
\noindent or do an SSH port-forward (more secure, recommended):
\begin{lstlisting}
ssh -L 9090:localhost:9090 remotehost
\end{lstlisting}

Open "http://localhost:9090" in your browser.  If everything is ok, you will get cherokee-admin.

In cherokee-admin web interface, click "info sources".  Choose "Local Interpreter". Write in the following code, then click "Add New".

\begin{lstlisting}
Nick: web2py
Connection: /tmp/fcgi.sock
Interpreter: /var/web2py/startweb2py.sh
\end{lstlisting}

Finally, perform the following remaining steps:
\begin{itemize}
\item Click "Virtual Servers", then click "Default".

\item Click "Behavior", then, under that, click "default".

\item Choose "FastCGI" instead of "List and Send" from the list box.

\item At the bottom, select "web2py" as "Application Server"

\item Put a check in all the checkboxes (you can leave Allow-x-sendfile). If there is a warning displayed, disable and enable one of the checkboxes. (It will automatically re-submit the application server parameter. Sometimes it doesn't, which is a bug).

\item Point your browser to "http://yoursite", and "Welcome to web2py" will appear.
\end{itemize}

\goodbreak\subsection{Postgresql}

PostgreSQL is a free and open source database which is used in demanding production environments, for example, to store the.org domain name database, and has been proven to scale well into hundreds of terabytes of data. It has very fast and solid transaction support, and provides an auto-vacuum feature that frees the administrator from most database maintenance tasks.

On an Ubuntu or other Debian-based Linux distribution, it is easy to install PostgreSQL and its Python API with:
\begin{lstlisting}
sudo apt-get -y install postgresql
sudo apt-get -y install python-psycopg2
\end{lstlisting}

It is wise to run the web server(s) and the database server on different machines. In this case, the machines running the web servers should be connected with a secure internal (physical) network, or should establish SSL tunnels to securely connect with the database server.

Edit the PostgreSQL configuration file
\begin{lstlisting}
sudo nano /etc/postgresql/8.4/main/postgresql.conf
\end{lstlisting}
\noindent and make sure it contains these two lines
\begin{lstlisting}
...
track_counts = on
...
autovacuum = on   # Enable autovacuum subprocess?  'on'
...
\end{lstlisting}

Start the database server with:
\begin{lstlisting}
sudo /etc/init.d/postgresql restart
\end{lstlisting}

When restarting the PostgreSQL server, it should notify which port it is running on. Unless you have multiple database servers, it should be 5432.

The PostgreSQL logs are in:
\begin{lstlisting}
/var/log/postgresql/
\end{lstlisting}

Once the database server is up and running, create a user and a database so that web2py applications can use it:
\begin{lstlisting}
sudo -u postgres createuser -PE -s myuser
postgresql> createdb -O myself -E UTF8 mydb
postgresql> echo 'The following databases have been created:'
postgresql> psql -l
postgresql> psql mydb
\end{lstlisting}

The first of the commands will grant superuser-access to the new user, called {\ft myuser}. It will prompt you for a password.

Any web2py application can connect to this database with the command:
\begin{lstlisting}
db = DAL("postgres://myuser:mypassword@localhost:5432/mydb")
\end{lstlisting}
\noindent where {\ft mypassword} is the password you entered when prompted, and 5432 is the port where the database server is running.

Normally you use one database for each application, and multiple instances of the same application connect to the same database. It is also possible for different applications to share the same database.

For database backup details, read the PostgreSQL documentation; specifically the commands {\ft pg\_dump} and {\ft pg\_restore}.

\goodbreak\subsection{Start the scheduler as a Linux service (upstart)}

To install the scheduler as a permanent daemon on Linux (w/ Upstart), put the following into /etc/init/web2py-scheduler.conf, assuming your web2py instance is installed in <user>'s home directory, running as <user>, with app <myapp>, on network interface eth0.
\begin{lstlisting}
description "web2py task scheduler"
start on (local-filesystems and net-device-up IFACE=eth0)
stop on shutdown
respawn limit 8 60 # Give up if restart occurs 8 times in 60 seconds.
exec sudo -u <user> python /home/<user>/web2py/web2py.py -K <myapp>
respawn
\end{lstlisting}

You can then start/stop/restart/check status of the daemon with:
\begin{lstlisting}
sudo start web2py-scheduler
sudo stop web2py-scheduler
sudo restart web2py-scheduler
sudo status web2py-scheduler
\end{lstlisting}

\goodbreak\section{Windows}

\goodbreak\subsection{Apache and mod\_wsgi}

Installing Apache, and mod\_wsgi under Windows requires a different procedure.
Here are assuming Python 2.5 is installed, you are running from source and web2py is located at {\ft c:/web2py}.

First download the requires packages:
\begin{itemize}
\item Apache {\ft apache\_2.2.11-win32-x86-openssl-0.9.8i.msi} from ~\cite{apache1}

\item mod\_wsgi from~\cite{modwsgi1}
\end{itemize}

Second, run {\ft apache...msi} and follow the wizard screens. On the server information screen


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en9200.png}\end{center}

\noindent enter all requested values:
\begin{itemize}
\item {\bf Network Domain}: enter the DNS domain in which your server is or will be registered in.  For example, if your server's full DNS name is server.mydomain.net, you would type mydomain.net here

\item {\bf ServerName}: Your server's full DNS name. From the example above, you would type server.mydomain.net here. Enter a fully qualified domain name or IP address from the web2py install, not a shortcut, for more information see~\cite{apache2}.

\item {\bf Administrator's Email Address}. Enter the server administrator's or webmaster's email address here. This address will be displayed along with error messages to the client by default.
\end{itemize}

Continue with a typical install to the end unless otherwise required

The wizard, by default, installed Apache in the folder:
\begin{lstlisting}
C:/Program Files/Apache Software Foundation/Apache2.2/
\end{lstlisting}

From now on we refer to this folder simply as {\ft Apache2.2}.

Third, copy the downloaded mod\_wsgi.so to
{\ft Apache2.2/modules}
\noindent written by Chris Travers, published by the Open Source Software Lab at Microsoft, December 2007.

Fourth, create {\ft server.crt} and {\ft server.key} certificates (as discussed in the previous section) and place them in the folder  {\ft Apache2.2/conf}. Notice the cnf file is in {\ft Apache2.2/conf/openssl.cnf}.

Fifth, edit {\ft Apache2.2/conf/httpd.conf},
remove the comment mark (the \# character) from the line
\begin{lstlisting}
LoadModule ssl_module modules/mod_ssl.so
\end{lstlisting}
\noindent add the following line after all the other LoadModule lines
\begin{lstlisting}
LoadModule wsgi_module modules/mod_wsgi.so
\end{lstlisting}
\noindent look for "Listen 80" and add this line after it
\begin{lstlisting}
Listen 443
\end{lstlisting}
\noindent append the following lines at the end changing  drive letter, port number,
ServerName according to your values
\begin{lstlisting}
NameVirtualHost *:443
<VirtualHost *:443>
  DocumentRoot "C:/web2py/applications"
  ServerName server1

  <Directory "C:/web2py">
    Order allow,deny
    Deny from all
  </Directory>

  <Location "/">
    Order deny,allow
    Allow from all
  </Location>

  <LocationMatch "^(/[\w_]*/static/.*)">
    Order Allow,Deny
    Allow from all
  </LocationMatch>

  WSGIScriptAlias / "C:/web2py/wsgihandler.py"

  SSLEngine On
  SSLCertificateFile conf/server.crt
  SSLCertificateKeyFile conf/server.key

  LogFormat "%h %l %u %t "%r" %>s %b" common
  CustomLog logs/access.log common
</VirtualHost>
\end{lstlisting}

Save and check the config using: [Start > Program > Apache HTTP Server 2.2 > Configure Apache Server > Test Configuration]

If there are no problems you will see a command screen open and close.
Now you can start Apache:

[Start > Program > Apache HTTP Server 2.2 > Control Apache Server > Start]
\noindent or better yet start the taskbar monitor

{\ft [Start > Program > Apache HTTP Server 2.2 > Control Apache Server]}

Now you can right-click on the red feather-like taskbar icon to "Open Apache Monitor" and then start, stop and restart Apache as required.

This section was created by Jonathan Lundell.

\goodbreak\subsection{Start as Windows service}

\inxx{Windows service}

What Linux calls a daemon, Windows calls a service.
The web2py server can easily be installed/started/stopped as a Windows service.

In order to use web2py as a Windows service, you must create a file "options.py"
with startup parameters:
\begin{lstlisting}
import socket, os
ip = socket.gethostname()
port = 80
password = '<recycle>'
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
ssl_certificate = "
ssl_private_key = "
numthreads = 10
server_name = socket.gethostname()
request_queue_size = 5
timeout = 10
shutdown_timeout = 5
folder = os.getcwd()
\end{lstlisting}

You don't need to create "options.py" from scratch since there is already an "options\_std.py" in the web2py folder that you can use as a model.

After creating "options.py" in the web2py installation folder, you can install web2py as a service with:
\begin{lstlisting}
python web2py.py -W install
\end{lstlisting}
\noindent optionally you can specify an options.py file:

\begin{lstlisting}
python web2py.py -W install -L options.py
\end{lstlisting}

You can start/stop the service with:
\begin{lstlisting}
python web2py.py -W start
python web2py.py -W stop
\end{lstlisting}

\goodbreak\subsection{Start the scheduler as a Windows service}

\inxx{Windows scheduler service}

Running the scheduler as a Windows service makes a lot of sense.
The easiest approach is to download nssm (from htp://www.nssm.cc). nssm is an open source scheduling helper.
It wraps around an executable command to turn it into a service.
The command to start the scheduler is {\it pythonw.exe -K <appname>}
We use nssm to wrap around this, becoming a service.
Before doing this, you need to choose a name for your service.
There are strong advantages to creating a specific service for each app which needs a scheduler.
Therefore, your naming convention for services may be web2py\_scheduler\_app1

After extracting the zip file, open a Windows command prompt in the folder containing the version for your architecture, and type
\begin{lstlisting}
nssm install web2py_scheduler_app1
\end{lstlisting}

This shows a dialog asking you to enter Application and Options.
Application is the pythonw.exe executable from your Python installation.
Options is
{\ft -K app1}
where app1 is the name of your application.

It is possible to invoke the scheduler with multiple applications. However, in this mode, web2py detaches each application's scheduler into a subprocess.
Therefore, the process started by the service will not die if one of the scheduler instances runs into problems; rather, that child process would die.
We then can't take advantage of automatic restarting of services in case of failure. Using one app per service avoids this weakness.

\goodbreak\section{Securing sessions and {\bf admin}}

\inxx{security} \inxx{admin}

It is very dangerous to publicly expose the {\bf admin} application and the {\bf appadmin} controllers unless they run over HTTPS. Moreover, your password and credentials should never be transmitted unencrypted. This is true for web2py and any other web application.

In your applications, if they require authentication, you should make the session cookies secure with:
\begin{lstlisting}
session.secure()
\end{lstlisting}

An easy way to setup a secure production environment on a server is to first stop web2py and then remove all the {\ft parameters\_*.py} files from the web2py installation folder.  Then start web2py without a password. This will completely disable admin and appadmin.
\begin{lstlisting}
nohup python web2py --nogui -p 8001 -i 127.0.0.1 -a '' &
\end{lstlisting}

Next, start a second web2py instance accessible only from localhost:
\begin{lstlisting}
nohup python web2py --nogui -p 8002 -i 127.0.0.1 -a '<ask>' &
\end{lstlisting}
\noindent and create an SSH tunnel from the local machine (the one from which you wish to access the administrative interface) to the server (the one where web2py is running, example.com), using:
\begin{lstlisting}
ssh -L 8002:127.0.0.1:8002 username@example.com
\end{lstlisting}

Now you can access the administrative interface locally via the web browser at {\ft localhost:8002}.

This configuration is secure because {\bf admin} is not reachable when the tunnel is closed (the user is logged out).

\begin{quote}This solution is secure on shared hosts if and only if other users do not have read access to the folder that contains web2py; otherwise users may be able to steal session cookies directly from the server.\end{quote}
\goodbreak\section{Efficiency and scalability}

\inxx{scalability}
\noindent web2py is designed to be easy to deploy and to setup. This does not mean that it compromises on efficiency or scalability, but it means you may need to tweak it to make it scalable.

In this section we assume multiple web2py installations behind a NAT server that provides local load-balancing.

In this case, web2py works out-of-the-box if some conditions are met. In particular, all instances of each web2py application must access the same database servers and must see the same files. This latter condition can be implemented by making the following folders shared:
\begin{lstlisting}
applications/myapp/sessions
applications/myapp/errors
applications/myapp/uploads
applications/myapp/cache
\end{lstlisting}

The shared folders must support file locking. Possible solutions are ZFS
(ZFS was developed by Sun Microsystems and is the preferred choice.), NFS
(With NFS you may need to run the{\ft nlockmgr} daemon to allow file locking.), or Samba (SMB).

It is possible to share the entire web2py folder or the entire applications folder, but this is not a good idea because this would cause a needless increase of network bandwidth usage.

We believe the configuration discussed above to be very scalable because it reduces the database load by moving to the shared filesystems those resources that need to be shared but do not need transactional safety (only one client at a time is supposed to access a session file, cache always needs a global lock, uploads and errors are write once/read many files).

Ideally, both the database and the shared storage should have RAID capability. Do not make the mistake of storing the database on the same storage as the shared folders, or you will create a new bottleneck there.

On a case-by-case basis, you may need to perform additional optimizations and we will discuss them below. In particular, we will discuss how to get rid of these shared folders one-by-one, and how to store the associated data in the database instead. While this is possible, it is not necessarily a good solution. Nevertheless, there may be reasons to do so. One such reason is that sometimes we do not have the freedom to set up shared folders.

\goodbreak\subsection{Efficiency tricks}
\noindent web2py application code is executed on every request, so you want to minimize this amount of code. Here is what you can do:

\begin{itemize}
\item Run once with {\ft migrate=True} then set all your tables to {\ft migrate=False}.

\item Bytecode compile your app using {\bf admin}.

\item Use {\ft cache.ram} as much as you can but make sure to use a finite set of keys, or else the amount of cache used will grow arbitrarily.

\item Minimize the code in models: do not define functions there, define functions in the controllers that need them or - even better - define functions in modules, import them and use those functions as needed.

\item Do not put many functions in the same controller but use many controllers with few functions.

\item Call {\ft session.forget(response)} in all controllers and/or functions that do not change the session.

\item Try to avoid web2py cron, and use a background process instead. web2py cron can start too many Python instances and cause excessive memory usage.
\end{itemize}

\goodbreak\subsection{Sessions in database}

It is possible to instruct web2py to store sessions in a database instead of in the sessions folder. This has to be done for each individual web2py application, although they may all use the same database to store sessions.

Given a database connection
\begin{lstlisting}
db = DAL(...)
\end{lstlisting}
\noindent you can store the sessions in this database (db) by simply stating the following, in the same model file that establishes the connection:
\begin{lstlisting}
session.connect(request, response, db)
\end{lstlisting}

If it does not exist already, web2py creates, under the hood, a table in the database called {\ft web2py\_session\_}{\it appname} containing the following fields:
\begin{lstlisting}
Field('locked', 'boolean', default=False),
Field('client_ip'),
Field('created_datetime', 'datetime', default=now),
Field('modified_datetime', 'datetime'),
Field('unique_key'),
Field('session_data', 'text')
\end{lstlisting}

"unique\_key" is a uuid key used to identify the session in the cookie.
"session\_data" is the cPickled session data.

To minimize database access, you should avoid storing sessions when they are not needed with:
\begin{lstlisting}
session.forget()
\end{lstlisting}

Sessions are automatically forgotten is unchanged.

With sessions in database, "sessions" folder does not need to be a shared folder because it will no longer be accessed.

\begin{quote}Notice that, if sessions are disabled, you must not pass the {\ft session} to {\ft form.accepts} and you cannot use {\ft session.flash} nor CRUD.\end{quote}
\goodbreak\subsection{HAProxy a high availability load balancer}

\inxx{HAProxy}

If you need multiple web2py processes running on multiple machines, instead of storing sessions in the database or in cache, you have the option to use a load balancer with sticky sessions.

Pound~\cite{pound}  and HAProxy~\cite{haproxy}  are two HTTP load balancers and Reverse proxies that provides sticky sessions. Here we discuss the latter because it seems to be more common on commercial VPS hosting.

By sticky sessions, we mean that once a session cookie has been issued, the load balancer will always route requests from the client associated to the session, to the same server. This allows you to store the session in the local filesystem without need for a shared filesystem.

To use HAProxy:

First, install it, on out Ubuntu test machine:
\begin{lstlisting}
sudo apt-get -y install haproxy
\end{lstlisting}

Second edit the configuration file "/etc/haproxy.cfg" to something like this:
\begin{lstlisting}
## this config needs haproxy-1.1.28 or haproxy-1.2.1

global
      log 127.0.0.1   local0
      maxconn 1024
      daemon

defaults
      log     global
      mode    http
      option  httplog
      option  httpchk
      option  httpclose
      retries 3
      option redispatch
      contimeout      5000
      clitimeout      50000
      srvtimeout      50000

listen 0.0.0.0:80
      balance url_param WEB2PYSTICKY
      balance roundrobin
      server  L1_1 10.211.55.1:7003  check
      server  L1_2 10.211.55.2:7004  check
      server  L1_3 10.211.55.3:7004  check
      appsession WEB2PYSTICKY len 52 timeout 1h
\end{lstlisting}

The {\ft listen} directive tells HAProxy, which port to wait for connection from.
The {\ft server} directive tells HAProxy where to find the proxied servers.
The {\ft appsession} directory makes a sticky session and uses the a cookie called {\ft WEB2PYSTICKY} for this purpose.

Third, enable this config file and start HAProxy:
\begin{lstlisting}
/etc/init.d/haproxy restart
\end{lstlisting}

You can find similar instructions to setup Pound at the URL

\begin{lstlisting}[keywords={}]
http://web2pyslices.com/main/slices/take_slice/33
\end{lstlisting}

\goodbreak\subsection{Cleaning up sessions}

You should be aware that on a production environment, sessions pile up fast. web2py provides a script called:
\begin{lstlisting}
scripts/sessions2trash.py
\end{lstlisting}
\noindent that when run in the background, periodically deletes all sessions that have not been accessed for a certain amount of time. Web2py provides a script to cleanup these sessions (it works for both file-based sessions and database sessions).

Here are some typical use cases:

\begin{itemize}
\item Delete expired sessions every 5 minutes:
\end{itemize}
\begin{lstlisting}
nohup python web2py.py -S app -M -R scripts/sessions2trash.py &
\end{lstlisting}

\begin{itemize}
\item Delete sessions older than 60 minutes regardless of expiration, with verbose output, then exit:
\end{itemize}
\begin{lstlisting}
python web2py.py -S app -M -R scripts/sessions2trash.py -A -o -x 3600 -f -v
\end{lstlisting}

\begin{itemize}
\item Delete all sessions regardless of expiry and exit:
\end{itemize}
\begin{lstlisting}
python web2py.py -S app -M -R scripts/sessions2trash.py -A -o -x 0
\end{lstlisting}

Here {\ft app} is the name of your application.

\goodbreak\subsection{Uploading files in database}

By default, all uploaded files handled by SQLFORMs are safely renamed and stored in the filesystem under the "uploads" folder. It is possible to instruct web2py to store uploaded files in the database instead.

Now, consider the following table:

\begin{lstlisting}
db.define_table('dog',
    Field('name')
    Field('image', 'upload'))
\end{lstlisting}
\noindent where {\ft dog.image} is of type upload. To make the uploaded image go in the same record as the name of the dog, you must modify the table definition by adding a blob field and link it to the upload field:
\begin{lstlisting}
db.define_table('dog',
    Field('name')
    Field('image', 'upload', uploadfield='image_data'),
    Field('image_data', 'blob'))
\end{lstlisting}

Here "image\_data" is just an arbitrary name for the new blob field.

Line 3 instructs web2py to safely rename uploaded images as usual, store the new name in the image field, and store the data in the uploadfield called "image\_data" instead of storing the data on the filesystem. All of this is be done automatically by SQLFORMs and no other code needs to be changed.

With this tweak, the "uploads" folder is no longer needed.

On Google App Engine, files are stored by default in the database without the need to define an uploadfield, since one is created by default.

\goodbreak\subsection{Collecting tickets}

By default, web2py stores tickets (errors) on the local file system. It would not make sense to store tickets directly in the database, because the most common origin of error in a production environment is database failure.

Storing tickets is never a bottleneck, because this is ordinarily a rare event. Hence, in a production environment with multiple concurrent servers, it is more than adequate to store them in a shared folder. Nevertheless, since only the administrator needs to retrieve tickets, it is also OK to store tickets in a non-shared local "errors" folder and periodically collect them and/or clear them.

One possibility is to periodically move all local tickets to the database.

For this purpose, web2py provides the following script:
\begin{lstlisting}
scripts/tickets2db.py
\end{lstlisting}

By default the script gets the db uri from a file saved into the private folder, {\bf ticket\_storage.txt}. This file should contain a string that is passed directly to a {\bf DAL} instance, like:

\begin{lstlisting}
mysql://username:password@localhost/test
postgres://username:password@localhost/test
...
\end{lstlisting}

This allows to leave the script as it is: if you have multiple applications, it will dynamically choose the right connection for every application. If you want to hardcode the uri in it, edit the second reference to db\_string, right after the {\it except} line.
You can run the script with the command:
\begin{lstlisting}
nohup python web2py.py -S myapp -M -R scripts/tickets2db.py &
\end{lstlisting}
\noindent where myapp is the name of your application.

This script runs in the background and moves all tickets every 5 minutes to a table and removes the local tickets.
You can later view the errors using the admin app, clicking on the "switch to: db" button at the top, with the same exact functionality as if they were stored on the file system.

With this tweak, the "errors" folder does not need to be a shared folder any more, since errors will be stored into the database.

\goodbreak\subsection{Memcache}

\inxx{memcache}

We have shown that web2py provides two types of cache: {\ft cache.ram} and {\ft cache.disk}.
They both work on a distributed environment with multiple concurrent servers, but they do not work as expected. In particular, {\ft cache.ram} will only cache at the server level; thus it becomes useless. {\ft cache.disk} will also cache at the server level unless the "cache" folder is a shared folder that supports locking; thus, instead of speeding things up, it becomes a major bottleneck.

The solution is not to use them, but to use memcache instead. web2py comes with a memcache API.

To use memcache, create a new model file, for example {\ft 0\_memcache.py}, and in this file write (or append) the following code:
\begin{lstlisting}
from gluon.contrib.memcache import MemcacheClient
memcache_servers = ['127.0.0.1:11211']
cache.memcache = MemcacheClient(request, memcache_servers)
cache.ram = cache.disk = cache.memcache
\end{lstlisting}

The first line imports memcache. The second line has to be a list of memcache sockets (server:port).  The third line defines {\ft cache.memcache}.  The fourth line redefines {\ft cache.ram} and {\ft cache.disk} in terms of memcache.

You could choose to redefine only one of them to define a totally new cache object pointing to the Memcache object.

With this tweak the "cache" folder does not need to be a shared folder any more, since it will no longer be accessed.

This code requires having memcache servers running on the local network. You should consult the memcache documentation for information on how to setup those servers.

\goodbreak\subsection{Sessions in memcache}

If you do need sessions and you do not want to use a load balancer with sticky sessions, you have the option to store sessions in memcache:
\begin{lstlisting}
from gluon.contrib.memdb import MEMDB
session.connect(request,response,db=MEMDB(cache.memcache))
\end{lstlisting}

\goodbreak\subsection{Caching with Redis}

~\cite{redis}
An alternative to Memcache is use Redis. \inxx{Redis}

Assuming we have Redis installed and running on localhost at port 6379, we can connect to it using the following code (in a model):

\begin{lstlisting}
from gluon.contrib.redis_cache import RedisCache
cache.redis = RedisCache('localhost:6379',db=None, debug=True)
\end{lstlisting}
\noindent where 'localhost:6379' is the connection string and {\ft db} is not a DAL object but a Redis database name.

We can now use {\ft cache.redis} in place of (or along with) {\ft cache.ram} and {\ft cache.disk}.

We can also obtain Redis statistics by calling:

\begin{lstlisting}
cache.redis.stats()
\end{lstlisting}

\goodbreak\subsection{Sessions in Redis}

If you have Redis in your stack, why not use it for sessions ?
\begin{lstlisting}
from gluon.contrib.redis_session import RedisSession
sessiondb = RedisSession('localhost:6379',db=0, session_expiry=False)
session.connect(request, response, db = sessiondb)
\end{lstlisting}
The code has been tested with ~1M sessions. As long as Redis can fit in memory, the time taken to handle
1 or 1M sessions is the same. While against file-based sessions or db-based sessions
the speedup is unnoticeable for ~40K sessions, over that barrier the improvement is remarkable.
You'll end up with 1 key per session, plus 2 keys, one holding an integer (needed for assigning different session keys) and the other holding the set of all
sessions generated (so for 1000 sessions, 1002 keys).

If {\ft session\_expiry} is not set, sessions will be handled as usual, you'd need to {\footnotesize\href{@///chapter/13\#Cleaning-up-sessions}{cleanup sessions as usual}} once a while.

However, when {\ft session\_expiry} is set will delete automatically sessions after n seconds
(e.g. if set to 3600, session will expire exactly one hour later having been updated the last time)
You should however occasionally run sessions2trash.py just to clean the key holding the set of all
the sessions previously issued (for ~1M sessions, cleaning up requires 3 seconds)

\goodbreak\subsection{Removing applications}

\inxx{removing application}

In a production setting, it may be better not to install the default applications: {\bf admin}, {\bf examples} and {\bf welcome}. Although these applications are quite small, they are not necessary.

Removing these applications is as easy as deleting the corresponding folders under the applications folder.

\goodbreak\subsection{Using replicated databases}

In a high performance environment you may have a master-slave database
architecture with many replicated slaves and perhaps a couple of
replicated servers. The DAL can handle this situation and conditionally
connect to different servers depending on the request parameters. The
API to do this was described in Chapter 6. Here is an example:

\begin{lstlisting}
from random import sample
db = DAL(sample(['mysql://...1','mysql://...2','mysql://...3'], 3))
\end{lstlisting}

In this case, different HTTP requests will be served by different
databases at random, and each DB will be hit more or less with the
same probability.

We can also implement a simple Round-Robin

\begin{lstlisting}
def fail_safe_round_robin(*uris):
     i = cache.ram('round-robin', lambda: 0, None)
     uris = uris[i:]+uris[:i] # rotate the list of uris
     cache.ram('round-robin', lambda: (i+1)%len(uris), 0)
     return uris
db = DAL(fail_safe_round_robin('mysql://...1','mysql://...2','mysql://...3'))
\end{lstlisting}

This is fail-safe in the sense that if the database server assigned to
the request fails to connect, DAL will try the next one in the order.

It is also possible to connect to different databases depending on the requested action or controller. In a master-slave database configuration, some action performs only a read and some person both read/write. The former can safely connect to a slave db server, while the latter should connect to a master. So you can do:

\begin{lstlisting}
if request.function in read_only_actions:
   db = DAL(sample(['mysql://...1','mysql://...2','mysql://...3'], 3))
if request.action in read_only_actions:
   db = DAL(shuffle(['mysql://...1','mysql://...2','mysql://...3']))
else:
   db = DAL(sample(['mysql://...3','mysql://...4','mysql://...5'], 3))
\end{lstlisting}
\noindent where 1,2,3 are slaves and 3,4,5 are masters.

\goodbreak\subsection{Compress static files}

Browsers can decompress content on-the-fly, so compressing content for those browsers saves your bandwidth and theirs, lowering response times.
Nowadays most web servers can compress your content on the fly and send it to the browsers requesting gzipped content.
However, for static files, you are wasting CPU cycles to compress the same content over and over.

You can use {\it scripts/zip\_static\_files.py} to create gzipped versions of your static files and serve those without wasting CPU.
Run as {\ft python web2py.py -S myapp -R scripts/zip\_static\_files.py} in cron. The script takes care to create (or update) the gzipped version and saves them along with your files, appending a.gz to their name.
You just need to let your webserver know when to send those files~\cite{apache-content-negotiation}~\cite{nginx-gzipstatic}

\goodbreak\section{Deploying on PythonAnywhere}

{\ft PythonAnywhere} \inxx{PythonAnywhere}

PythonAnywhere is the simplest way to deploy web2py applications.

PythonAnywhere is a Python development and hosting environment that displays in your web browser and runs on cloud servers. They are already set up with everything you need to run Python
and they support web2py specifically. In our experience PythonAnywhere is easy to use, fast, and powerful. They also provide MySQL databases, python shells and Dropbox integration.
Professional hosting is available if the free basic one is not enough for you.

In order to use PythonAnywhere you need to create an account, login, then use the provided web Dashboard to add a new Web App of type web2py.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/pythonanywhere1.png}\end{center}


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/pythonanywhere2.png}\end{center}


The interface also ask you for an admistrative password.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/pythonanywhere3.png}\end{center}


The web2py folder will be created in your user folder.

Alternatively, you can also use the web based BASH shell to install web2py as you normally do:

\begin{lstlisting}
wget http://www.web2py.com/examples/static/web2py_src.zip
unzip web2py_src.zip
\end{lstlisting}

Always from the shell you should create an admin password for later use:

\begin{lstlisting}
python -c "from gluon.main import save_password; save_password(raw_input('admin  password: '),433)"
\end{lstlisting}

Then visit the "Web" panel using the web interface and edit the "/var/www/<username>\_pythonanywhere\_com\_wsgi.py" file. This is the entry point for your program (in our case web2py) and, as you may guess, it is based on the WSGI protocol.

Edit the "/var/www/<username>\_pythonanywhere\_com\_wsgi.py" file and write in it:

\begin{lstlisting}
import sys
path = '/home/<username>/web2py'
if path not in sys.path: sys.path.append(path)
from wsgihandler import application # the web2py handler
\end{lstlisting}

Here "<username>" is your PythonAnywhere username.

After you've installed web2py, notice that you do not need to start or configure a web server. PythonAnywhere provides one and it is reloaded when you edit the above config file.
or press the "Reload web app" button on the Dashboard. Everyone can immediately access it at the url:

\begin{lstlisting}[keywords={}]
http://yourusername.pythonanywhere.com/
\end{lstlisting}

They also provide a secure version of the site, and you're forced to use it for using the web2py Administrative interface at:

\begin{lstlisting}[keywords={}]
https://yourusername.pythonanywhere.com/admin/default/index
\end{lstlisting}

We thank the PythonAnywhere team for their help and support.

\goodbreak\section{Deploying on Heroku}

~\cite{heroku} \inxx{Heroku}

Heroku is a modern and agile multiplatform hosting solution. It allows to push your applications to a server cloud using Git. In order to user Heroku you must have Git installed and you must have the Heroku SDK installed. You interact heroku using the SDK locally and your commands will be pushed and executed on the server.

Applications running on Heroku cannot rely on a persistent filesystem since it is refreshed periodically. For this reason only the application code can be stored on the file system. All data must be stored in the database. Heroku relies on PostgreSQL. Yet the PostgreSQL is also configured using the Heroku SDK and the URI for the database is assigned dynamically at run-time and stored in an environment variable.

This means that web2py applications must be modified to work on Heroku in order to use the database.

Web2py provides a "heroku.py" script to help you. All you need to do is replace:

\begin{lstlisting}
db = DAL(...)
\end{lstlisting}
\noindent in your code with:

\begin{lstlisting}
from gluon.contrib.heroku import get_db
db = get_db(name=None, pool_size=10)
\end{lstlisting}

Here {\ft name} is the environment variable containing the Heroku PostgreSQL URI (something like {\ft HEROKU\_POSTGRESQL\_RED\_URL}). It defaults to {\ft None} and if there is only one {\ft HEROKU\_POSTGRESQL\_*\_URL} environment variable it will use that. {\ft pool\_size} is the usual DAL pool size.

When non-running on the Heroku platform {\ft get\_db} will use a development database "sqlite://heroku.test.sqlite".

In both cases sessions will be stored in database.

Web2py provides a script "scripts/setup-web2py-heroku.py" to deploy your web2py installation on heroku. It performs the following steps:

It installs virtualenv and the psycopg2 driver:
\begin{lstlisting}
sudo pip install virtualenv
sudo pip install psycopg2
\end{lstlisting}

It creates and activates a virtualenv
\begin{lstlisting}
virtualenv venv --distribute
source venv/bin/activate
\end{lstlisting}

Then creates a requirement file:
\begin{lstlisting}
pip freeze > requirements.txt
\end{lstlisting}

And creates a "Procfile" which tells Heroku how to start web2py:

\begin{lstlisting}
echo "web: python web2py.py -a 'yourpassword' -i 0.0.0.0 -p \$PORT" > Procfile
\end{lstlisting}

You can change this line to use a different server. You must edit it to select your own admin password. {\ft {\textbackslash}\$PORT} is a variable which is correctly escaped since its value is set at runtime. You should also consider starting web2py with gnuicorn using {\ft anyserver.py} since this is one of the recommended web servers for Python.

Finally the script creates a Git repository:

\begin{lstlisting}
git init
git add .
git add Procfile
git commit -a -m "first commit"
\end{lstlisting}
\noindent pushes everything to Heroku, and starts it:

\begin{lstlisting}
heroku create
git push heroku master
heroku addons:add heroku-postgresql:dev
heroku scale web=1
heroku open
\end{lstlisting}

{\ft heroku} here is a shell command part of the Heroku SDK.

We thank Craig Krestiens from Heroku for his help with this recipe.

\goodbreak\section{Deploying on EC2}

\inxx{Amazon EC2}

Amazon Elastic Compute Cloud (Amazon EC2) is a web service that provides resizable computing capacity in the cloud. It is one of the largest and most popular clouds. Many other cloud platforms run on EC2. You can run any application on EC2 by creating and deploying a disk image. Amazon then provides API to replicate the image while sharing part of the file system.

A description of the entire process is beyond the scope of this book but, assuming you have an existing Amazon EC2 account, you can use the Turnkey Hub find and deploy a ready made web2py image:

{\ft https://hub.turnkeylinux.org/amazon/launch/web2py/}

Once your image is deployed you can login into it as a normal VPS and you can manage (backup/restore/copy) it via the Amazon EC2 web interface.

\goodbreak\section{Deploying on Google App Engine}

\inxx{Google App Engine}

It is possible to run web2py code on Google App Engine (GAE)~\cite{gae}, including DAL code.

GAE supports two versions of Python: 2.5 (default) and 2.7 (beta). web2y supports both but uses 2.5 by default (this may change in the future). Look into the "app.yaml" file described below for configuration details.

GAE also supports a Google SQL database (compatible with MySQL) and a Google NoSQL (referred to as "Datastore").
\noindent web2py supports both. If you wish to use Google SQL database follow the instructions on Chapter 6. This section assumes you will be using the Google Datastore.

The GAE platform provides several advantages over normal hosting solutions:

\begin{itemize}
\item Ease of deployment. Google completely abstracts the underlying architecture.

\item Scalability. Google will replicate your app as many times as it takes to serve all concurrent requests.

\item One can choose between a SQL and a NoSQL database (or both together).
\end{itemize}

But also some disadvantages:
\begin{itemize}
\item No read or write access to the file system.

\item No HTTPS unless you use the {\ft appspot.com} domain with a Google certificate.
\end{itemize}
\noindent and some Datastore specific disadvantages:

\begin{itemize}
\item No typical transactions.

\item No complex datastore queries. In particular there are no {\ft JOIN}, {\ft LIKE}, and {\ft DATE/DATETIME} operators.

\item No multiple {\ft OR} sub-queries unless they involve one and the same field.
\end{itemize}

Because of the read-only filesystem, web2py cannot store sessions, error tickets, cache files and uploaded files in the filesystem; they must be stored in the datastore and not in the filesystem.

Here we provide a quick overview of GAE and we focus on web2py specific issues, we refer you to the official GAE documentation online for details.

\begin{quote}Attention: At the time of writing, GAE supports only Python 2.5. Any other version will cause problems. You also must run the web2py source distribution, not a binary distribution.\end{quote}
\goodbreak\subsection{Configuration}

There are three configuration files to be aware of:
\begin{lstlisting}
web2py/app.yaml
web2py/queue.yaml
web2py/index.yaml
\end{lstlisting}

{\ft app.yaml} and {\ft queue.yaml} are most easily created by using the template files {\ft app.example.yaml} and {\ft queue.example.yaml} as starting points. {\ft index.yaml} is created automatically by the Google deployment software.

{\ft app.yaml} has the following structure (it has been shortened using...):

\begin{lstlisting}
application: web2py
version: 1
api_version: 1
runtime: python
handlers:
- url: /_ah/stats.*
  ...
- url: /(?P<a>.+?)/static/(?P<b>.+)
  ...
- url: /_ah/admin/.*
  ...
- url: /_ah/queue/default
  ...
- url: .*
  ...
skip_files:
...
\end{lstlisting}

{\ft app.example.yaml} (when copied to {\ft app.yaml}) is configured to deploy the web2py {\ft welcome} application, but not the {\ft admin} or {\ft example} applications. You must replace {\ft web2py} with the application id that you used when registering with Google App Engine.

{\ft url: /(.+?)/static/(.+)} instructs GAE to serve your app static files directly, without calling web2py logic, for speed.

{\ft url:.*} instructs web2py to use the {\ft gaehandler.py} for every other request.

The {\ft skip\_files:} session is list of regular expressions for files that do not need to deployed on GAE. In particular the lines:

\begin{lstlisting}
 (applications/(admin|examples)/.*)|
 ((admin|examples|welcome)\.(w2p|tar))|
\end{lstlisting}
\noindent tell GAE not to deploy the default applications, except for the unpacked welcome scaffolding application. You can add more applications to be ignored here.

Except for the application id and version, you probably do not need to edit {\ft app.yaml}, though you may wish to exclude the {\ft welcome} application.

The file {\ft queue.yaml} is used to configure GAE task queues.

The file {\ft index.yaml} is automatically generated when you run your application locally using the GAE appserver (the web server that comes with the Google SDK). It contains something like this:

\begin{lstlisting}
indexes:
- kind: person
  properties:
  - name: name
    direction: desc
\end{lstlisting}

In this example it tells GAE to create an index for table "person" that will be used to sort by "name" in reversed alphabetical order. You will not be able to search and sort records in your app without corresponding indexes.

It is important to always run your apps locally with the appserver and try every functionality of your app, before deployment. This will be important for testing purposes, but also to automatically generate the "index.yaml" file.
Occasionally you may want to edit this file and perform cleanup, such as removing duplicate entries.

\goodbreak\subsection{Running and deployment}

{\bf Linux}

Here we assume you have installed the GAE SDK.  At the time of writing, GAE runs on Python 2.5.2.  You can run your app from inside the "web2py" folder by using the appserver command:

\begin{lstlisting}
python2.5 dev_appserver.py ../web2py
\end{lstlisting}

This will start the appserver and you can run your application at the URL:

\begin{lstlisting}[keywords={}]
http://127.0.0.1:8080/
\end{lstlisting}

In order to upload your app on GAE, make sure you have edited the "app.yaml" file as explained before and set the proper application id, then run:

\begin{lstlisting}
python2.5 appcfg.py update ../web2py
\end{lstlisting}

{\bf Mac, Windows}

On Mac and Windows, you can also use the Google App Engine Launcher.
You can download the software from ref.~\cite{gae}.

Choose [File][Add Existing Application], set the path to the path of the top-level web2py folder, and press the [Run] button in the toolbar. After you have tested that it works locally, you can deploy it on GAE by simply clicking on the [Deploy] button on the toolbar (assuming you have an account).


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en9300.png}\end{center}


On GAE, the web2py tickets/errors are also logged into the GAE administration console where logs can be accessed and searched online.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/en9400.png}\end{center}


\goodbreak\subsection{Configuring the handler}

The file {\ft gaehandler.py} is responsible for serving files on GAE and it has a few options. Here are their default values:

\begin{lstlisting}
LOG_STATS = False
APPSTATS = True
DEBUG = False
\end{lstlisting}

{\ft LOG\_STATS} will log the time to serve pages in the GAE logs.

{\ft APPSTATS} will enable GAE appstats which provides profiling statistics. They will be made available at the URL:

\begin{lstlisting}[keywords={}]
http://localhost:8080/_ah/stats
\end{lstlisting}

{\ft DEBUG} sets debug mode. It make no difference in practice unless checked explicitly in your code via {\ft gluon.settings.web2py\_runtime}.

\goodbreak\subsection{Avoid the filesystem}

On GAE you have no access to the filesystem. You cannot open any file for writing.

For this purpose, on GAE, web2py automatically stores all uploaded files in the datastore, whether or not "upload" Field(s) have a {\ft uploadfield} attribute.

You also should store sessions and tickets in the database and you have to be explicit:

\begin{lstlisting}
if request.env.web2py_runtime_gae
    db = DAL('gae')
    session.connect(request,response,db)
else:
    db = DAL('sqlite://storage.sqlite')
\end{lstlisting}

The above code checks whether you are running on GAE, connects to BigTable, and instructs web2py to store sessions and tickets in there. It connects to a sqlite database otherwise. This code is already in the scaffolding app in the file "db.py".

\goodbreak\subsection{Memcache}

If you prefer, you can store sessions in memcache:

\begin{lstlisting}
from gluon.contrib.gae_memcache import MemcacheClient
from gluon.contrib.memdb import MEMDB
cache.memcache = MemcacheClient(request)
cache.ram = cache.disk = cache.memcache

db = DAL('gae')
session.connect(request,response,MEMDB(cache.memcache))
\end{lstlisting}

Notice that on GAE cache.ram and cache.disk should not be used, so we make them point to cache.memcache.

\goodbreak\subsection{Datastore issues}

The absence of multi-entity transactions and typical functionalities of relational databases are what sets GAE apart from other hosting environment. This is the price to pay for high scalability. GAE is an excellent platform if these limitations are tolerable; if not, then a regular hosting platform with a relational database should be considered instead.

If a web2py application does not run on GAE, it is because of one of the limitations discussed above. Most issues can be resolved by removing JOINs from web2py queries and de-normalizing the database.

Google App Engine supports some special field types, such as {\ft ListProperty} and {\ft StringListProperty}. You can use these types with web2py using the following old syntax:

\begin{lstlisting}
from gluon.dal import gae
db.define_table('product',
    Field('name'),
    Field('tags', type=gae.StringListProperty())
\end{lstlisting}
\noindent or the equivalent new syntax:

\begin{lstlisting}
db.define_table('product',
    Field('name'),
    Field('tags', 'list:string')
\end{lstlisting}

In both cases the "tags" field is a {\ft StringListProperty} therefore its values must be lists of strings, compatibly with the GAE documentation. The second notation is to be preferred because web2py will treat the field in a smarter way in the context of forms and because it will work with relational databases too.

Similarly, web2py supports {\ft list:integer} and {\ft list:reference} which map into a {\ft ListProperty(int)}.

{\ft list} types are discussed in more detail in Chapter 6.

\goodbreak\subsection{GAE and https}

If you application has id "myapp" your GAE domain is

\begin{lstlisting}[keywords={}]
http://myapp.appspot.com/
\end{lstlisting}
\noindent and it can also be accessed via HTTPS

\begin{lstlisting}[keywords={}]
https://myapp.appspot.com/
\end{lstlisting}

In this case it will use an "appspot.com" certificate provided by Google.

You can register a DNS entry and use any other domain name you own for your app but you will not be able to use HTTPS on it. At the time of writing, this is a GAE limitation.

\goodbreak\chapter{Other recipes}

\goodbreak\section{Upgrading}

\inxx{upgrades}

In the "site" page of the administrative interface there is an "upgrade now" button. In case this is not feasible or does not work (for example because of a file locking issue), upgrading web2py manually is very easy.

\begin{quote}Simply unzip the latest version of web2py over the old installation.\end{quote}
This will upgrade all the libraries as well as the applications {\bf admin}, {\bf examples}, {\bf welcome}. It will also create a new empty file "NEWINSTALL". Upon restarting, web2py will delete the empty file and package the welcome app into "welcome.w2p" that will be used as the new scaffolding app.
\noindent web2py does not upgrade any file in other existing applications.

\goodbreak\section{How to distribute your applications as binaries}

It is possible to bundle your app with the web2py binary distribution and distribute them together. The license allows this as long you make clear in the license of your app that you are bundling with web2py and add a link to the {\ft web2py.com}.

Here we explain how to do it for Windows:

\begin{itemize}
\item Create your app as usual

\item Using {\bf admin}, bytecode compile your app (one click)

\item Using {\bf admin}, pack your app compiled (another click)

\item Create a folder "myapp"

\item Download a web2py windows binary distribution

\item Unzip it in folder "myapp" and start it (two clicks)

\item Upload using {\bf admin} the previously packed and compiled app with the name "init" (one click)

\item Create a file "myapp/start.bat" that contains "cd web2py; web2py.exe"

\item Create a file "myapp/license" that contains a license for your app and make sure it states that it is being "distributed with an unmodified copy of web2py from web2py.com"

\item Zip the myapp folder into a file "myapp.zip"

\item Distribute and/or sell "myapp.zip"
\end{itemize}

When users will unzip "myapp.zip" and click "run" they will see your app instead of the "welcome" app.
There is no requirement on the user side, not even Python pre-installed.

For Mac binaries the process is the same but there is no need for the "bat" file.

\goodbreak\section{WingIDE, Rad2Py, and Eclipse}

\inxx{WingIDE} \inxx{Eclipse} \inxx{Rad2Py}

You can use web2py with third party IDEs with as WingIDE, Rad2Py, and Eclipse.

Here is a screenshot of using web2py with WingIDE:


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/wingide.png}\end{center}


The general problem with these IDEs (except Rad2Py which is designed specifically to work with web2py) is that they do not understand the context in which models and controllers are executed and therefore autocompletion does not work out of the box.

To make autocompletion work the general trick consists in editing your models and controllers and adding the following code:

\begin{lstlisting}
if False:
    from gluon import *
    request = current.request
    response = current.response
    session = current.session
    cache = current.cache
    T = current.T
\end{lstlisting}
\noindent it does not change the logic as this is never executed but it forces the IDE to parse it and understand where the objects in the global namespace come from (the {\ft gluon} module) thus making autocompletion work.

\goodbreak\section{SQLDesigner}

There is a software called SQLDesigner which allows you to build web2py models visually and then generate the corresponding code. Here is a screenshot.


\goodbreak\begin{center}\includegraphics[width=8cm]{/cygdrive/c/MyFiles/eclipse/workspaces/python/Web2py-book/sources/29-web2py-english/images/designer.png}\end{center}


The version of SQLDesigner which works with web2py can be found here:

{\ft https://github.com/elcio/visualdal}

\goodbreak\section{Publishing a folder}

Consider the problem of sharing a folder (and subfolders) on the web. web2py makes this very easy. You just need a controller like this:

\begin{lstlisting}
from gluon.tools import Expose
def myfolder():
    return dict(files=Expose('/path/to/myfolder'))
\end{lstlisting}
\noindent which you can render in a view with {\ft \{\{=fiels\}\}}. It will create an interface to view the files and folders, and navigate the tree structure. Images will have a preview.

The path prefix "/path/to/myfolder" will be hidden to the visitors. For example a file called "/path/to/myfolder/a/b.txt" and replaced with "base/a/b.txt". The "base" prefix can be specified using the {\ft basename} argument of the Expose function. Using the argument {\ft extensions} can specify a list of file extensions to be listed, other files will be hidden. For example:

\begin{lstlisting}
def myfolder():
    return dict(files=Expose('/path/to/myfolder',basename='.',
                             extensions=['.py', '.jpg']))
\end{lstlisting}

Files and folders that contain the word "private" in the path or have file that start with "." or terminate in "~" are always hidden.

\goodbreak\section{Functional testing}
\noindent web2py comes with a module {\ft gluon.contrib.webclient} which allows functional testing of local and remote web2py applications. Actually, this module is not web2py specific and it can be used for testing and interacting programmatically with any web application, yet it is designed to understand web2py session and web2py postbacks.

Here is an example of usage. The program below creates a client,
connects to the "index" action in order to establish a session,
registers a new user, then logouts, and logins again using the
newly created credentials:

\begin{lstlisting}
from gluon.contrib.webclient import WebClient

client = WebClient('http://127.0.0.1:8000/welcome/default/',
                   postbacks=True)

client.get('index')
# register
data = dict(first_name = 'Homer',
            last_name = 'Simpson',
            email = 'homer@web2py.com',
            password = 'test',
            password_two = 'test',
            _formname = 'register')
client.post('user/register',data = data)

# logout
client.get('user/logout')

# login again
data = dict(email='homer@web2py.com',
            password='test',
            _formname = 'login')
client.post('user/login',data = data)

# check registration and login were successful
client.get('index')
assert('Welcome Homer' in client.text)
\end{lstlisting}

The WebClient constructor takes a URL prefix as argument. In the example that is "http://127.0.0.1:8000/welcome/default/". It does not perform any network IO. The {\ft postbacks} argument defaults to {\ft True} and tells the client how to handle web2py postbacks.

The WebClient object, {\ft client}, has only two methods:
{\ft get} and {\ft post}.  The first argument is always a URL postfix.
The full URL for the GET of POST request is constructed simply by concatenating the prefix and the postfix. The purpose of this is imply making the syntax less verbose for long conversations between client and server.

{\ft data} is a parameter specific of POST request and contains a dictionary of the data to be posted. Web2py forms have a hidden {\ft \_formname} field and its value must be provided unless there is a single form in the page. Web2py forms also contain a hidden {\ft \_formkey} field which is designed to prevent CSRF attacked. It is handled automatically by WebClient.

Both {\ft client.get} and {\ft client.post} accept the following extra arguments:
\begin{itemize}
\item {\ft headers}: a dictionary of optional HTTP headers.

\item {\ft cookies}: a dictionary of optional HTTP cookies.

\item {\ft auth}: a dictionary of parameters to be passed to {\ft urllib2.HTTPBasicAuthHandler().add\_password(**auth)} in order to perform basic authentication. For more information about this we refer to the Python documentation for the urllib2 module.
\end{itemize}

The {\ft client} object in the example carries on a conversation with the server specified in the constructor by making GET and POST requests. It automatically handles all cookies and sends them back to maintain sessions. If it detects that a new session cookie is issued while an existing one is already present, it interprets it as a broken session and raises an exception. If the server returns an HTTP error, it raises an exception. If the server returns an HTTP error which contains a web2py ticket, it returns a RuntimeError exception containing the ticket code.

The {\ft client} object maintains a log of requests in {\ft client.history} and a state associated with its last successful request. The state consists of:

\begin{itemize}
\item {\ft client.status}: the returned status code

\item {\ft client.text}: the content of the page

\item {\ft client.headers}: a dictionary of parsed headers

\item {\ft client.cookies}: a dictionary of parsed cookies

\item {\ft client.sessions}: a dictionary of web2py sessions in the form {\ft \{appname: session\_id\}}.

\item {\ft client.forms}: a dictionary of web2py forms detected in the {\ft client.text}. The dictionary has the form {\ft \{\_formname,\_formkey\}}.
\end{itemize}

The WebClient object does not perform any parsing of the {\ft client.text} returned by the server but this can easily be accomplished with many third-party modules such as BeautifulSoup. For example here is an example code that finds all links in a page downloaded by the client and checks all of them:

\begin{lstlisting}
from BeautifulSoup import BeautifulSoup
dom = BeautifulSoup(client.text)
for link in dom.findAll('a'):
    new_client = WebClient()
    new_client.get(a.href)
    print new_client.status
\end{lstlisting}

\goodbreak\section{Building a minimalist web2py}

Some times we need to deploy web2py in a server with very small memory footprint. In this case we want to strip down web2py to its bare minimum.

An easy way to do it is the following:
\begin{itemize}
\item On a production machine, install the full web2py from source

\item From inside the main web2py folder run
\end{itemize}
\begin{lstlisting}
python scripts/make_min_web2py.py /path/to/minweb2py
\end{lstlisting}
\begin{itemize}
\item Now copy under "/path/to/minweb2py/applications" the applications you want to deploy

\item Deploy "/path/to/minweb2py" to the small footprint server
\end{itemize}

The script "make\_min\_web2py.py" builds a minimalist web2py distribution that does not include:
\begin{itemize}
\item admin

\item examples

\item welcome

\item scripts

\item rarely used contrib modules
\end{itemize}

It does include a "welcome" app consisting of a single file to allow testing deployment.
Look into this script. At the top it contains a detailed list of what is included and what is ignored. You can easily modify it and tailor to your needs.

\goodbreak\section{Fetching an external URL}

\inxx{fetch}

Python includes the {\ft urllib} library for fetching urls:
\begin{lstlisting}
import urllib
page = urllib.urlopen('http://www.web2py.com').read()
\end{lstlisting}

\inxx{API}

This is often fine, but the {\ft urllib} module does not work on the Google App Engine. Google provides a different API for downloading URLs that works on GAE only. In order to make your code portable, web2py includes a {\ft fetch} function that works on GAE as well as other Python installations:
\begin{lstlisting}
from gluon.tools import fetch
page = fetch('http://www.web2py.com')
\end{lstlisting}

\goodbreak\section{Pretty dates}

\inxx{prettydate}

It is often useful to represent a datetime not as "2009-07-25 14:34:56" but as "one year ago". web2py provides a utility function for this:
\begin{lstlisting}
import datetime
d = datetime.datetime(2009,7,25,14,34,56)
from gluon.tools import prettydate
pretty_d = prettydate(d,T)
\end{lstlisting}

The second argument (T) must be passed to allow internationalization for the output.

\goodbreak\section{Geocoding}

\inxx{geocode}

If you need to convert an address (for example: "243 S Wabash Ave, Chicago, IL, USA") into geographical coordinates (latitude and longitude), web2py provides a function to do so.
\begin{lstlisting}
from gluon.tools import geocode
address = '243 S Wabash Ave, Chicago, IL, USA'
(latitude, longitude) = geocode(address)
\end{lstlisting}

The function {\ft geocode} requires a network connection and it connects to the Google geocoding service for the geocoding. The function returns {\ft (0,0)} in case of failure. Notice that the Google geocoding service caps the number of requests, so you should check their service agreement. The {\ft geocode} function is built on top of the {\ft fetch} function and thus it works on GAE.

\goodbreak\section{Pagination}

\inxx{pagination}

This recipe is a useful trick to minimize database access in case of pagination, e.g., when you need to display a list of rows from a database but you want to distribute the rows over multiple pages.

Start by creating a {\bf primes} application that stores the first 1000 prime numbers in a database.

Here is the model {\ft db.py}:
\begin{lstlisting}
db = DAL('sqlite://primes.db')
db.define_table('prime',Field('value','integer'))
def isprime(p):
    for i in range(2,p):
        if p%i==0: return False
    return True
if len(db().select(db.prime.id))==0:
   p=2
   for i in range(1000):
       while not isprime(p): p+=1
       db.prime.insert(value=p)
       p+=1
\end{lstlisting}

Now create an action {\ft list\_items} in the "default.py" controller that reads like this:
\begin{lstlisting}
def list_items():
    if len(request.args): page=int(request.args[0])
    else: page=0
    items_per_page=20
    limitby=(page*items_per_page,(page+1)*items_per_page+1)
    rows=db().select(db.prime.ALL,limitby=limitby)
    return dict(rows=rows,page=page,items_per_page=items_per_page)
\end{lstlisting}

Notice that this code selects one more item than is needed, 20+1. The extra element tells the view whether there is a next page.

Here is the "default/list\_items.html" view:
\begin{lstlisting}[keywords={}]
{{extend 'layout.html'}}

{{for i,row in enumerate(rows):}}
{{if i==items_per_page: break}}
{{=row.value}}<br />
{{pass}}

{{if page:}}
<a href="{{=URL(args=[page-1])}}">previous</a>
{{pass}}

{{if len(rows)>items_per_page:}}
<a href="{{=URL(args=[page+1])}}">next</a>
{{pass}}
\end{lstlisting}

In this way we have obtained pagination with one single select per action, and that one select only selects one row more than we need.

\goodbreak\section{httpserver.log and the Log File Format}

\inxx{httpserver.log}

The web2py web server logs all requests to a file called:
\begin{lstlisting}[keywords={}]
httpserver.log
\end{lstlisting}
\noindent in the root web2py directory. An alternative filename and location
can be specified via web2py command-line options.

New entries are appended to the end of the file each time a request is made. Each line looks like this:
\begin{lstlisting}
127.0.0.1, 2008-01-12 10:41:20, GET, /admin/default/site, HTTP/1.1, 200, 0.270000
\end{lstlisting}

The format is:
\begin{lstlisting}
ip, timestamp, method, path, protocol, status, time_taken
\end{lstlisting}

Where
\begin{itemize}
\item ip is the IP address of the client who made the request

\item timestamp is the date and time of the request in ISO 8601 format, YYYY-MM-DDT HH:MM:SS

\item method is either GET or POST

\item path is the path requested by the client

\item protocol is the HTTP protocol used to send to the client, usually HTTP/1.1

\item status is the one of the HTTP status codes~\cite{status}

\item time\_taken is the amount of time the server took to process the request, in seconds, not including upload/download time.
\end{itemize}

In the appliances repository~\cite{appliances}, you will find an appliance for log analysis.

This logging is disabled by default when using mod\_wsgi since it would be the same as the Apache log.

\goodbreak\section{Populating database with dummy data}

For testing purposes, it is convenient to be able to populate database tables with dummy data. web2py includes a Bayesian classifier already trained to generate dummy but readable text for this purpose.

Here is the simplest way to use it:
\begin{lstlisting}
from gluon.contrib.populate import populate
populate(db.mytable,100)
\end{lstlisting}

It will insert 100 dummy records into db.mytable. It will try to do intelligently by generating short text for string fields, longer text for text fields, integers, doubles, dates, datetimes, times, booleans, etc. for the corresponding fields. It will try to respect requirements imposed by validators. For fields containing the word "name" it will try to generate dummy names. For reference fields it will generate valid references.

If you have two tables (A and B) where B references A, make sure to populate A first and B second.

Because population is done in a transaction, do not attempt to populate too many records at once, particularly if references are involved. Instead, populate 100 at a time, commit, loop.
\begin{lstlisting}
for i in range(10):
    populate(db.mytable,100)
    db.commit()
\end{lstlisting}

You can use the Bayesian classifier to learn some text and generate dummy text that sounds similar but should not make sense:
\begin{lstlisting}
from gluon.contrib.populate import Learner, IUP
ell=Learner()
ell.learn('some very long input text ...')
print ell.generate(1000,prefix=None)
\end{lstlisting}

\goodbreak\section{Accepting credit card payments}

\inxx{Google Wallet} \inxx{Paypal} \inxx{Stripe.com}
\inxx{Authorize.net} \inxx{DowCommerce}

There are multiple ways to accept credit card payments online. web2py provides specific APIs for some of the most popular and practical ones:

\begin{itemize}
\item Google Wallet~\cite{googlewallet}

\item PayPal {\ft paypal}cite

\item Stripe.com~\cite{stripe}

\item Authorize.net~\cite{authorizenet}

\item DowCommerece~\cite{dowcommerce}
\end{itemize}

The first two mechanisms above delegate the process of authenticating the payee to an external service. While this is the best solution for security (your app does not handle any credit card information at all) it makes the process cumbersome (the user must login twice; for example, once with your app, and once with Google) and does not allow your app to handle recurrent payments in an automated way.

There are times when you need more control and you want to generate yourself the entry form for the credit card info and than programmatically ask the processor to transfer money from the credit card to your account.

For this reason web2py provide integration out of the box with Stripe, Authorize.net (the module was developed by John Conde and slightly modified) and DowCommerce. Stripe is the simplest to use and also the cheapest for low volume of transactions (they charge no fix cost but charge about 3\% per transaction). Authorize.net is better for high volumes (has a fixed yearly costs plus a lower cost per transaction).

Mind that in the case of Stripe and Authorize.net your program will be accepting credit cards information. You do not have to store this information and we advise you not to because of the legal requirements involved (check with Visa or MasterCard), but there are times when you may want to store the information for recurrent payments or to reproduce the Amazon one-click pay button.

\goodbreak\subsection{Google Wallet}

The simplest way to use Google Wallet (Level 1) consists of embedding a button on your page that, when clicked, redirects your visitor to a payment page provided by Google.

First of all you need to register a Google Merchant Account at the url:

\begin{lstlisting}[keywords={}]
https://checkout.google.com/sell
\end{lstlisting}

You will need to provide Google with your bank information. Google will assign you a {\ft merchant\_id} and a {\ft merchant\_key} (do not confuse them, keep them secret).

Then you simply need to create the following code in your view:

\begin{lstlisting}[keywords={}]
{{from gluon.contrib.google_wallet import button}}
{{=button(merchant_id="123456789012345",
           products=[dict(name="shoes",
                          quantity=1,
                          price=23.5,
                          currency='USD',
                          description="running shoes black")])}}
\end{lstlisting}

When a visitor clicks on the button, the visitor will be redirected to the Google page where he/she can pay for the items. Here products is a list of products and each product is a dictionary of parameters that you want to pass describing your items (name, quantity, price, currency, description, and other optional ones which you can find described in the Google Wallet documentation).

If you choose to use this mechanism, you may want to generate the values passed to the button programmatically based on your inventory and the visitor shopping chart.

All the tax and shipping information will be handled on the Google side. Same for accounting information. By default your application is not notified that the transaction has been completed therefore you will have to visit your Google Merchant site to see which products have been purchased and paid for, and which products you need to ship to your buyers there. Google will also send you an email with the information.

If you want a tighter integration, you have to use the Level 2 notification API. In that case you can pass more information to Google and Google will call your API to notify about purchases. This allows you to keep accounting information within your application but it requires you expose web services that can talk to Google Wallet.

This is a considerable more difficult problem but such API has already been implemented and it is available as plugin from

\begin{lstlisting}[keywords={}]
http://web2py.com/plugins/static/web2py.plugin.google_checkout.w2p
\end{lstlisting}

You can find the documentation of the plugin in the plugin itself.

\goodbreak\subsection{Paypal}

Paypal integration is not described here but you can find more information about it at this resource:

\begin{lstlisting}[keywords={}]
http://www.web2pyslices.com/main/slices/take_slice/9
\end{lstlisting}

\goodbreak\subsection{Stripe.com}

This is probably one of the easiest way and flexible ways to accept credit card payments.

You need to register with Stripe.com and that is a very easy process, in fact Stripe will assign you an API key to try even before you create any credentials.

Once you have the API key you can accept credit cards with the following code:

\begin{lstlisting}
from gluon.contrib.stripe import Stripe
stripe = Stripe(api_key)
d = stripe.charge(amount=100,
              currency='usd',
              card_number='4242424242424242',
              card_exp_month='5',
              card_exp_year='2012',
              card_cvc_check='123',
              description='the usual black shoes')
if d.get('paid',False):
    # payment accepted
elif:
    # error is in d.get('error','unknown')
\end{lstlisting}

The response, {\ft d}, is a dictionary which you can explore yourself. The card number used in the example is a sandbox and it will always succeed. Each transaction is associated to a transaction id stored in {\ft d['id']}.

Stripe also allows you to verify a transaction at a later time:

\begin{lstlisting}
d = Stripe(key).check(d['id'])
\end{lstlisting}
\noindent and refund a transaction:

\begin{lstlisting}
r = Stripe(key).refund(d['id'])
if r.get('refunded',False):
    # refund was successful
elif:
    # error is in d.get('error','unknown')
\end{lstlisting}

Stripe makes very easy to keep the accounting within your application.

All the communications between your app and Stripe go over RESTful web services. Stripe actually exposes even more services and provides a larger set of Python API. You can read more on their web site.

\goodbreak\subsection{Authorize.Net}

Another simple way to accept credit cards is to use Authorize.Net. As usual you need to register and you will obtain a {\ft login} and a transaction key ({\ft transkey}. Once you have them it works very much like Stripe does:

\begin{lstlisting}
from gluon.contrib.AuthorizeNet import process
if process(creditcard='4427802641004797',
           expiration="122012,
           total=100.0,cvv='123',tax=None,invoice=None,
           login='cnpdev4289', transkey='SR2P8g4jdEn7vFLQ',testmode=True):
   # payment was processed
else:
   # payment was rejected
\end{lstlisting}

If you have a valid Authorize.Net account you should replace the sandbox {\ft login} and {\ft transkey} with those of your account, set {\ft testmode=False} to run on the real platform instead of the sandbox, and use credit card information provided by the visitor.

If {\ft process} returns {\ft True}, the money has been transferred from the visitor credit card account to your Authorize.Net account. {\ft invoice} is just a string that you can set and will be store by Authorize.Net with this transaction so that you can reconcile the data with the information in your application.

Here is a more complex example of workflow where more variables are exposed:
\begin{lstlisting}
from gluon.contrib.AuthorizeNet import AIM
payment = AIM(login='cnpdev4289',
              transkey='SR2P8g4jdEn7vFLQ',
              testmod=True)
payment.setTransaction(creditcard, expiration, total, cvv, tax, invoice)
payment.setParameter('x_duplicate_window', 180) # three minutes duplicate windows
payment.setParameter('x_cust_id', '1324')       # customer ID
payment.setParameter('x_first_name', 'Agent')
payment.setParameter('x_last_name', 'Smith')
payment.setParameter('x_company', 'Test Company')
payment.setParameter('x_address', '1234 Main Street')
payment.setParameter('x_city', 'Townsville')
payment.setParameter('x_state', 'NJ')
payment.setParameter('x_zip', '12345')
payment.setParameter('x_country', 'US')
payment.setParameter('x_phone', '800-555-1234')
payment.setParameter('x_description', 'Test Transaction')
payment.setParameter('x_customer_ip', socket.gethostbyname(socket.gethostname()))
payment.setParameter('x_email', 'you@example.com')
payment.setParameter('x_email_customer', False)

payment.process()
if payment.isApproved():
    print 'Response Code: ', payment.response.ResponseCode
    print 'Response Text: ', payment.response.ResponseText
    print 'Response: ', payment.getResultResponseFull()
    print 'Transaction ID: ', payment.response.TransactionID
    print 'CVV Result: ', payment.response.CVVResponse
    print 'Approval Code: ', payment.response.AuthCode
    print 'AVS Result: ', payment.response.AVSResponse
elif payment.isDeclined():
    print 'Your credit card was declined by your bank'
elif payment.isError():
    print 'It did not work'
print 'approved',payment.isApproved()
print 'declined',payment.isDeclined()
print 'error',payment.isError()
\end{lstlisting}

Notice the code above uses a dummy test account. You need to register with Authorize.Net (it is not a free service) and provide your own login, transkey, testmode=True or False to the AIM constructor.

\goodbreak\section{Dropbox API}

\inxx{Dropbox.com}

Dropbox is a very popular storage service. It not only stores your files but it keeps the cloud storage in sync with all your machines. It allows you to create groups and give read/write permissions to the various folders to individual users or groups. It also keeps version history of all your files. It includes a folder called "Public" and each file you put in there will have its own public URL. Dropbox is a great way to collaborate.

You can access dropbox easily by registering at

\begin{lstlisting}[keywords={}]
https://www.dropbox.com/developers
\end{lstlisting}
\noindent you will get an {\ft APP\_KEY} and an {\ft APP\_SECRET}. Once you have them you can use Dropbox to authenticate your users.

Create a file called "yourapp/private/dropbox.key" and in it write
\begin{lstlisting}[keywords={}]
<APP_KEY>:<APP_SECERT>:app_folder
\end{lstlisting}
where {\ft <APP\_KEY>} and {\ft APP\_SECRET} are your key and secret.

Then in "models/db.py" do:

\begin{lstlisting}
from gluon.contrib.login_methods.dropbox_account import use_dropbox
use_janrain(auth,filename='private/dropbox.key')
mydropbox = auth.settings.login_form
\end{lstlisting}

This will allow users to login into your app using their dropbox credentials, and your program will be able to upload files into their dropbox account:

\begin{lstlisting}
stream = open('localfile.txt','rb')
mydropbox.put('destfile.txt',stream)
\end{lstlisting}
\noindent download files:

\begin{lstlisting}
stream = mydropbox.get('destfile.txt')
open('localfile.txt','wb').write(read)
\end{lstlisting}
\noindent and get directory listings:

\begin{lstlisting}
contents = mydropbox.dir(path = '/')['contents']
\end{lstlisting}

\goodbreak\section{Twitter API}

Here are some quick examples on how to post/get tweets. No third-party libraries are required, since Twitter uses simple RESTful APIs.

Here is an example of how to post a tweet:
\begin{lstlisting}
def post_tweet(username,password,message):
    import urllib, urllib2, base64
    import gluon.contrib.simplejson as sj
    args= urllib.urlencode([('status',message)])
    headers={}
    headers['Authorization'] = 'Basic '+base64.b64encode(
        username+':'+password)
    req = urllib2.Request(
        'http://twitter.com/statuses/update.json',
        args, headers)
    return  sj.loads(urllib2.urlopen(req).read())
\end{lstlisting}

Here is an example of how to receive tweets:
\begin{lstlisting}
def get_tweets():
    user='web2py'
    import urllib
    import gluon.contrib.simplejson as sj
    page = urllib.urlopen('http://twitter.com/%s?format=json' % user).read()
    tweets=XML(sj.loads(page)['#timeline'])
    return dict(tweets=tweets)
\end{lstlisting}

For more complex operations, refer to the Twitter API documentation.

\goodbreak\section{Streaming virtual files}

\inxx{streaming}

It is common for malicious attackers to scan web sites for vulnerabilities. They use security scanners like Nessus to explore the target web sites for scripts that are known to have vulnerabilities. An analysis of web server logs from a scanned machine or directly in the Nessus database reveals that most of the known vulnerabilities are in PHP scripts and ASP scripts. Since we are running web2py, we do not have those vulnerabilities, but we will still be scanned for them. This is annoying, so we like to respond to those vulnerability scans and make the attacker understand their time is being wasted.

One possibility is to redirect all requests for.php,.asp, and anything suspicious to a dummy action that will respond to the attack by keeping the attacker busy for a large amount of time. Eventually the attacker will give up and will not scan us again.

This recipe requires two parts.

A dedicated application called {\bf jammer} with a "default.py" controller as follows:
\begin{lstlisting}
class Jammer():
   def read(self,n): return 'x'*n
def jam(): return response.stream(Jammer(),40000)
\end{lstlisting}

When this action is called, it responds with an infinite data stream full of "x"-es. 40000 characters at a time.

The second ingredient is a "route.py" file that redirects any request ending in.php,.asp, etc. (both upper case and lower case) to this controller.
\begin{lstlisting}
route_in=(
 ('.*\.(php|PHP|asp|ASP|jsp|JSP)','jammer/default/jam'),
)
\end{lstlisting}

The first time you are attacked you may incur a small overhead, but our experience is that the same attacker will not try twice.

\end{fullwidth}

\backmatter
\printindex

\begin{thebibliography}{999}
\bibitem{web2py} \url{http://www.web2py.com}
\bibitem{python} \url{http://www.python.org}
\bibitem{sql-w} \url{http://en.wikipedia.org/wiki/SQL}
\bibitem{sqlite} \url{http://www.sqlite.org/}
\bibitem{mysql} \url{http://www.mysql.com/}
\bibitem{postgres} \url{http://www.postgresql.org/}
\bibitem{mssql} \url{http://www.microsoft.com/sqlserver}
\bibitem{firebird} \url{http://www.firebirdsql.org/}
\bibitem{oracle} \url{http://www.oracle.com/database/index.html}
\bibitem{db2} \url{http://www-01.ibm.com/software/data/db2/}
\bibitem{informix} \url{http://www-01.ibm.com/software/data/informix/}
\bibitem{ingresdb} \url{http://www.ingres.com/}
\bibitem{mongodb} \url{http://www.mongodb.org/}
\bibitem{gae} \url{http://code.google.com/appengine/}
\bibitem{html-w} \url{http://en.wikipedia.org/wiki/HTML}
\bibitem{html-o} \url{http://www.w3.org/TR/REC-html40/}
\bibitem{php} \url{http://www.php.net/}
\bibitem{owasp} \url{http://www.owasp.org}
\bibitem{rocket} \url{https://launchpad.net/rocket}
\bibitem{wsgi-w} \url{http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface}
\bibitem{wsgi-o} \url{http://www.python.org/dev/peps/pep-0333/}
\bibitem{ssl} \url{http://en.wikipedia.org/wiki/Secure_Sockets_Layer}
\bibitem{pythonsecurity} \url{http://www.pythonsecurity.org}
\bibitem{appliances} \url{http://www.web2py.com/appliances}
\bibitem{usergroup} \url{http://www.web2py.com/examples/default/usergroups}
\bibitem{alterego} \url{http://www.web2py.com/AlterEgo}
\bibitem{style} \url{http://www.python.org/dev/peps/pep-0008/}
\bibitem{lgpl3} \url{http://www.gnu.org/licenses/lgpl.html}
\bibitem{editarea} \url{http://www.cdolivet.com/editarea/}
\bibitem{simplejson} \url{http://pypi.python.org/pypi/simplejson}
\bibitem{pyrtf} \url{http://pyrtf.sourceforge.net/}
\bibitem{pyrss2gen} \url{http://www.dalkescientific.com/Python/PyRSS2Gen.html}
\bibitem{feedparser} \url{http://packages.python.org/feedparser/}
\bibitem{markdown2} \url{https://github.com/trentm/python-markdown2}
\bibitem{memcache} \url{http://www.tummy.com/Community/software/python-memcached/}
\bibitem{jquery} \url{http://jquery.com/}
\bibitem{guido} \url{http://www.network-theory.co.uk/docs/pytut/}
\bibitem{lutz} \url{http://oreilly.com/catalog/9780596158071}
\bibitem{pydocs} \url{http://www.python.org/doc/}
\bibitem{css-w} \url{http://en.wikipedia.org/wiki/Cascading_Style_Sheets}
\bibitem{css-o} \url{http://www.w3.org/Style/CSS/}
\bibitem{css-school} \url{http://www.w3schools.com/css/}
\bibitem{js-w} \url{http://en.wikipedia.org/wiki/JavaScript}
\bibitem{js-b} \url{http://www.amazon.com/dp/0596000480}
\bibitem{xmlrpc} \url{http://www.xmlrpc.com/}
\bibitem{oembed} \url{http://oembed.com/}
\bibitem{qdb} \url{http://code.google.com/p/rad2py/wiki/QdbRemotePythonDebugger}
\bibitem{http-w} \url{http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol}
\bibitem{http-o} \url{http://www.w3.org/Protocols/rfc2616/rfc2616.html}
\bibitem{googlewallet} \url{https://wallet.google.com/manage}
\bibitem{stripe} \url{https://stripe.com/}
\bibitem{authorizenet} \url{http://www.authorize.net/}
\bibitem{dowcommerce} \url{http://www.dowcommerce.com/}
\bibitem{PAM} \url{http://en.wikipedia.org/wiki/Pluggable_Authentication_Modules}
\bibitem{cron} \url{http://en.wikipedia.org/wiki/Cron#CRON_expression}
\bibitem{easy-install} \url{http://peak.telecommunity.com/DevCenter/EasyInstall}
\bibitem{PIP} \url{http://www.pip-installer.org}
\bibitem{xml-w} \url{http://en.wikipedia.org/wiki/XML}
\bibitem{xml-o} \url{http://www.w3.org/XML/}
\bibitem{xhtml-w} \url{http://en.wikipedia.org/wiki/XHTML}
\bibitem{xhtml-o} \url{http://www.w3.org/TR/xhtml1/}
\bibitem{xhtml-school} \url{http://www.w3schools.com/xhtml/}
\bibitem{modernizr} \url{http://www.modernizr.com/}
\bibitem{bootstrap} \url{http://twitter.github.com/bootstrap/}
\bibitem{zxjdbc} \url{http://sourceforge.net/projects/zxjdbc/}
\bibitem{psycopg2} \url{http://pypi.python.org/pypi/psycopg2}
\bibitem{pg8000} \url{http://pybrary.net/pg8000/}
\bibitem{pymysql} \url{https://github.com/petehunt/PyMySQL}
\bibitem{mysqldb} \url{http://sourceforge.net/projects/mysql-python}
\bibitem{cxoracle} \url{http://python.net/crew/atuining/cx_Oracle/}
\bibitem{pyodbc} \url{http://pyodbc.sourceforge.net/}
\bibitem{kinterbasdb} \url{http://kinterbasdb.sourceforge.net/}
\bibitem{informixdb} \url{http://informixdb.sourceforge.net/}
\bibitem{ingresdbi} \url{http://pypi.python.org/simple/ingresdbi/}
\bibitem{cubridb} \url{http://www.cubrid.org/}
\bibitem{Sybase} \url{http://www.sybase.com/}
\bibitem{Teradata} \url{http://www.teradata.com/products-and-services/database}
\bibitem{SAPDB} \url{http://www.sapdb.org/}
\bibitem{pymongo} \url{http://pypi.python.org/pypi/pymongo/}
\bibitem{IMAP} \url{http://docs.python.org/library/imaplib.html}
\bibitem{quoteall} \url{http://docs.python.org/library/csv.html\#csv.QUOTE_ALL}
\bibitem{RFC2616} \url{http://www.faqs.org/rfcs/rfc2616.html}
\bibitem{RFC2396} \url{http://www.faqs.org/rfcs/rfc2396.html}
\bibitem{RFC3490} \url{http://tools.ietf.org/html/rfc3490}
\bibitem{RFC3492} \url{http://tools.ietf.org/html/rfc3492}
\bibitem{source1} \url{ttp://mail.python.org/pipermail/python-list/2007-June/617126.html}
\bibitem{regexlib} \url{ttp://mail.python.org/pipermail/python-list/2007-June/617126.html}
\bibitem{recaptcha} \url{http://www.recaptcha.net}
\bibitem{recaptchagoogle} \url{http://www.google.com/recaptcha}
\bibitem{blogspot1} \url{http://gdwarner.blogspot.com/2008/10/brief-pyjamas-django-tutorial.html}
\bibitem{ReportLab} \url{http://www.reportlab.org}
\bibitem{jquery-ui} \url{http://ui.jquery.com/}
\bibitem{jquery-b} \url{http://www.learningjquery.com/}
\bibitem{apache} \url{http://www.apache.org/}
\bibitem{Nginx} \url{http://wiki.nginx.org/Main}
\bibitem{lighttpd} \url{http://www.lighttpd.net/}
\bibitem{cherokee} \url{http://www.cherokee-project.com/download/}
\bibitem{cgi} \url{http://en.wikipedia.org/wiki/Common_Gateway_Interface}
\bibitem{modwsgi} \url{http://code.google.com/p/modwsgi/}
\bibitem{fastcgi} \url{http://www.fastcgi.com/}
\bibitem{openssl} \url{http://www.openssl.org/}
\bibitem{uwsgi} \url{http://projects.unbit.it/uwsgi/}
\bibitem{apache1} \url{http://httpd.apache.org/download.cgi}
\bibitem{modwsgi1} \url{http://adal.chiriliuc.com/mod_wsgi/revision_1018_2.3/mod_wsgi_py25_apache22/mod_wsgi.so}
\bibitem{apache2} \url{http://httpd.apache.org/docs/2.2/mod/core.html}
\bibitem{pound} \url{http://www.apsis.ch/pound/}
\bibitem{haproxy} \url{http://haproxy.1wt.eu/}
\bibitem{redis} \url{http://redis.io/}
\bibitem{apache-content-negotiation} \url{http://httpd.apache.org/docs/2.2/content-negotiation.html}
\bibitem{nginx-gzipstatic} \url{http://wiki.nginx.org/HttpGzipStaticModule}
\bibitem{heroku} \url{https://devcenter.heroku.com/articles/python}
\bibitem{status} \url{http://en.wikipedia.org/wiki/List_of_HTTP_status_codes}
\end{thebibliography}
\end{document}

